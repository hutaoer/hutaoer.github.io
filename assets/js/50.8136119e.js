(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{414:function(t,e,v){"use strict";v.r(e);var _=v(45),a=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"react-知识链路梳理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#react-知识链路梳理"}},[t._v("#")]),t._v(" React 知识链路梳理")]),t._v(" "),v("h2",{attrs:{id:"fiber机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#fiber机制"}},[t._v("#")]),t._v(" fiber机制")]),t._v(" "),v("ul",[v("li",[t._v("render 阶段是允许暂停、终止和重启的。")]),t._v(" "),v("li",[t._v("render 阶段的生命周期都可能是被重复执行的。")])]),t._v(" "),v("h3",{attrs:{id:"废弃的api"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#废弃的api"}},[t._v("#")]),t._v(" 废弃的API")]),t._v(" "),v("ul",[v("li",[t._v("废弃的API有："),v("code",[t._v("componentWillMount")]),t._v(","),v("code",[t._v("componentWillUpdate")]),t._v(","),v("code",[t._v("componentWillReceiveProps")]),t._v("，都是处于render阶段，可能被重复执行的。")]),t._v(" "),v("li",[t._v("这些API使用不推荐的操作：\n"),v("ul",[v("li",[t._v("在"),v("code",[t._v("componentWillMount")]),t._v("中，请求数据，应该放到"),v("code",[t._v("componentDidMount")]),t._v("中。首屏渲染依然会在数据返回之前执行。")]),t._v(" "),v("li",[v("code",[t._v("componentWillUpdate")]),t._v("和"),v("code",[t._v("componentWillReceiveProps")]),t._v("中滥用"),v("code",[t._v("setState")]),t._v("导致死循环。")])])]),t._v(" "),v("li",[t._v("fiber异步渲染机制下，可能导致的bug:\n"),v("ul",[v("li",[t._v("由于render阶段，生命周期可以重复执行，"),v("code",[t._v("componentWillMount")]),t._v("被打断、重复多次后，可能会发出多个请求。")])])]),t._v(" "),v("li",[t._v("新的生命周期："),v("code",[t._v("getDerivedStateFromProps")]),t._v("是静态方法，不能访问"),v("code",[t._v("this")])]),t._v(" "),v("li",[t._v("React 16 改造生命周期的动机是为了配合 fiber 架构带来的异步渲染机制。")])]),t._v(" "),v("h2",{attrs:{id:"数据传递"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据传递"}},[t._v("#")]),t._v(" 数据传递")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("UI = render(data)")]),t._v(", 视图会随着数据变化而变化。")])]),t._v(" "),v("h3",{attrs:{id:"props"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#props"}},[t._v("#")]),t._v(" props")]),t._v(" "),v("ul",[v("li",[t._v("基于"),v("code",[t._v("props")]),t._v("的单向数据流，当前组件的"),v("code",[t._v("state")]),t._v("以"),v("code",[t._v("props")]),t._v("的形式流动时，只能流向组件树中比自己层级更低的组件。"),v("code",[t._v("props")]),t._v("传参适用于\n"),v("ul",[v("li",[t._v("父子间的组件通信")]),t._v(" "),v("li",[t._v("兄弟组件间的数据通信")]),t._v(" "),v("li",[t._v("其他场景，不推荐，不如超过了两层关系传递数据。")])])]),t._v(" "),v("li",[t._v("父组件的更新，都会触发子组件"),v("code",[t._v("componentWillReceiveProps")]),t._v("，而不仅仅是传入的"),v("code",[t._v("props")]),t._v("发生改变。")])]),t._v(" "),v("h3",{attrs:{id:"发布订阅模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#发布订阅模式"}},[t._v("#")]),t._v(" 发布订阅模式")]),t._v(" "),v("ul",[v("li",[t._v("常见的有："),v("code",[t._v("socket.io")]),t._v(", "),v("code",[t._v("Node.js")]),t._v("中的"),v("code",[t._v("EventEmitter")]),t._v("，"),v("code",[t._v("Vue.js")]),t._v("中的"),v("code",[t._v("EventBus")])]),t._v(" "),v("li",[v("code",[t._v("target.addEventListener(type, listener, useCapture")]),t._v(" 创建事件监听器")]),t._v(" "),v("li",[t._v("监听位置和触发事件的位置不受限制。事件的监听即订阅，事件的触发即发布。")]),t._v(" "),v("li",[t._v("使用发布订阅模式，可以在任意的组件间进行通信。")])]),t._v(" "),v("h3",{attrs:{id:"context-api"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#context-api"}},[t._v("#")]),t._v(" Context API")]),t._v(" "),v("ul",[v("li",[t._v("16.3 版本后，新的"),v("code",[t._v("context API")]),t._v("，即使组件的"),v("code",[t._v("shouldComponentUpdate")]),t._v("返回"),v("code",[t._v("false")]),t._v(",它依然可以穿透组件，向子组件进行传播。")])]),t._v(" "),v("h3",{attrs:{id:"redux"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[t._v("#")]),t._v(" Redux")]),t._v(" "),v("ul",[v("li",[t._v("Redux是js的状态容器。由三部分组成："),v("code",[t._v("store")]),t._v(","),v("code",[t._v("action")]),t._v(","),v("code",[t._v("reducer")]),t._v(","),v("code",[t._v("redux")]),t._v("工作流程中，数据是严格单向的。")]),t._v(" "),v("li",[v("code",[t._v("store")]),t._v("是单一的数据源，只读。")]),t._v(" "),v("li",[v("code",[t._v("action")]),t._v("是对变化的描述，包含"),v("code",[t._v("type")]),t._v("和"),v("code",[t._v("payload")])]),t._v(" "),v("li",[t._v("使用"),v("code",[t._v("dispatch")]),t._v("来派发"),v("code",[t._v("action")]),t._v(","),v("code",[t._v("store.dispatch(action)")]),t._v(", "),v("code",[t._v("action")]),t._v("会进入到"),v("code",[t._v("reducer")]),t._v("触发对应的更新。")]),t._v(" "),v("li",[v("code",[t._v("reducer")]),t._v("纯函数，对变化进行分发和处理，返回新的数据给"),v("code",[t._v("store")])])]),t._v(" "),v("h2",{attrs:{id:"函数组件与类组件对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数组件与类组件对比"}},[t._v("#")]),t._v(" 函数组件与类组件对比")]),t._v(" "),v("ul",[v("li",[t._v("类组件需要继承，函数组件不需要")]),t._v(" "),v("li",[t._v("类组件可以访问生命周期方法，函数组件不可以")]),t._v(" "),v("li",[t._v("类组件中可以获取实例化后的this，然后可以调用各种实例方法，有生命周期钩子。")]),t._v(" "),v("li",[t._v("类组件中有state状态，函数组件没有。")])]),t._v(" "),v("h3",{attrs:{id:"类组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类组件"}},[t._v("#")]),t._v(" 类组件")]),t._v(" "),v("ul",[v("li",[t._v("是基于面向对象的一种封装，提供了各种钩子函数，但对于一些简单的场景，类组件的实现有些复杂。")]),t._v(" "),v("li",[t._v("类组件的内部逻辑难以拆分和复用")]),t._v(" "),v("li",[t._v("面向对象编程思想。")])]),t._v(" "),v("h3",{attrs:{id:"函数组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数组件"}},[t._v("#")]),t._v(" 函数组件")]),t._v(" "),v("ul",[v("li",[t._v("轻量、灵活。")]),t._v(" "),v("li",[t._v("函数组件会捕获"),v("code",[t._v("render")]),t._v("内部的状态，这是与类组件最大的不同。")]),t._v(" "),v("li",[t._v("函数式编程思想。")])]),t._v(" "),v("h2",{attrs:{id:"react-hooks"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks"}},[t._v("#")]),t._v(" React Hooks")]),t._v(" "),v("ul",[v("li",[t._v("16.8 版本开始推广的。")])]),t._v(" "),v("h3",{attrs:{id:"使用原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用原则"}},[t._v("#")]),t._v(" 使用原则")]),t._v(" "),v("ul",[v("li",[t._v("只在React 函数中使用 Hook")]),t._v(" "),v("li",[t._v("不要在循环、条件或嵌套中使用 Hook")])]),t._v(" "),v("h3",{attrs:{id:"底层实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#底层实现"}},[t._v("#")]),t._v(" 底层实现")]),t._v(" "),v("ul",[v("li",[t._v("依赖于顺序链表，"),v("code",[t._v("hooks")]),t._v("的本质是链表。所有的hook是通过单向链表存储的，每个"),v("code",[t._v("hook")]),t._v("是一个对象。")]),t._v(" "),v("li",[t._v("首次渲染的时候，调用"),v("code",[t._v("moutState")]),t._v("构建链表并渲染")]),t._v(" "),v("li",[t._v("二次渲染的时候，调用"),v("code",[t._v("updateState")]),t._v("一次遍历链表并渲染。")]),t._v(" "),v("li",[t._v("hooks的渲染是通过"),v("code",[t._v("依次遍历")]),t._v("来定位每个hook的内容的。如果前后两次读到的链表在顺序上的位置不一样，那么渲染就会出现问题。")])]),t._v(" "),v("h2",{attrs:{id:"虚拟dom"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),v("ul",[v("li",[t._v("本质上是"),v("code",[t._v("js")]),t._v("和"),v("code",[t._v("DOM")]),t._v("之间的一个映射缓存，一个能描述"),v("code",[t._v("DOM")]),t._v("结构和属性的js对象。")]),t._v(" "),v("li",[t._v("简单来讲，虚拟DOM是一个js对象，是对真实DOM的描述。")]),t._v(" "),v("li",[t._v("挂载阶段：通过"),v("code",[t._v("JSX")]),t._v("，构建出虚拟DOM树，然后通过"),v("code",[t._v("ReactDOM.render")]),t._v("实现虚拟DOM到真实DOM的映射。")]),t._v(" "),v("li",[t._v("更新阶段：页面的变化，会先作用于虚拟DOM，虚拟DOM借助diff算法，对比出需要改变的DOM，然后将这些改变作用于真实DOM。")])]),t._v(" "),v("h3",{attrs:{id:"原始的方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原始的方案"}},[t._v("#")]),t._v(" 原始的方案")]),t._v(" "),v("ul",[v("li",[t._v("原生对DOM操作，比较繁琐。")]),t._v(" "),v("li",[t._v("jQuery，解决浏览器兼容性，API更人性化，链式调用。")]),t._v(" "),v("li",[t._v("模板引擎，拼接DOM。没有缓存，更新的时候，性能存在瓶颈。")]),t._v(" "),v("li",[t._v("使用虚拟DOM，更多的考虑是在于开发体验和研发效率，虚拟DOM不一定回带来更高的渲染效率。")]),t._v(" "),v("li",[t._v("模板渲染过程：动态生成HTML字符串 -> 旧的DOM元素整体被替换为新的DOM元素（全量更新）")]),t._v(" "),v("li",[t._v("虚拟DOM渲染过程：构建新的虚拟DOM树 -> 通过diff对比出新旧两个树的差异 -> 差量更新DOM")])]),t._v(" "),v("h3",{attrs:{id:"为什么要使用虚拟dom"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用虚拟dom"}},[t._v("#")]),t._v(" 为什么要使用虚拟DOM")]),t._v(" "),v("ul",[v("li",[t._v("模板引擎和虚拟DOM存在着递进的关系。")]),t._v(" "),v("li",[t._v("解决了研发体验、研发效率、和跨平台的问题。")]),t._v(" "),v("li",[t._v("解决跨平台问题：同一套虚拟DOM可以映射为不同平台的渲染元素。")])]),t._v(" "),v("h2",{attrs:{id:"diff-算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法"}},[t._v("#")]),t._v(" diff 算法")]),t._v(" "),v("ul",[v("li",[t._v("调和不等同于diff.")]),t._v(" "),v("li",[t._v("React 15 使用的是 "),v("code",[t._v("Stack Reconciler")]),t._v("，同步递归，不可被打断。如果嵌套节点层级很深，递归的过程时间会很长，导致js长时间的占用主线程，从而导致页面的渲染卡顿。")]),t._v(" "),v("li",[t._v("React 16 使用的是 "),v("code",[t._v("Fiber")]),t._v("。从架构来看，是对React核心算法重写；从编码来看，是React内部定义的一种数据结构，是虚拟节点；从工作流来看，Fiber节点保存了组件更新的状态和副作用。")])]),t._v(" "),v("h3",{attrs:{id:"设计思想"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#设计思想"}},[t._v("#")]),t._v(" 设计思想")]),t._v(" "),v("ul",[v("li",[t._v("若两个组件属于同一个类型，它们拥有一样的DOM树形结构")]),t._v(" "),v("li",[t._v("同一层级的一组子节点，可以通过设置"),v("code",[t._v("key")]),t._v("作为唯一标识，来维持各个节点在不同渲染过程中的稳定性。")]),t._v(" "),v("li",[t._v("diff的关键点：1. 递归的进行分层对比；2. 必须是类型一致的节点；3. key属性设置，利于对节点的复用。")])]),t._v(" "),v("h3",{attrs:{id:"reconciler"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#reconciler"}},[t._v("#")]),t._v(" Reconciler")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("Reconciler")]),t._v("中文意思是”调和器“")]),t._v(" "),v("li",[t._v("虚拟DOM保存在内存中，通过"),v("code",[t._v("ReactDOM")]),t._v("等类库的作用，使之与真实的DOM同步，这个过程称之为协调（调和）。")]),t._v(" "),v("li",[t._v("简单讲：就是将虚拟DOM转变为真实DOM的过程。")]),t._v(" "),v("li",[t._v("调和器的工作：组件的挂载、卸载、更新等等。")])]),t._v(" "),v("h2",{attrs:{id:"setstate"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#setstate"}},[t._v("#")]),t._v(" setState")]),t._v(" "),v("ul",[v("li",[t._v("为了避免频繁的二次渲染，setState 有异步更新、批量更新的机制。每次调用"),v("code",[t._v("setState")]),t._v("，将"),v("code",[t._v("state")]),t._v("缓存起来，在合适的时机，将"),v("code",[t._v("state")]),t._v("做合并，针对最新的"),v("code",[t._v("state")]),t._v("做更新渲染。")]),t._v(" "),v("li",[v("code",[t._v("setTimout")]),t._v(" 可以帮助"),v("code",[t._v("setState")]),t._v(" 脱离"),v("code",[t._v("React")]),t._v("的管控，从而变成同步的。一般而言，React管控下的"),v("code",[t._v("setState")]),t._v("一定是异步的。")]),t._v(" "),v("li",[v("code",[t._v("setState")]),t._v("并不是具备同步渲染的特性，而是在特定的场景下，比如在"),v("code",[t._v("setTimout")]),t._v("的回调中的时候，"),v("code",[t._v("isBatchingUpdates")]),t._v("的值，就是"),v("code",[t._v("false")]),t._v("，所以就变成了同步更新。")])]),t._v(" "),v("h3",{attrs:{id:"工作流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#工作流程"}},[t._v("#")]),t._v(" 工作流程")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("setState")]),t._v(" -> "),v("code",[t._v("enqueueSetState")]),t._v(" -> "),v("code",[t._v("enqueueUpState")]),t._v(" -> "),v("code",[t._v("isBatchingUpdates??")])]),t._v(" "),v("li",[v("code",[t._v("isBatchingUpdates")]),t._v("的判断，决定了是立刻渲染，还是等待，是一个全局的锁。默认是"),v("code",[t._v("false")]),t._v("，异步批量更新。")]),t._v(" "),v("li",[v("code",[t._v("isBatchingUpdates(true)")]),t._v(" -> "),v("code",[t._v("dirtyComponents")])]),t._v(" "),v("li",[v("code",[t._v("isBatchingUpdates(false)")]),t._v(" -> 循环更新"),v("code",[t._v("dirtyComponents")])])]),t._v(" "),v("h3",{attrs:{id:"transaction-事务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#transaction-事务"}},[t._v("#")]),t._v(" transaction（事务）")]),t._v(" "),v("ul",[v("li",[t._v("批量更新，就是一次事务的执行。")])]),t._v(" "),v("h3",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("setState")]),t._v("的表现，会因为调用场景的不同而不同。")]),t._v(" "),v("li",[t._v("在生命周期钩子函数及合成事件中，表现为异步。")]),t._v(" "),v("li",[t._v("在"),v("code",[t._v("setTimeout")]),t._v(","),v("code",[t._v("setInterval")]),t._v(", 原生DOM事件中，表现为同步。")])]),t._v(" "),v("h2",{attrs:{id:"fiber"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#fiber"}},[t._v("#")]),t._v(" Fiber")]),t._v(" "),v("ul",[v("li",[t._v("浏览器是多线程的，包括处理DOM和UI的渲染。js是单线程，但是可以操作DOM。")]),t._v(" "),v("li",[t._v("GUI渲染线程与JS线程是互斥的。渲染线程必须互斥，否则渲染结果难以预料。当一个线程执行的时候，另个一线程必须挂起。")]),t._v(" "),v("li",[t._v("js中，事件被触发的时候，将由事件线程把它添加到任务队列末尾，等到js的同步代码执行完成后，在空闲时间执行出队。")]),t._v(" "),v("li",[t._v("架构核心：可中断、可恢复、优先级。")]),t._v(" "),v("li",[t._v("React 15流程：Reconciler -> render")]),t._v(" "),v("li",[t._v("React 16流程：Scheduler -> Reconciler -> render，多了一个更新优先级的调度。\n"),v("ul",[v("li",[t._v("Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler")]),t._v(" "),v("li",[t._v("Reconciler（协调器）—— 负责找出变化的组件")]),t._v(" "),v("li",[t._v("Renderer（渲染器）—— 负责将变化的组件渲染到页面上")])])]),t._v(" "),v("li",[t._v("每个更新任务，会被赋予一个优先级。")]),t._v(" "),v("li",[t._v("Fiber架构是一种同时兼容同步渲染和异步渲染的设计。")]),t._v(" "),v("li",[t._v("深度优先遍历。")])]),t._v(" "),v("h3",{attrs:{id:"首次渲染"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#首次渲染"}},[t._v("#")]),t._v(" 首次渲染")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("ReactDOM.render")]),t._v("触发的首次渲染是同步过程。")]),t._v(" "),v("li",[t._v("几种启动方式：\n"),v("ul",[v("li",[v("code",[t._v("legacy模式")]),t._v("： "),v("code",[t._v("ReactDOM.render(<App/>, rootNode)")]),t._v("，当前版本的方式，同步渲染。")]),t._v(" "),v("li",[v("code",[t._v("blocking模式")]),t._v("： "),v("code",[t._v("ReactDOM.createBlockingRoot(rootNode).render(<App/>)")]),t._v("处于实验中，作为迁移到"),v("code",[t._v("concurrent模式")]),t._v("的一个步骤。")]),t._v(" "),v("li",[v("code",[t._v("concurrent模式")]),t._v("： "),v("code",[t._v("ReactDOM.createRoot(rootNode).render(<App/>)")]),t._v(", 开启异步渲染，目前也是在实验中，React的终极目标。")])])]),t._v(" "),v("li",[v("code",[t._v("React 17")]),t._v("中可以开启"),v("code",[t._v("concurrent")]),t._v("异步渲染，但是是不稳定的，调用方式如下："),v("code",[t._v("ReactDOM.unstable_createNode(rootNode)")])]),t._v(" "),v("li",[t._v("不同渲染模式在挂载阶段的差异，是由"),v("code",[t._v("mode")]),t._v("属性决定的。")])]),t._v(" "),v("h2",{attrs:{id:"事件系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件系统"}},[t._v("#")]),t._v(" 事件系统")]),t._v(" "),v("ul",[v("li",[t._v("一个事件的传播要经过一下3个阶段：\n"),v("ul",[v("li",[t._v("事件捕获：事件从最外层向最内层传递，知道抵达目标元素。")]),t._v(" "),v("li",[t._v("目标阶段：到达目标元素")]),t._v(" "),v("li",[t._v("事件冒泡：从目标元素向外层传递。")])])]),t._v(" "),v("li",[t._v("在"),v("code",[t._v("React")]),t._v("里面，事件在具体的DOM节点上被触发后，都会冒泡到"),v("code",[t._v("document")]),t._v("上。"),v("code",[t._v("document")]),t._v("上所绑定的统一事件处理程序会将事件分发到具体组件实例。")])]),t._v(" "),v("h3",{attrs:{id:"合成事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#合成事件"}},[t._v("#")]),t._v(" 合成事件")]),t._v(" "),v("ul",[v("li",[t._v("符合W3C规范，抹平了不同浏览器的差异。")]),t._v(" "),v("li",[t._v("暴露统一、稳定的，与原生DOM事件相同的事件接口。")]),t._v(" "),v("li",[t._v("可以通过"),v("code",[t._v("e.nativeEvent")]),t._v("访问到原生事件对象")])]),t._v(" "),v("h3",{attrs:{id:"事件工作流"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件工作流"}},[t._v("#")]),t._v(" 事件工作流")]),t._v(" "),v("ul",[v("li",[t._v("事件绑定是在组件挂载时候完成。")]),t._v(" "),v("li",[t._v("最后绑定到"),v("code",[t._v("document")]),t._v("上，统一的事件分发函数，"),v("code",[t._v("dispatchEvent")]),t._v("。事件触发本质，是对"),v("code",[t._v("dispatchEvent")]),t._v("的调用。")]),t._v(" "),v("li",[t._v("整体流程：\n"),v("ul",[v("li",[t._v("事件触发、冒泡到"),v("code",[t._v("docuemnt")])]),t._v(" "),v("li",[t._v("执行"),v("code",[t._v("dispatchEvent")])]),t._v(" "),v("li",[t._v("创建事件对应的合成事件对象"),v("code",[t._v("SyntheticEvent")])]),t._v(" "),v("li",[t._v("收集事件在 "),v("strong",[t._v("捕获阶段")]),t._v(" 所涉及的回调函数和对应的节点实例。")]),t._v(" "),v("li",[t._v("收集事件在 "),v("strong",[t._v("冒泡阶段")]),t._v(" 所涉及的回调函数和对应的节点实例。")]),t._v(" "),v("li",[t._v("将前两步收集的回调按顺序执行，执行时"),v("code",[t._v("SyntheticEvent")]),t._v("作为入参传入每个回调中。")])])]),t._v(" "),v("li",[t._v("收集过程中，仅收集DOM元素对应的Fiber节点。")]),t._v(" "),v("li",[t._v("对于 React 来讲，事件委托帮助其实现了对所有事件的中心化管控。")])]),t._v(" "),v("h2",{attrs:{id:"redux-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redux-2"}},[t._v("#")]),t._v(" Redux")]),t._v(" "),v("ul",[v("li",[t._v("是对 "),v("code",[t._v("Flux")]),t._v(" 架构的一种实现，是单向数据流，一共包含四个方面：\n"),v("ul",[v("li",[v("code",[t._v("View: 视图")])]),t._v(" "),v("li",[v("code",[t._v("Action: 动作")]),t._v("，通过视图来触发")]),t._v(" "),v("li",[v("code",[t._v("Dispatcher: 派发器")]),t._v("，对"),v("code",[t._v("Action")]),t._v("进行分发；")]),t._v(" "),v("li",[v("code",[t._v("Store：数据层")]),t._v(", 存储应用状态，定义修改状态的逻辑。")])])]),t._v(" "),v("li",[t._v("简单描述其过程：用户与"),v("code",[t._v("View")]),t._v("产生交互，发起一个"),v("code",[t._v("action")]),t._v(", "),v("code",[t._v("dispatcher")]),t._v(" 将"),v("code",[t._v("action")]),t._v(" 派发给 "),v("code",[t._v("store")]),t._v("，通知 "),v("code",[t._v("store")]),t._v(" 进行相应的状态更新，状态更新完成后通知 "),v("code",[t._v("view")]),t._v(" 更新界面。")]),t._v(" "),v("li",[t._v("Flux 允许多个 store，Redux 只允许一个。")])]),t._v(" "),v("h3",{attrs:{id:"双向数据流的问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#双向数据流的问题"}},[t._v("#")]),t._v(" 双向数据流的问题")]),t._v(" "),v("ul",[v("li",[t._v("View 和 Model 可以直接通信。")]),t._v(" "),v("li",[t._v("可能会比较混乱，因为 View 的更新可能来自 Model")]),t._v(" "),v("li",[t._v("单向数据流的优点是：数据可预测。")])]),t._v(" "),v("h3",{attrs:{id:"设计思想-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#设计思想-2"}},[t._v("#")]),t._v(" 设计思想")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("Store")]),t._v(": 一个单一的只读的数据源")]),t._v(" "),v("li",[v("code",[t._v("Action")]),t._v(": 对变化的描述")]),t._v(" "),v("li",[v("code",[t._v("Reducer")]),t._v(": 一个函数，对变化分发和处理，将新的数据返回给"),v("code",[t._v("Store")])]),t._v(" "),v("li",[t._v("任何组件都可以从"),v("code",[t._v("Store")]),t._v("读取全局的状态，并派发"),v("code",[t._v("Action")]),t._v("来修改全局状态。")])]),t._v(" "),v("h3",{attrs:{id:"工作原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#工作原理"}},[t._v("#")]),t._v(" 工作原理")]),t._v(" "),v("h4",{attrs:{id:"createstore"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#createstore"}},[t._v("#")]),t._v(" createStore")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("getState")]),t._v("：获取当前的状态")]),t._v(" "),v("li",[v("code",[t._v("subscribe")]),t._v(": 订阅监听函数")]),t._v(" "),v("li",[v("code",[t._v("dispatch")]),t._v(": 派发action, 调用reducer触发订阅。")])]),t._v(" "),v("h4",{attrs:{id:"dispatch"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dispatch"}},[t._v("#")]),t._v(" dispatch")]),t._v(" "),v("ul",[v("li",[t._v("先将"),v("code",[t._v("isDispatching")]),t._v("变量设置为"),v("code",[t._v("true")]),t._v("，")]),t._v(" "),v("li",[t._v("执行"),v("code",[t._v("reducer(state, action)")])]),t._v(" "),v("li",[t._v("执行完后，"),v("code",[t._v("isDispatching")]),t._v("设置为"),v("code",[t._v("false")])]),t._v(" "),v("li",[t._v("上锁的目的，是为了在执行"),v("code",[t._v("reducer")]),t._v("的时候，防止手动执行"),v("code",[t._v("dispatch")]),t._v("，"),v("code",[t._v("reducer")]),t._v("就不再是纯函数了，可能陷入死循环。")])]),t._v(" "),v("h4",{attrs:{id:"触发订阅"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#触发订阅"}},[t._v("#")]),t._v(" 触发订阅")]),t._v(" "),v("ul",[v("li",[t._v("Redux 中，默认的订阅对象就是状态的变化。")]),t._v(" "),v("li",[t._v("store对象创建后，通过调用store.subscribe 来注册监听函数，dispatch 发生时，在 reducer 执行完成后，将 listeners 数组中的监听函数逐个执行。")])]),t._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" listeners "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("currentLisnteners "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nextListeners"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" listeners"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" listener "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" listeners"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("listener")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 确保是两个数组")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("ensureCanMutateNextListeners")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nextListeners "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" currentLisnteners"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\tnextListeners "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" currentLisnteners"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("slice")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),v("ul",[v("li",[t._v("为什么有"),v("code",[t._v("currentLisnteners")]),t._v("和"),v("code",[t._v("nextListeners")]),t._v("两个数组？\n"),v("ul",[v("li",[v("code",[t._v("currentLisnteners")]),t._v("用于确保监听函数执行过程的稳定性，而对注册事件监听的取消都是发生在"),v("code",[t._v("nextListeners")]),t._v("上，因此需要一个稳定的数组。")]),t._v(" "),v("li",[t._v("事件监听注册后，会返回一个取消注册的函数。dispatch 的时候，可能会取消注册，可能会影响执行过程中的 listenrs 数组。因此不能使用同一份数组。")])])])])])}),[],!1,null,null,null);e.default=a.exports}}]);