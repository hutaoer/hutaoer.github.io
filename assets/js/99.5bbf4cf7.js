(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{497:function(t,e,v){"use strict";v.r(e);var _=v(3),a=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react-知识点梳理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-知识点梳理"}},[t._v("#")]),t._v(" React 知识点梳理")]),t._v(" "),e("h2",{attrs:{id:"fiber机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fiber机制"}},[t._v("#")]),t._v(" fiber机制")]),t._v(" "),e("ul",[e("li",[t._v("render 阶段是允许暂停、终止和重启的。")]),t._v(" "),e("li",[t._v("render 阶段的生命周期都可能是被重复执行的。")])]),t._v(" "),e("h3",{attrs:{id:"废弃的api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#废弃的api"}},[t._v("#")]),t._v(" 废弃的API")]),t._v(" "),e("ul",[e("li",[t._v("废弃的API有："),e("code",[t._v("componentWillMount")]),t._v(","),e("code",[t._v("componentWillUpdate")]),t._v(","),e("code",[t._v("componentWillReceiveProps")]),t._v("，都是处于render阶段，可能被重复执行的。")]),t._v(" "),e("li",[t._v("这些API使用不推荐的操作：\n"),e("ul",[e("li",[t._v("在"),e("code",[t._v("componentWillMount")]),t._v("中，请求数据，应该放到"),e("code",[t._v("componentDidMount")]),t._v("中。首屏渲染依然会在数据返回之前执行。")]),t._v(" "),e("li",[e("code",[t._v("componentWillUpdate")]),t._v("和"),e("code",[t._v("componentWillReceiveProps")]),t._v("中滥用"),e("code",[t._v("setState")]),t._v("导致死循环。")])])]),t._v(" "),e("li",[t._v("fiber异步渲染机制下，可能导致的bug:\n"),e("ul",[e("li",[t._v("由于render阶段，生命周期可以重复执行，"),e("code",[t._v("componentWillMount")]),t._v("被打断、重复多次后，可能会发出多个请求。")])])]),t._v(" "),e("li",[t._v("新的生命周期："),e("code",[t._v("getDerivedStateFromProps")]),t._v("是静态方法，不能访问"),e("code",[t._v("this")])]),t._v(" "),e("li",[t._v("React 16 改造生命周期的动机是为了配合 fiber 架构带来的异步渲染机制。")])]),t._v(" "),e("h2",{attrs:{id:"数据传递"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据传递"}},[t._v("#")]),t._v(" 数据传递")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("UI = render(data)")]),t._v(", 视图会随着数据变化而变化。")])]),t._v(" "),e("h3",{attrs:{id:"props"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#props"}},[t._v("#")]),t._v(" props")]),t._v(" "),e("ul",[e("li",[t._v("基于"),e("code",[t._v("props")]),t._v("的单向数据流，当前组件的"),e("code",[t._v("state")]),t._v("以"),e("code",[t._v("props")]),t._v("的形式流动时，只能流向组件树中比自己层级更低的组件。"),e("code",[t._v("props")]),t._v("传参适用于\n"),e("ul",[e("li",[t._v("父子间的组件通信")]),t._v(" "),e("li",[t._v("兄弟组件间的数据通信")]),t._v(" "),e("li",[t._v("其他场景，不推荐，不如超过了两层关系传递数据。")])])]),t._v(" "),e("li",[t._v("父组件的更新，都会触发子组件"),e("code",[t._v("componentWillReceiveProps")]),t._v("，而不仅仅是传入的"),e("code",[t._v("props")]),t._v("发生改变。")])]),t._v(" "),e("h3",{attrs:{id:"发布订阅模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#发布订阅模式"}},[t._v("#")]),t._v(" 发布订阅模式")]),t._v(" "),e("ul",[e("li",[t._v("常见的有："),e("code",[t._v("socket.io")]),t._v(", "),e("code",[t._v("Node.js")]),t._v("中的"),e("code",[t._v("EventEmitter")]),t._v("，"),e("code",[t._v("Vue.js")]),t._v("中的"),e("code",[t._v("EventBus")])]),t._v(" "),e("li",[e("code",[t._v("target.addEventListener(type, listener, useCapture")]),t._v(" 创建事件监听器")]),t._v(" "),e("li",[t._v("监听位置和触发事件的位置不受限制。事件的监听即订阅，事件的触发即发布。")]),t._v(" "),e("li",[t._v("使用发布订阅模式，可以在任意的组件间进行通信。")])]),t._v(" "),e("h3",{attrs:{id:"context-api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#context-api"}},[t._v("#")]),t._v(" Context API")]),t._v(" "),e("ul",[e("li",[t._v("16.3 版本后，新的"),e("code",[t._v("context API")]),t._v("，即使组件的"),e("code",[t._v("shouldComponentUpdate")]),t._v("返回"),e("code",[t._v("false")]),t._v(",它依然可以穿透组件，向子组件进行传播。")])]),t._v(" "),e("h3",{attrs:{id:"redux"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[t._v("#")]),t._v(" Redux")]),t._v(" "),e("ul",[e("li",[t._v("Redux是js的状态容器。由三部分组成："),e("code",[t._v("store")]),t._v(","),e("code",[t._v("action")]),t._v(","),e("code",[t._v("reducer")]),t._v(",在"),e("code",[t._v("redux")]),t._v("工作流程中，数据是严格单向的。")]),t._v(" "),e("li",[e("code",[t._v("store")]),t._v("是单一的数据源，只读。")]),t._v(" "),e("li",[e("code",[t._v("action")]),t._v("是对变化的描述，包含"),e("code",[t._v("type")]),t._v("和"),e("code",[t._v("payload")])]),t._v(" "),e("li",[t._v("使用"),e("code",[t._v("dispatch")]),t._v("来派发"),e("code",[t._v("action")]),t._v(","),e("code",[t._v("store.dispatch(action)")]),t._v(", "),e("code",[t._v("action")]),t._v("会进入到"),e("code",[t._v("reducer")]),t._v("触发对应的更新。")]),t._v(" "),e("li",[e("code",[t._v("reducer")]),t._v("纯函数，对变化进行分发和处理，返回新的数据给"),e("code",[t._v("store")])])]),t._v(" "),e("h2",{attrs:{id:"函数组件与类组件对比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数组件与类组件对比"}},[t._v("#")]),t._v(" 函数组件与类组件对比")]),t._v(" "),e("ul",[e("li",[t._v("类组件需要继承，函数组件不需要")]),t._v(" "),e("li",[t._v("类组件可以访问生命周期方法，函数组件不可以")]),t._v(" "),e("li",[t._v("类组件中可以获取实例化后的this，然后可以调用各种实例方法，有生命周期钩子。")]),t._v(" "),e("li",[t._v("类组件中有state状态，函数组件没有。")])]),t._v(" "),e("h3",{attrs:{id:"类组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类组件"}},[t._v("#")]),t._v(" 类组件")]),t._v(" "),e("ul",[e("li",[t._v("是基于面向对象的一种封装，提供了各种钩子函数，但对于一些简单的场景，类组件的实现有些复杂。")]),t._v(" "),e("li",[t._v("类组件的内部逻辑难以拆分和复用")]),t._v(" "),e("li",[t._v("面向对象编程思想。")])]),t._v(" "),e("h3",{attrs:{id:"函数组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数组件"}},[t._v("#")]),t._v(" 函数组件")]),t._v(" "),e("ul",[e("li",[t._v("轻量、灵活。")]),t._v(" "),e("li",[t._v("函数组件会捕获"),e("code",[t._v("render")]),t._v("内部的状态，这是与类组件最大的不同。")]),t._v(" "),e("li",[t._v("函数式编程思想。")])]),t._v(" "),e("h2",{attrs:{id:"react-hooks"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks"}},[t._v("#")]),t._v(" React Hooks")]),t._v(" "),e("ul",[e("li",[t._v("16.8 版本开始推广的。")])]),t._v(" "),e("h3",{attrs:{id:"使用原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用原则"}},[t._v("#")]),t._v(" 使用原则")]),t._v(" "),e("ul",[e("li",[t._v("只在React 函数中使用 Hook")]),t._v(" "),e("li",[t._v("不要在循环、条件或嵌套中使用 Hook")])]),t._v(" "),e("h3",{attrs:{id:"底层实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#底层实现"}},[t._v("#")]),t._v(" 底层实现")]),t._v(" "),e("ul",[e("li",[t._v("依赖于顺序链表，"),e("code",[t._v("hooks")]),t._v("的本质是链表。所有的hook是通过单向链表存储的，每个"),e("code",[t._v("hook")]),t._v("是一个对象。")]),t._v(" "),e("li",[t._v("首次渲染的时候，调用"),e("code",[t._v("moutState")]),t._v("构建链表并渲染")]),t._v(" "),e("li",[t._v("二次渲染的时候，调用"),e("code",[t._v("updateState")]),t._v("一次遍历链表并渲染。")]),t._v(" "),e("li",[t._v("hooks的渲染是通过"),e("code",[t._v("依次遍历")]),t._v("来定位每个hook的内容的。如果前后两次读到的链表在顺序上的位置不一样，那么渲染就会出现问题。")])]),t._v(" "),e("h2",{attrs:{id:"虚拟dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),e("ul",[e("li",[t._v("本质上是"),e("code",[t._v("js")]),t._v("和"),e("code",[t._v("DOM")]),t._v("之间的一个映射缓存，一个能描述"),e("code",[t._v("DOM")]),t._v("结构和属性的js对象。")]),t._v(" "),e("li",[t._v("简单来讲，虚拟DOM是一个js对象，是对真实DOM的描述。")]),t._v(" "),e("li",[t._v("挂载阶段：通过"),e("code",[t._v("JSX")]),t._v("，构建出虚拟DOM树，然后通过"),e("code",[t._v("ReactDOM.render")]),t._v("实现虚拟DOM到真实DOM的映射。")]),t._v(" "),e("li",[t._v("更新阶段：页面的变化，会先作用于虚拟DOM，虚拟DOM借助diff算法，对比出需要改变的DOM，然后将这些改变作用于真实DOM。")])]),t._v(" "),e("h3",{attrs:{id:"原始的方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原始的方案"}},[t._v("#")]),t._v(" 原始的方案")]),t._v(" "),e("ul",[e("li",[t._v("原生对DOM操作，比较繁琐。")]),t._v(" "),e("li",[t._v("jQuery，解决浏览器兼容性，API更人性化，链式调用。")]),t._v(" "),e("li",[t._v("模板引擎，拼接DOM。没有缓存，更新的时候，性能存在瓶颈。")]),t._v(" "),e("li",[t._v("使用虚拟DOM，更多的考虑是在于开发体验和研发效率，虚拟DOM不一定回带来更高的渲染效率。")]),t._v(" "),e("li",[t._v("模板渲染过程：动态生成HTML字符串 -> 旧的DOM元素整体被替换为新的DOM元素（全量更新）")]),t._v(" "),e("li",[t._v("虚拟DOM渲染过程：构建新的虚拟DOM树 -> 通过diff对比出新旧两个树的差异 -> 差量更新DOM")])]),t._v(" "),e("h3",{attrs:{id:"为什么要使用虚拟dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用虚拟dom"}},[t._v("#")]),t._v(" 为什么要使用虚拟DOM")]),t._v(" "),e("ul",[e("li",[t._v("模板引擎和虚拟DOM存在着递进的关系。")]),t._v(" "),e("li",[t._v("解决了研发体验、研发效率、和跨平台的问题。")]),t._v(" "),e("li",[t._v("解决跨平台问题：同一套虚拟DOM可以映射为不同平台的渲染元素。")])]),t._v(" "),e("h2",{attrs:{id:"diff-算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法"}},[t._v("#")]),t._v(" diff 算法")]),t._v(" "),e("ul",[e("li",[t._v("调和不等同于diff.")]),t._v(" "),e("li",[t._v("React 15 使用的是 "),e("code",[t._v("Stack Reconciler")]),t._v("，同步递归，不可被打断。如果嵌套节点层级很深，递归的过程时间会很长，导致js长时间的占用主线程，从而导致页面的渲染卡顿。")]),t._v(" "),e("li",[t._v("React 16 使用的是 "),e("code",[t._v("Fiber")]),t._v("。从架构来看，是对React核心算法重写；从编码来看，是React内部定义的一种数据结构，是虚拟节点；从工作流来看，Fiber节点保存了组件更新的状态和副作用。")])]),t._v(" "),e("h3",{attrs:{id:"设计思想"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计思想"}},[t._v("#")]),t._v(" 设计思想")]),t._v(" "),e("ul",[e("li",[t._v("若两个组件属于同一个类型，它们拥有一样的DOM树形结构")]),t._v(" "),e("li",[t._v("同一层级的一组子节点，可以通过设置"),e("code",[t._v("key")]),t._v("作为唯一标识，来维持各个节点在不同渲染过程中的稳定性。")]),t._v(" "),e("li",[t._v("diff的关键点：1. 递归的进行分层对比；2. 必须是类型一致的节点；3. key属性设置，利于对节点的复用。")])]),t._v(" "),e("h3",{attrs:{id:"reconciler"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reconciler"}},[t._v("#")]),t._v(" Reconciler")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Reconciler")]),t._v("中文意思是”调和器“")]),t._v(" "),e("li",[t._v("虚拟DOM保存在内存中，通过"),e("code",[t._v("ReactDOM")]),t._v("等类库的作用，使之与真实的DOM同步，这个过程称之为协调（调和）。")]),t._v(" "),e("li",[t._v("简单讲：就是将虚拟DOM转变为真实DOM的过程。")]),t._v(" "),e("li",[t._v("调和器的工作：组件的挂载、卸载、更新等等。")])]),t._v(" "),e("h2",{attrs:{id:"setstate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#setstate"}},[t._v("#")]),t._v(" setState")]),t._v(" "),e("ul",[e("li",[t._v("为了避免频繁的二次渲染，setState 有异步更新、批量更新的机制。每次调用"),e("code",[t._v("setState")]),t._v("，将"),e("code",[t._v("state")]),t._v("缓存起来，在合适的时机，将"),e("code",[t._v("state")]),t._v("做合并，针对最新的"),e("code",[t._v("state")]),t._v("做更新渲染。")]),t._v(" "),e("li",[e("code",[t._v("setTimout")]),t._v(" 可以帮助"),e("code",[t._v("setState")]),t._v(" 脱离"),e("code",[t._v("React")]),t._v("的管控，从而变成同步的。一般而言，React管控下的"),e("code",[t._v("setState")]),t._v("一定是异步的。")]),t._v(" "),e("li",[e("code",[t._v("setState")]),t._v("并不是具备同步渲染的特性，而是在特定的场景下，比如在"),e("code",[t._v("setTimout")]),t._v("的回调中的时候，"),e("code",[t._v("isBatchingUpdates")]),t._v("的值，就是"),e("code",[t._v("false")]),t._v("，所以就变成了同步更新。")])]),t._v(" "),e("h3",{attrs:{id:"工作流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#工作流程"}},[t._v("#")]),t._v(" 工作流程")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("setState")]),t._v(" -> "),e("code",[t._v("enqueueSetState")]),t._v(" -> "),e("code",[t._v("enqueueUpState")]),t._v(" -> "),e("code",[t._v("isBatchingUpdates??")])]),t._v(" "),e("li",[e("code",[t._v("isBatchingUpdates")]),t._v("的判断，决定了是立刻渲染，还是等待，是一个全局的锁。默认是"),e("code",[t._v("false")]),t._v("，异步批量更新。")]),t._v(" "),e("li",[e("code",[t._v("isBatchingUpdates(true)")]),t._v(" -> "),e("code",[t._v("dirtyComponents")])]),t._v(" "),e("li",[e("code",[t._v("isBatchingUpdates(false)")]),t._v(" -> 循环更新"),e("code",[t._v("dirtyComponents")])])]),t._v(" "),e("h3",{attrs:{id:"transaction-事务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#transaction-事务"}},[t._v("#")]),t._v(" transaction（事务）")]),t._v(" "),e("ul",[e("li",[t._v("批量更新，就是一次事务的执行。")])]),t._v(" "),e("h3",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("setState")]),t._v("的表现，会因为调用场景的不同而不同。")]),t._v(" "),e("li",[t._v("在生命周期钩子函数及合成事件中，表现为异步。")]),t._v(" "),e("li",[t._v("在"),e("code",[t._v("setTimeout")]),t._v(","),e("code",[t._v("setInterval")]),t._v(", 原生DOM事件中，表现为同步。")])]),t._v(" "),e("h2",{attrs:{id:"fiber"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fiber"}},[t._v("#")]),t._v(" Fiber")]),t._v(" "),e("ul",[e("li",[t._v("浏览器是多线程的，包括处理DOM和UI的渲染。js是单线程，但是可以操作DOM。")]),t._v(" "),e("li",[t._v("GUI渲染线程与JS线程是互斥的。渲染线程必须互斥，否则渲染结果难以预料。当一个线程执行的时候，另个一线程必须挂起。")]),t._v(" "),e("li",[t._v("js中，事件被触发的时候，将由事件线程把它添加到任务队列末尾，等到js的同步代码执行完成后，在空闲时间执行出队。")]),t._v(" "),e("li",[t._v("架构核心：可中断、可恢复、优先级。")]),t._v(" "),e("li",[t._v("React 15流程：Reconciler -> render")]),t._v(" "),e("li",[t._v("React 16流程：Scheduler -> Reconciler -> render，多了一个更新优先级的调度。\n"),e("ul",[e("li",[t._v("Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler")]),t._v(" "),e("li",[t._v("Reconciler（协调器）—— 负责找出变化的组件")]),t._v(" "),e("li",[t._v("Renderer（渲染器）—— 负责将变化的组件渲染到页面上")])])]),t._v(" "),e("li",[t._v("每个更新任务，会被赋予一个优先级。")]),t._v(" "),e("li",[t._v("Fiber架构是一种同时兼容同步渲染和异步渲染的设计。")]),t._v(" "),e("li",[t._v("深度优先遍历。")])]),t._v(" "),e("h3",{attrs:{id:"首次渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#首次渲染"}},[t._v("#")]),t._v(" 首次渲染")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("ReactDOM.render")]),t._v("触发的首次渲染是同步过程。")]),t._v(" "),e("li",[t._v("几种启动方式：\n"),e("ul",[e("li",[e("code",[t._v("legacy模式")]),t._v("： "),e("code",[t._v("ReactDOM.render(<App/>, rootNode)")]),t._v("，当前版本的方式，同步渲染。")]),t._v(" "),e("li",[e("code",[t._v("blocking模式")]),t._v("： "),e("code",[t._v("ReactDOM.createBlockingRoot(rootNode).render(<App/>)")]),t._v("处于实验中，作为迁移到"),e("code",[t._v("concurrent模式")]),t._v("的一个步骤。")]),t._v(" "),e("li",[e("code",[t._v("concurrent模式")]),t._v("： "),e("code",[t._v("ReactDOM.createRoot(rootNode).render(<App/>)")]),t._v(", 开启异步渲染，目前也是在实验中，React的终极目标。")])])]),t._v(" "),e("li",[e("code",[t._v("React 17")]),t._v("中可以开启"),e("code",[t._v("concurrent")]),t._v("异步渲染，但是是不稳定的，调用方式如下："),e("code",[t._v("ReactDOM.unstable_createNode(rootNode)")])]),t._v(" "),e("li",[t._v("不同渲染模式在挂载阶段的差异，是由"),e("code",[t._v("mode")]),t._v("属性决定的。")])]),t._v(" "),e("h2",{attrs:{id:"事件系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件系统"}},[t._v("#")]),t._v(" 事件系统")]),t._v(" "),e("ul",[e("li",[t._v("一个事件的传播要经过一下3个阶段：\n"),e("ul",[e("li",[t._v("事件捕获：事件从最外层向最内层传递，知道抵达目标元素。")]),t._v(" "),e("li",[t._v("目标阶段：到达目标元素")]),t._v(" "),e("li",[t._v("事件冒泡：从目标元素向外层传递。")])])]),t._v(" "),e("li",[t._v("在"),e("code",[t._v("React")]),t._v("里面，事件在具体的DOM节点上被触发后，都会冒泡到"),e("code",[t._v("document")]),t._v("上。"),e("code",[t._v("document")]),t._v("上所绑定的统一事件处理程序会将事件分发到具体组件实例。")])]),t._v(" "),e("h3",{attrs:{id:"合成事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#合成事件"}},[t._v("#")]),t._v(" 合成事件")]),t._v(" "),e("ul",[e("li",[t._v("符合W3C规范，抹平了不同浏览器的差异。")]),t._v(" "),e("li",[t._v("暴露统一、稳定的，与原生DOM事件相同的事件接口。")]),t._v(" "),e("li",[t._v("可以通过"),e("code",[t._v("e.nativeEvent")]),t._v("访问到原生事件对象")])]),t._v(" "),e("h3",{attrs:{id:"事件工作流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件工作流"}},[t._v("#")]),t._v(" 事件工作流")]),t._v(" "),e("ul",[e("li",[t._v("事件绑定是在组件挂载时候完成。")]),t._v(" "),e("li",[t._v("最后绑定到"),e("code",[t._v("document")]),t._v("上，统一的事件分发函数，"),e("code",[t._v("dispatchEvent")]),t._v("。事件触发本质，是对"),e("code",[t._v("dispatchEvent")]),t._v("的调用。")]),t._v(" "),e("li",[t._v("整体流程：\n"),e("ul",[e("li",[t._v("事件触发、冒泡到"),e("code",[t._v("docuemnt")])]),t._v(" "),e("li",[t._v("执行"),e("code",[t._v("dispatchEvent")])]),t._v(" "),e("li",[t._v("创建事件对应的合成事件对象"),e("code",[t._v("SyntheticEvent")])]),t._v(" "),e("li",[t._v("收集事件在 "),e("strong",[t._v("捕获阶段")]),t._v(" 所涉及的回调函数和对应的节点实例。")]),t._v(" "),e("li",[t._v("收集事件在 "),e("strong",[t._v("冒泡阶段")]),t._v(" 所涉及的回调函数和对应的节点实例。")]),t._v(" "),e("li",[t._v("将前两步收集的回调按顺序执行，执行时"),e("code",[t._v("SyntheticEvent")]),t._v("作为入参传入每个回调中。")])])]),t._v(" "),e("li",[t._v("收集过程中，仅收集DOM元素对应的Fiber节点。")]),t._v(" "),e("li",[t._v("对于 React 来讲，事件委托帮助其实现了对所有事件的中心化管控。")])]),t._v(" "),e("h2",{attrs:{id:"redux-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redux-2"}},[t._v("#")]),t._v(" Redux")]),t._v(" "),e("ul",[e("li",[t._v("是对 "),e("code",[t._v("Flux")]),t._v(" 架构的一种实现，是单向数据流，一共包含四个方面：\n"),e("ul",[e("li",[e("code",[t._v("View: 视图")])]),t._v(" "),e("li",[e("code",[t._v("Action: 动作")]),t._v("，通过视图来触发")]),t._v(" "),e("li",[e("code",[t._v("Dispatcher: 派发器")]),t._v("，对"),e("code",[t._v("Action")]),t._v("进行分发；")]),t._v(" "),e("li",[e("code",[t._v("Store：数据层")]),t._v(", 存储应用状态，定义修改状态的逻辑。")])])]),t._v(" "),e("li",[t._v("简单描述其过程：用户与"),e("code",[t._v("View")]),t._v("产生交互，发起一个"),e("code",[t._v("action")]),t._v(", "),e("code",[t._v("dispatcher")]),t._v(" 将"),e("code",[t._v("action")]),t._v(" 派发给 "),e("code",[t._v("store")]),t._v("，通知 "),e("code",[t._v("store")]),t._v(" 进行相应的状态更新，状态更新完成后通知 "),e("code",[t._v("view")]),t._v(" 更新界面。")]),t._v(" "),e("li",[t._v("Flux 允许多个 store，Redux 只允许一个。")])]),t._v(" "),e("h3",{attrs:{id:"双向数据流的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#双向数据流的问题"}},[t._v("#")]),t._v(" 双向数据流的问题")]),t._v(" "),e("ul",[e("li",[t._v("View 和 Model 可以直接通信。")]),t._v(" "),e("li",[t._v("可能会比较混乱，因为 View 的更新可能来自 Model")]),t._v(" "),e("li",[t._v("单向数据流的优点是：数据可预测。")])]),t._v(" "),e("h3",{attrs:{id:"设计思想-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计思想-2"}},[t._v("#")]),t._v(" 设计思想")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Store")]),t._v(": 一个单一的只读的数据源")]),t._v(" "),e("li",[e("code",[t._v("Action")]),t._v(": 对变化的描述")]),t._v(" "),e("li",[e("code",[t._v("Reducer")]),t._v(": 一个函数，对变化分发和处理，将新的数据返回给"),e("code",[t._v("Store")]),t._v("。"),e("code",[t._v("reducer")]),t._v(" 是一个纯函数，接收旧的 "),e("code",[t._v("state")]),t._v(" 和 "),e("code",[t._v("action")]),t._v("，返回新的 "),e("code",[t._v("state")]),t._v("。")]),t._v(" "),e("li",[t._v("任何组件都可以从"),e("code",[t._v("Store")]),t._v("读取全局的状态，并派发"),e("code",[t._v("Action")]),t._v("来修改全局状态。")])]),t._v(" "),e("h3",{attrs:{id:"工作原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#工作原理"}},[t._v("#")]),t._v(" 工作原理")]),t._v(" "),e("h4",{attrs:{id:"createstore"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#createstore"}},[t._v("#")]),t._v(" createStore")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("getState")]),t._v("：获取当前的状态")]),t._v(" "),e("li",[e("code",[t._v("subscribe")]),t._v(": 订阅监听函数")]),t._v(" "),e("li",[e("code",[t._v("dispatch")]),t._v(": 派发action, 调用reducer触发订阅。")])]),t._v(" "),e("h4",{attrs:{id:"dispatch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dispatch"}},[t._v("#")]),t._v(" dispatch")]),t._v(" "),e("ul",[e("li",[t._v("先将"),e("code",[t._v("isDispatching")]),t._v("变量设置为"),e("code",[t._v("true")]),t._v("，")]),t._v(" "),e("li",[t._v("执行"),e("code",[t._v("reducer(state, action)")])]),t._v(" "),e("li",[t._v("执行完后，"),e("code",[t._v("isDispatching")]),t._v("设置为"),e("code",[t._v("false")])]),t._v(" "),e("li",[t._v("上锁的目的，是为了在执行"),e("code",[t._v("reducer")]),t._v("的时候，防止手动执行"),e("code",[t._v("dispatch")]),t._v("，"),e("code",[t._v("reducer")]),t._v("就不再是纯函数了，可能陷入死循环。")])]),t._v(" "),e("h4",{attrs:{id:"触发订阅"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#触发订阅"}},[t._v("#")]),t._v(" 触发订阅")]),t._v(" "),e("ul",[e("li",[t._v("Redux 中，默认的订阅对象就是状态的变化。")]),t._v(" "),e("li",[t._v("store对象创建后，通过调用"),e("code",[t._v("store.subscribe")]),t._v(" 来注册监听函数，"),e("code",[t._v("dispatch")]),t._v(" 发生时，在 "),e("code",[t._v("reducer")]),t._v(" 执行完成后，将 listeners 数组中的监听函数逐个执行。")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" listeners "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("currentLisnteners "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nextListeners"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" listeners"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" listener "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" listeners"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("listener")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 确保是两个数组")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("ensureCanMutateNextListeners")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nextListeners "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" currentLisnteners"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\tnextListeners "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" currentLisnteners"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("slice")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("ul",[e("li",[t._v("为什么有"),e("code",[t._v("currentLisnteners")]),t._v("和"),e("code",[t._v("nextListeners")]),t._v("两个数组？\n"),e("ul",[e("li",[e("code",[t._v("currentLisnteners")]),t._v("用于确保监听函数执行过程的稳定性，而对注册事件监听的取消都是发生在"),e("code",[t._v("nextListeners")]),t._v("上，因此需要一个稳定的数组。")]),t._v(" "),e("li",[t._v("事件监听注册后，会返回一个取消注册的函数。dispatch 的时候，可能会取消注册，可能会影响执行过程中的 listenrs 数组。因此不能使用同一份数组。")])])])]),t._v(" "),e("h3",{attrs:{id:"注意事项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[t._v("#")]),t._v(" 注意事项")]),t._v(" "),e("ul",[e("li",[t._v("在"),e("code",[t._v("reducer")]),t._v("中，不能修改"),e("code",[t._v("state")]),t._v("，类似"),e("code",[t._v("Object.assign(state, {data: {}})")]),t._v("，这样会修改"),e("code",[t._v("state")]),t._v("。应该这样使用："),e("code",[t._v("Object.assign({}, state, otherData)")])]),t._v(" "),e("li",[t._v("当管理的数据较多的时候，需要对"),e("code",[t._v("reducer")]),t._v("做拆分。每个 "),e("code",[t._v("reducer")]),t._v(" 只负责管理全局 "),e("code",[t._v("state")]),t._v(" 中它负责的一部分。每个 "),e("code",[t._v("reducer")]),t._v(" 的 "),e("code",[t._v("state")]),t._v(" 参数都不同，分别对应它管理的那部分 "),e("code",[t._v("state")]),t._v(" 数据。")]),t._v(" "),e("li",[e("code",[t._v("reducer")]),t._v(" 是纯函数。它仅用于计算下一个 "),e("code",[t._v("state")]),t._v("。它应该是完全可预测的：多次传入相同的输入必须产生相同的输出。它不应做有副作用的操作，如 "),e("code",[t._v("API")]),t._v(" 调用或路由跳转。这些应该在 "),e("code",[t._v("dispatch action")]),t._v(" 前发生。")])]),t._v(" "),e("h3",{attrs:{id:"react-redux"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-redux"}},[t._v("#")]),t._v(" react-redux")]),t._v(" "),e("ul",[e("li",[t._v("容器组件就是使用 "),e("code",[t._v("store.subscribe()")]),t._v(" 从 "),e("code",[t._v("Redux state")]),t._v(" 树中读取部分数据，并通过 "),e("code",[t._v("props")]),t._v(" 来把这些数据提供给要渲染的组件。直接使用"),e("code",[t._v("connect()")]),t._v("方法来生成容器。")]),t._v(" "),e("li",[t._v("定义 "),e("code",[t._v("mapStateToProps")]),t._v(" 函数来指定如何把当前 "),e("code",[t._v("state")]),t._v(" 映射到组件的 "),e("code",[t._v("props")]),t._v(" 中。")]),t._v(" "),e("li",[t._v("定义 "),e("code",[t._v("mapDispatchToProps")]),t._v(" 方法接收 "),e("code",[t._v("dispatch()")]),t._v(" 方法并返回期望注入到展示组件的 "),e("code",[t._v("props")]),t._v(" 中的回调方法。")]),t._v(" "),e("li",[t._v("最后，调用"),e("code",[t._v("connect()")]),t._v("，与组件进行绑定。")]),t._v(" "),e("li",[t._v("在最外层根组件中，使用"),e("code",[t._v("Provider")]),t._v("将根组件包裹。")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" connect "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'react-redux'")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DemoComponent")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Demo "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("connect")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  mapStateToProps"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  mapDispatchToProps\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("DemoComponent"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" Demo\n")])])]),e("h4",{attrs:{id:"异步action"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步action"}},[t._v("#")]),t._v(" 异步action")]),t._v(" "),e("ul",[e("li",[t._v("引入"),e("code",[t._v("redux-thunk")]),t._v("，"),e("code",[t._v("action")]),t._v("函数除了返回action对象外，还可以返回函数。")]),t._v(" "),e("li",[t._v("当 "),e("code",[t._v("action")]),t._v(" 创建函数返回函数时，这个函数会被 "),e("code",[t._v("Redux Thunk")]),t._v(" 执行。这个函数不需要保持纯净；它还可以带有副作用，包括执行异步 API 请求，还可以 "),e("code",[t._v("dispatch action")])]),t._v(" "),e("li",[t._v("通过"),e("code",[t._v("applyMiddleware()")]),t._v("来使用"),e("code",[t._v("redux-chunk")]),t._v("中间件。")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" thunkMiddleware "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'redux-thunk'")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" createLogger "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'redux-logger'")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" createStore"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" applyMiddleware "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'redux'")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" store "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("createStore")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("applyMiddleware")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    thunkMiddleware"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 允许我们 dispatch() 函数")]),t._v("\n    loggerMiddleware "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用来打印 action 日志")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("h4",{attrs:{id:"其他方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#其他方式"}},[t._v("#")]),t._v(" 其他方式")]),t._v(" "),e("ul",[e("li",[t._v("使用 redux-promise 或者 redux-promise-middleware 来 dispatch Promise 来替代函数。")]),t._v(" "),e("li",[t._v("使用 redux-observable 来 dispatch Observable。")]),t._v(" "),e("li",[t._v("使用 redux-saga 中间件来创建更加复杂的异步 action。")]),t._v(" "),e("li",[t._v("使用 redux-pack 中间件 dispatch 基于 Promise 的异步 Action。")])]),t._v(" "),e("h2",{attrs:{id:"优化技巧"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化技巧"}},[t._v("#")]),t._v(" 优化技巧")]),t._v(" "),e("h3",{attrs:{id:"purecomponent、react-memo"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#purecomponent、react-memo"}},[t._v("#")]),t._v(" PureComponent、React.memo")]),t._v(" "),e("ul",[e("li",[t._v("如果父组件发生状态更新，及时父组件传给子组件的"),e("code",[t._v("props")]),t._v("没有修改，也会引起子组件的渲染。")]),t._v(" "),e("li",[e("code",[t._v("PureComponent")]),t._v("是对类组件的 "),e("code",[t._v("Props")]),t._v(" 和 "),e("code",[t._v("State")]),t._v(" 进行浅比较，如果没有变化，则不会渲染组件。")]),t._v(" "),e("li",[e("code",[t._v("React.memo")]),t._v(" 是对函数组件的 Props 进行浅比较。")])]),t._v(" "),e("h3",{attrs:{id:"shouldcomponentupdate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#shouldcomponentupdate"}},[t._v("#")]),t._v(" shouldComponentUpdate")]),t._v(" "),e("ul",[e("li",[t._v("使用"),e("code",[t._v("shouldComponentUpdate")]),t._v("会存在一些隐患。如果存在很多子孙组件，「找出所有子孙组件使用的属性」就会有很多工作量，也容易因为遗漏导致 bug，且会带来一定的维护成本。")])]),t._v(" "),e("h3",{attrs:{id:"usememo、usecallback"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#usememo、usecallback"}},[t._v("#")]),t._v(" useMemo、useCallback")]),t._v(" "),e("ul",[e("li",[t._v("子组件接收的函数或"),e("code",[t._v("props")]),t._v("，每次都是新的引用，那么"),e("code",[t._v("PureComponent")]),t._v(" 和 "),e("code",[t._v("React.memo")]),t._v(" 优化就会失效。需要使用 "),e("code",[t._v("useMemo")]),t._v(" 和 "),e("code",[t._v("useCallback")]),t._v(" 来生成稳定值，并结合 "),e("code",[t._v("PureComponent")]),t._v(" 或 "),e("code",[t._v("React.memo")]),t._v(" 避免子组件重新 Render。")]),t._v(" "),e("li",[e("code",[t._v("useCallback")]),t._v(" 是基于 "),e("code",[t._v("useMemo")]),t._v(" 实现的，只是针对缓存函数。")]),t._v(" "),e("li",[e("code",[t._v("useMemo")]),t._v(" 用于非常耗时的计算场景。")])]),t._v(" "),e("h3",{attrs:{id:"节流、防抖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#节流、防抖"}},[t._v("#")]),t._v(" 节流、防抖")]),t._v(" "),e("ul",[e("li",[t._v("节流，可以想象为水龙头放水，不能一直放任其流水，为了节约用水，改成每隔固定的间隔滴水。无论规定时间内，事件有无触发，都会按照固定频率触发。比如滚动时候，请求数据。窗口拖动时候，resize 事件。")]),t._v(" "),e("li",[t._v("防抖，频繁触发的动作，在 n 秒内只执行一次。输入框不断的输入值，使用防抖节约请求。频繁点赞和取消，仅需获取最后一次的操作结果传递给服务端。")])])])}),[],!1,null,null,null);e.default=a.exports}}]);