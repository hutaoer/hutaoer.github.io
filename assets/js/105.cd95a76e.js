(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{499:function(e,a,r){"use strict";r.r(a);var t=r(3),v=Object(t.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"web性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web性能优化"}},[e._v("#")]),e._v(" web性能优化")]),e._v(" "),a("h2",{attrs:{id:"prefetch-preload"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prefetch-preload"}},[e._v("#")]),e._v(" prefetch / preload")]),e._v(" "),a("h3",{attrs:{id:"prefetch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prefetch"}},[e._v("#")]),e._v(" prefetch")]),e._v(" "),a("ul",[a("li",[e._v("提示浏览器提前加载链接的资源，因为它未来可能会被用户请求。浏览器就会在闲时去加载对应的资源。")]),e._v(" "),a("li",[e._v("当资源真正被使用的时候立即执行，就无需等待网络的消耗。")]),e._v(" "),a("li",[e._v("IE11以下版本不支持，Safari 也不支持，支持覆盖率：80.21%，参见：https://caniuse.com/?search=prefetch")])]),e._v(" "),a("h3",{attrs:{id:"preload"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#preload"}},[e._v("#")]),e._v(" preload")]),e._v(" "),a("ul",[a("li",[e._v("一种预加载的方式，向浏览器声明一个需要提交加载的资源，当资源真正被使用的时候立即执行，就无需等待网络的消耗。")]),e._v(" "),a("li",[e._v("除IE外，大部分浏览器都支持。覆盖率：93.37%。参见：https://caniuse.com/?search=preload")]),e._v(" "),a("li",[e._v("preload 的支持度更好些。")])]),e._v(" "),a("h3",{attrs:{id:"注意"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意"}},[e._v("#")]),e._v(" 注意")]),e._v(" "),a("ul",[a("li",[e._v("preload / prefetch 的资源被获取后，被放在内存缓存中。如果资源位存在有效的缓存极致（如 cache-control 或 max-age），它将被存储在 HTTP 缓存中可以被不同页面所使用。")]),e._v(" "),a("li",[e._v("正常情况下，不会儿进行二次下载。对于 preload 来说，一旦页面关闭了，它就会立即停止 preload 获取资源，而对于 prefetch 资源，即使页面关闭，prefetch 发起的请求仍会进行不会中断。")]),e._v(" "),a("li",[e._v("对一个资源同时使用了 preload 和 prefetch ，会造成二次下载。")]),e._v(" "),a("li",[e._v("preload 字体不带 crossorigin 也将会二次获取！ 确保你对 preload 的字体添加 crossorigin 属性。")])]),e._v(" "),a("h3",{attrs:{id:"使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[e._v("#")]),e._v(" 使用场景")]),e._v(" "),a("ul",[a("li",[e._v("preload 是告诉浏览器页面必定需要的资源，浏览器一定会加载这些资源，而 prefetch 是告诉浏览器页面可能需要的资源，浏览器不一定会加载这些资源。所以建议：对于当前页面很有必要的资源使用 preload，对于可能在将来的页面中使用的资源使用 prefetch。")]),e._v(" "),a("li",[e._v("使用 preload，提前加载字体文件，避免页面闪动。")]),e._v(" "),a("li",[e._v("页面加载完成后，分析页面上可能的二级跳转，并使用 prefetch 预加载。")])]),e._v(" "),a("h2",{attrs:{id:"defer-async"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#defer-async"}},[e._v("#")]),e._v(" defer / async")]),e._v(" "),a("ul",[a("li",[e._v("在浏览器加载HTML过程中，HTML 解析器运行于主线程之中，并且在遇到 "),a("code",[e._v("<\/script>")]),e._v(" 标签后会被阻塞，直到脚本从网络中被获取和执行。也就是说"),a("code",[e._v("<script>")]),e._v("标签中的脚本会阻塞浏览器的渲染，这样也被称为“渲染阻塞”。")]),e._v(" "),a("li",[e._v("内联脚本的解析和求值（Execute）也是HTML解析过程的一部分.")]),e._v(" "),a("li",[e._v("使用 async/defer 属性在加载脚本的时候不阻塞 HTML 的解析，defer 加载脚本执行会在所有元素解析完成，DOMContentLoaded 事件触发之前完成执行。它的用途其实跟 preload 十分相似。你可以使用 defer 加载脚本在 head 末尾，这比将脚本放在 body 底部效果来的更好。")]),e._v(" "),a("li",[e._v("defer 只能用于脚本资源，而且会执行。")])]),e._v(" "),a("h3",{attrs:{id:"async"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async"}},[e._v("#")]),e._v(" async")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("async")]),e._v("属性告诉浏览器先把文件下载下来，在适当的时候再执行。异步脚本一定会在页面的"),a("code",[e._v("load")]),e._v("事件前执行，但可能会在"),a("code",[e._v("DOMContentLoaded")]),e._v("事件触发之前或之后执行。")]),e._v(" "),a("li",[a("code",[e._v("async")]),e._v("的脚本并不保证按照指定他们的先后顺序执行。")])]),e._v(" "),a("h3",{attrs:{id:"defer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#defer"}},[e._v("#")]),e._v(" defer")]),e._v(" "),a("ul",[a("li",[e._v("该脚本将在文档完成解析后，触发 "),a("code",[e._v("DOMContentLoaded")]),e._v(" 事件前执行。")]),e._v(" "),a("li",[e._v("仅对外联的脚本起作用。")])]),e._v(" "),a("h3",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("async")]),e._v("是在外部JS加载完成后，浏览器空闲时，"),a("code",[e._v("Load")]),e._v("事件触发前执行；而Defer是在JS加载完成后，整个文档解析完成后执行。")]),e._v(" "),a("li",[e._v("Defer更像是将"),a("code",[e._v("<script>")]),e._v("标签放在"),a("code",[e._v("</body>")]),e._v("之后的效果，它是异步加载JS文件，所以可以节省时间。")])])])}),[],!1,null,null,null);a.default=v.exports}}]);