(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{459:function(e,t,a){"use strict";a.r(t);var s=a(3),r=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"热更新"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#热更新"}},[e._v("#")]),e._v(" 热更新")]),e._v(" "),t("h2",{attrs:{id:"websocket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[e._v("#")]),e._v(" websocket")]),e._v(" "),t("ul",[t("li",[e._v("webpack-dev-server启动的时候，启动了"),t("code",[e._v("websocket")]),e._v("服务。通过websocket，可以建立本地服务和浏览器的双向通信。这样就可以实现当本地文件发生变化，立马告知浏览器可以热更新代码啦！")])]),e._v(" "),t("h2",{attrs:{id:"webpack监听文件变化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack监听文件变化"}},[e._v("#")]),e._v(" webpack监听文件变化")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("webpack-dev-middleware")]),e._v("，调用"),t("code",[e._v("compiler.watch")]),e._v("方法。")]),e._v(" "),t("li",[e._v("开启对本地文件的监听，当文件发生变化，重新编译，编译完成之后继续监听。")]),e._v(" "),t("li",[e._v("将打包好的代码放入内存中。")])]),e._v(" "),t("h2",{attrs:{id:"hotmodulereplacementplugin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hotmodulereplacementplugin"}},[e._v("#")]),e._v(" HotModuleReplacementPlugin")])])}),[],!1,null,null,null);t.default=r.exports}}]);