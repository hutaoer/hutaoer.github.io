(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{471:function(t,o,e){"use strict";e.r(o);var n=e(3),a=Object(n.a)({},(function(){var t=this,o=t._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"mongodb-实战总结"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#mongodb-实战总结"}},[t._v("#")]),t._v(" MongoDB 实战总结")]),t._v(" "),o("h2",{attrs:{id:"连接池"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#连接池"}},[t._v("#")]),t._v(" 连接池")]),t._v(" "),o("ul",[o("li",[t._v("在用 MySQL 的时候，通常我们会创建一个连接池。每次增删改查都会从池子里获取一个已经存在的连接，这样做会减少新建连接而造成的资源浪费。")]),t._v(" "),o("li",[t._v("在 MongoDB 中，有一个最大连接数限制，默认值为 1000000。我们也可以通过 net.maxIncomingConnections 参数来配置它。以 MongoDB 为例，每个线程都要分配 1MB 的栈内存出来。")]),t._v(" "),o("li",[o("code",[t._v("new MongoClient")]),t._v(" 的时候就已经创建了一个连接池，getDatabase 只是从这个连接池中拿一个可用的连接。而连接池是不需要我们及时关闭的，我们可以在程序的生命周期中维护一个这样的单例.")]),t._v(" "),o("li",[t._v("在 mongo 中，一个连接池会维持一定数目的连接，当你需要的时候调用 getDatabase 去连接池中拿到连接，而 mongo 会在这个 DB 执行完数据操作时候自动收回连接到连接池中待用。所以在 mongoDB 中大家不必担心连接没有关闭的问题，在你需要在所有操作结束或者整个程序 shutdown 的时候调用 mongo 的 close() 方法即可。")]),t._v(" "),o("li",[t._v("默认的连接池大小为5，配置项为"),o("code",[t._v("poolSize")])])]),t._v(" "),o("h2",{attrs:{id:"参考"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),o("ul",[o("li",[o("a",{attrs:{href:"https://blog.csdn.net/weixin_43526371/article/details/108619915",target:"_blank",rel:"noopener noreferrer"}},[t._v("Node.js（四）：封装MongoDB类库"),o("OutboundLink")],1)]),t._v(" "),o("li",[o("a",{attrs:{href:"https://www.jianshu.com/p/210d3f55af17",target:"_blank",rel:"noopener noreferrer"}},[t._v("关于 mongoose 使用，这一篇就够了"),o("OutboundLink")],1)])])])}),[],!1,null,null,null);o.default=a.exports}}]);