(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{498:function(t,a,e){"use strict";e.r(a);var s=e(3),v=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react-学习笔记"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-学习笔记"}},[t._v("#")]),t._v(" React 学习笔记")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("React")]),t._v("是一个用于构建用户界面的 JS 库，相当于 "),a("code",[t._v("MVC")]),t._v(" 中的"),a("code",[t._v("View")]),t._v("层。")])]),t._v(" "),a("h2",{attrs:{id:"设计思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计思想"}},[t._v("#")]),t._v(" 设计思想")]),t._v(" "),a("ul",[a("li",[t._v("React 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递。尽管如此，但这种需要显式声明的方法更有助于人们理解程序的运作方式。")]),t._v(" "),a("li",[t._v("state 只能由拥有它们的组件进行更改。")])]),t._v(" "),a("h2",{attrs:{id:"版本更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#版本更新"}},[t._v("#")]),t._v(" 版本更新")]),t._v(" "),a("ul",[a("li",[t._v("React 16")]),t._v(" "),a("li",[t._v("React 17，没有添加任何面向开发人员的新功能，简化React自身的一次升级。\n"),a("ul",[a("li",[t._v("去除事件池。")]),t._v(" "),a("li",[t._v("事件代理更改。在React 16和更早的版本中，React将对大多数事件执行"),a("code",[t._v("document.addEventListener()")]),t._v("。 React 17将在后调用"),a("code",[t._v("rootNode.addEventListener()")]),t._v("。")]),t._v(" "),a("li",[t._v("新的"),a("code",[t._v("jsx")]),t._v("转换。为全新的 JSX 转换器添加 "),a("code",[t._v("react/jsx-runtime")]),t._v(" 和 "),a("code",[t._v("react/jsx-dev-runtime")]),t._v("。")]),t._v(" "),a("li",[a("code",[t._v("Concurrent Mode")]),t._v(" (实验阶段)。在实现性 API 前添加 "),a("code",[t._v("unstable_")]),t._v(" 前缀。")]),t._v(" "),a("li",[a("code",[t._v("useEffect")]),t._v(" 的回调修改为异步调用。"),a("code",[t._v("useEffect")]),t._v(" 的副作用清理函数是在 "),a("code",[t._v("effect")]),t._v(" 执行之后立马执行的，但是在使用中发现了如果回调中的操作比较耗时，会造成一些性能问题，现在"),a("code",[t._v("useEffect")]),t._v(" 的 副作用清理函数会在 "),a("code",[t._v("render")]),t._v(" 后执行了。")])])]),t._v(" "),a("li",[t._v("React 18 Alpha\n"),a("ul",[a("li",[t._v("时间分片是利用了 fiber 的可中断，可继续的功能，每个渲染周期内都会留一部分的时间来响应用户的输入,或者其他 IO 的状态修改。")]),t._v(" "),a("li",[t._v("使用 Transition API 进行并发控制。React 在内部使用了一个“调度程序”，负责对这些回调进行优先级排序和请求")]),t._v(" "),a("li",[t._v("自动批处理，多次调用状态修改函数，会进行合并。如果不想批处理，需要在函数外面包裹一层"),a("code",[t._v("flushSync")]),t._v("函数，同步渲染。")]),t._v(" "),a("li",[t._v("SSR 支持 Suspense，更快的加载页面。")])])])]),t._v(" "),a("h2",{attrs:{id:"基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),a("h3",{attrs:{id:"对比-vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对比-vue"}},[t._v("#")]),t._v(" 对比 Vue")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("JSX")]),t._v(" 是一种扩展的 "),a("code",[t._v("XML")]),t._v(" 语言，最终 "),a("code",[t._v("JSX")]),t._v(" 写出的代码会被转换成 "),a("code",[t._v("React.createElement")]),t._v("的形式。")]),t._v(" "),a("li",[a("code",[t._v("JSX")]),t._v(" 中的表达式，是使用"),a("code",[t._v("{}")]),t._v("来插入；而 Vue 使用的是“Mustache”语法 (双大括号) 的文本插值。")]),t._v(" "),a("li",[t._v("跟 Vue 比较，更接近于原生 JS，比如少了指令、修饰符等一些语法糖。")]),t._v(" "),a("li",[a("code",[t._v("portal")]),t._v(" 跟 Vue 中的 "),a("code",[t._v("teloport")]),t._v(" 类似。")]),t._v(" "),a("li",[a("code",[t._v("props.children")]),t._v(" 跟 "),a("code",[t._v("slot")]),t._v("类似。")]),t._v(" "),a("li",[a("code",[t._v("Context")]),t._v(" 类似 "),a("code",[t._v("provider/inject")])])]),t._v(" "),a("h4",{attrs:{id:"指定属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#指定属性"}},[t._v("#")]),t._v(" 指定属性")]),t._v(" "),a("ul",[a("li",[t._v("通过引号来指定字符串字面量， "),a("code",[t._v('const element = <div dataIndex="o"></div>')])]),t._v(" "),a("li",[t._v("通过大括号，来指定表达式，"),a("code",[t._v("const el = <img src={url}></img>")])]),t._v(" "),a("li",[a("code",[t._v("React DOM")]),t._v(" 使用 "),a("code",[t._v("camelCase")]),t._v("（小驼峰命名）来定义属性的名称。")]),t._v(" "),a("li",[a("code",[t._v("React DOM")]),t._v(" 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。可以有效的防止XSS攻击。")])]),t._v(" "),a("h3",{attrs:{id:"生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),a("ul",[a("li",[t._v("挂载过程中会依次执行：\n"),a("ul",[a("li",[t._v("constructor")]),t._v(" "),a("li",[t._v("componentWillMount")]),t._v(" "),a("li",[t._v("render")]),t._v(" "),a("li",[t._v("componentDidMount,一般组件需要自己加载数据，放到这个函数中")])])])]),t._v(" "),a("h4",{attrs:{id:"更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新"}},[t._v("#")]),t._v(" 更新")]),t._v(" "),a("ul",[a("li",[t._v("有三种途径：父组件更新、自身的状态变化、强制更新")])]),t._v(" "),a("h3",{attrs:{id:"数据-state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据-state"}},[t._v("#")]),t._v(" 数据 State")]),t._v(" "),a("ul",[a("li",[t._v("构造函数是唯一可以给 "),a("code",[t._v("this.state")]),t._v(" 赋值的地方。")]),t._v(" "),a("li",[t._v("出于性能考虑，"),a("code",[t._v("React")]),t._v(" 可能会把多个 "),a("code",[t._v("setState()")]),t._v(" 调用合并成一个调用。")]),t._v(" "),a("li",[t._v("数据是向下流动的，也称之为单向数据流。")])]),t._v(" "),a("h3",{attrs:{id:"组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件"}},[t._v("#")]),t._v(" 组件")]),t._v(" "),a("ul",[a("li",[t._v("所有 React 组件的 "),a("code",[t._v("props")]),t._v(" 不能更改。")])]),t._v(" "),a("h4",{attrs:{id:"functional-component"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#functional-component"}},[t._v("#")]),t._v(" Functional Component")]),t._v(" "),a("ul",[a("li",[t._v("函数式组件")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Welcome")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("props")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("h1"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("h1"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h4",{attrs:{id:"类组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类组件"}},[t._v("#")]),t._v(" 类组件")]),t._v(" "),a("ul",[a("li",[t._v("即：class 组件。")]),t._v(" "),a("li",[a("code",[t._v("Class")]),t._v(" 组件应该始终使用 "),a("code",[t._v("props")]),t._v(" 参数来调用父类的构造函数。")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Welcome")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("props")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("h1"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("h1"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h4",{attrs:{id:"purecomponent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#purecomponent"}},[t._v("#")]),t._v(" PureComponent")]),t._v(" "),a("ul",[a("li",[t._v("15.3 引入的一个组件基类。")]),t._v(" "),a("li",[a("code",[t._v("shouldComponentUpdate")]),t._v("不会直接返回"),a("code",[t._v("true")]),t._v("，而是会对属性和状态进行浅层比较。")])]),t._v(" "),a("h4",{attrs:{id:"渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染"}},[t._v("#")]),t._v(" 渲染")]),t._v(" "),a("ul",[a("li",[t._v("条件渲染：\n"),a("ul",[a("li",[a("code",[t._v("condition && expression")])]),t._v(" "),a("li",[a("code",[t._v("condition ? expression1 : expression2")])])])]),t._v(" "),a("li",[t._v("在组件的 render 方法中返回 null 并不会影响组件的生命周期。")])]),t._v(" "),a("h4",{attrs:{id:"列表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#列表"}},[t._v("#")]),t._v(" 列表")]),t._v(" "),a("ul",[a("li",[t._v("如果列表项目的顺序可能会变化，我们不建议使用索引来用作 "),a("code",[t._v("key")]),t._v(" 值，因为这样做会导致性能变差，还可能引起组件状态的问题。")]),t._v(" "),a("li",[t._v("当我们生成两个不同的数组时，我们可以使用相同的 "),a("code",[t._v("key")]),t._v(" 值。")])]),t._v(" "),a("h4",{attrs:{id:"事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件"}},[t._v("#")]),t._v(" 事件")]),t._v(" "),a("ul",[a("li",[t._v("不能通过返回 "),a("code",[t._v("false")]),t._v(" 的方式阻止默认行为。你必须显式的使用 "),a("code",[t._v("preventDefault")]),t._v("。")]),t._v(" "),a("li",[t._v("class 的方法默认不会绑定 this，需要手动绑定。有两种方法可以解决：\n"),a("ul",[a("li",[t._v("试验性质的"),a("code",[t._v("public class fields")]),t._v("语法，声明方法的时候："),a("code",[t._v("handleClick = () => {console.log()}")]),t._v(", 事件监听："),a("code",[t._v("<button onClick={this.handleClick}></button>")])]),t._v(" "),a("li",[t._v("或者可以使用箭头函数，"),a("code",[t._v("handleClick() {}")]),t._v("，事件监听："),a("code",[t._v("<button onClick={() => {this.handleClick()}></button")]),t._v("。这种写法有个问题，每次渲染的时候都会创建回调函数。如果是作为props传入子组件的话，会进行额外的重新渲染。")])])]),t._v(" "),a("li",[t._v("事件传参，有两种方式\n"),a("ul",[a("li",[a("code",[t._v("<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>")]),t._v("，这种需要显示的传递事件对象 e。")]),t._v(" "),a("li",[a("code",[t._v("<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>")]),t._v("，默认隐式传递。")])])])]),t._v(" "),a("h3",{attrs:{id:"合成事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合成事件"}},[t._v("#")]),t._v(" 合成事件")]),t._v(" "),a("ul",[a("li",[t._v("React 合成事件（"),a("code",[t._v("SyntheticEvent")]),t._v("）是React模拟原生DOM事件所有能力的一个事件对象。它遵循 W3C 规范，兼容所有浏览器，拥有与浏览器原生事件相同的接口。")]),t._v(" "),a("li",[t._v("React 中，所有事件都是合成的，不是原生的，但可以通过 "),a("code",[t._v("e.nativeEvent")]),t._v(" 属性获取 DOM 事件。")]),t._v(" "),a("li",[t._v("为什么使用合成事件\n"),a("ul",[a("li",[t._v("浏览器兼容，使用顶级事件代理机制，保证冒泡的一致性。")]),t._v(" "),a("li",[t._v("避免垃圾回收。引入事件池，从中获取或释放事件对象，避免频繁的创建和销毁事件对象。")]),t._v(" "),a("li",[t._v("方便事件统一管理和事务机制。")])])]),t._v(" "),a("li",[t._v("可以使用 "),a("code",[t._v("e.stopPropagation()")]),t._v(" 或者 "),a("code",[t._v("e.cancelBubble=true（IE）")]),t._v("来阻止事件的冒泡传播。")]),t._v(" "),a("li",[t._v("与原生事件区别\n"),a("ul",[a("li",[t._v("命名方式不同。原生为纯小写"),a("code",[t._v("<button onclick='handleClick()'>")]),t._v("，React采用小驼峰，"),a("code",[t._v("<button onClick={handleClick}>")])]),t._v(" "),a("li",[t._v("事件处理函数写法不同，原生是字符串，React是函数。")]),t._v(" "),a("li",[t._v("阻止默认行为方式不同：原生返回"),a("code",[t._v("false")]),t._v("，React 显示调用"),a("code",[t._v("preventDefault()")])])])]),t._v(" "),a("li",[t._v("执行顺序\n"),a("ul",[a("li",[t._v("在 React 中，“合成事件”会以事件委托"),a("code",[t._v("（Event Delegation）")]),t._v("方式绑定在组件最上层，并在组件卸载"),a("code",[t._v("（unmount）")]),t._v("阶段自动销毁绑定的事件。")]),t._v(" "),a("li",[t._v("React 所有事件都挂载在 document 对象上；")]),t._v(" "),a("li",[t._v("当真实 DOM 元素触发事件，会冒泡到 document 对象后，再处理 React 事件；")]),t._v(" "),a("li",[t._v("所以会先执行原生事件，然后处理 React 事件；")]),t._v(" "),a("li",[t._v("最后真正执行 document 上挂载的事件。")])])])]),t._v(" "),a("h3",{attrs:{id:"表单"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表单"}},[t._v("#")]),t._v(" 表单")]),t._v(" "),a("ul",[a("li",[t._v("表单一般会设计为受控组件，它的状态，会收到用户交互影响而改变，从而也会导致UI层的改变。")]),t._v(" "),a("li",[t._v("当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。")]),t._v(" "),a("li",[a("code",[t._v("this.setState({[name]: value})")]),t._v("，这里利用了ES6 计算属性名称的语法。")]),t._v(" "),a("li",[t._v("在受控组件上指定 "),a("code",[t._v("value")]),t._v(" 的值， 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将value 设置为 undefined 或 null。")]),t._v(" "),a("li",[t._v("处理表单的时候，推荐使用受控组件。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。")])]),t._v(" "),a("h3",{attrs:{id:"组合、继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组合、继承"}},[t._v("#")]),t._v(" 组合、继承")]),t._v(" "),a("ul",[a("li",[t._v("推荐使用组合而非继承来实现组件间的代码重用。")]),t._v(" "),a("li",[t._v("通过"),a("code",[t._v("children prop")]),t._v(" 来将他们的子组件传递到渲染结果中，类似 Vue 中的插槽。也可以通过"),a("code",[t._v("prop")]),t._v("来传递组件。")]),t._v(" "),a("li",[t._v("React 中没有“槽”这一概念的限制，你可以将任何东西作为 props 进行传递。")]),t._v(" "),a("li",[t._v("如果想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入"),a("code",[t._v("（import）")]),t._v("而无需通过 "),a("code",[t._v("extend")]),t._v(" 继承它们。")])]),t._v(" "),a("h2",{attrs:{id:"高级部分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高级部分"}},[t._v("#")]),t._v(" 高级部分")]),t._v(" "),a("h3",{attrs:{id:"代码分割"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码分割"}},[t._v("#")]),t._v(" 代码分割")]),t._v(" "),a("ul",[a("li",[t._v("使用 Create React App，该功能已开箱即用。")]),t._v(" "),a("li",[t._v("当使用 Babel 时，你要确保 Babel 能够解析动态 import 语法而不是将其进行转换。需要 "),a("code",[t._v("@babel/plugin-syntax-dynamic-import")]),t._v(" 插件。")]),t._v(" "),a("li",[a("code",[t._v("React.lazy")]),t._v("，可以动态引入组件。然后应在 Suspense 组件中渲染 lazy 组件，如此使得我们可以使用在等待加载 lazy 组件时做优雅降级。")]),t._v(" "),a("li",[t._v("如果动态加载的组件有带有样式的，需要做处理，那么打包跟 chunk 文件一起，这样的话 css 文件不会被异步加载。")]),t._v(" "),a("li",[t._v("注意："),a("code",[t._v("React.lazy")]),t._v(" 目前只支持默认导出（default exports）。")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("Suspense"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'react'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" LazyComp "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("lazy")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./LazyComp'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("MyComp")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t\t\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Suspense fallback"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("loading"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("LazyComp "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t\t\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Suspense"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[t._v("#")]),t._v(" Context")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("Context")]),t._v(" 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 "),a("code",[t._v("props")]),t._v("。")]),t._v(" "),a("li",[t._v("TOFILL")])]),t._v(" "),a("h3",{attrs:{id:"高阶组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件"}},[t._v("#")]),t._v(" 高阶组件")]),t._v(" "),a("ul",[a("li",[t._v("定义：将组件作为参数，并返回新组件的函数。")]),t._v(" "),a("li",[t._v("常见的组件就是：Redux 的 "),a("code",[t._v("connect")])]),t._v(" "),a("li",[t._v("解决的问题：我们需要一个抽象，允许我们在一个地方定义这个逻辑，并在许多组件之间共享它。")])]),t._v(" "),a("h2",{attrs:{id:"api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[t._v("#")]),t._v(" API")]),t._v(" "),a("h3",{attrs:{id:"createelement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#createelement"}},[t._v("#")]),t._v(" createElement")]),t._v(" "),a("ul",[a("li",[t._v("跟 Vue3.0 中的 "),a("code",[t._v("h")]),t._v(" 函数很像")])]),t._v(" "),a("h2",{attrs:{id:"concurrent-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#concurrent-模式"}},[t._v("#")]),t._v(" Concurrent 模式")]),t._v(" "),a("ul",[a("li",[t._v("目前尚处于实验阶段，可能会在 "),a("code",[t._v("React 18")]),t._v(" 版本中落地。")]),t._v(" "),a("li",[t._v("概念："),a("code",[t._v("Concurrent")]),t._v(" 模式是一组 "),a("code",[t._v("React")]),t._v(" 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。在 "),a("code",[t._v("Concurrent")]),t._v(" 模式中，渲染不是阻塞的。它是可中断的。")]),t._v(" "),a("li",[t._v("产生卡顿的原因很简单：一旦渲染开始，就不能被终止。"),a("code",[t._v("Concurrent")]),t._v(" 模式减少了防抖和节流在 UI 中的需求。因为渲染是可以中断的，React 不需要人为地 延迟 工作以避免卡顿。")])])])}),[],!1,null,null,null);a.default=v.exports}}]);