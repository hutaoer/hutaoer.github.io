(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{403:function(t,e,r){"use strict";r.r(e);var c=r(45),n=Object(c.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"react-文档学习笔记"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-文档学习笔记"}},[t._v("#")]),t._v(" React 文档学习笔记")]),t._v(" "),r("h2",{attrs:{id:"concurrent-模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#concurrent-模式"}},[t._v("#")]),t._v(" Concurrent 模式")]),t._v(" "),r("ul",[r("li",[t._v("目前尚处于实验阶段，可能会在 "),r("code",[t._v("React 18")]),t._v(" 版本中落地。")]),t._v(" "),r("li",[t._v("概念："),r("code",[t._v("Concurrent")]),t._v(" 模式是一组 "),r("code",[t._v("React")]),t._v(" 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。在 "),r("code",[t._v("Concurrent")]),t._v(" 模式中，渲染不是阻塞的。它是可中断的。")]),t._v(" "),r("li",[t._v("产生卡顿的原因很简单：一旦渲染开始，就不能被终止。"),r("code",[t._v("Concurrent")]),t._v(" 模式减少了防抖和节流在 UI 中的需求。因为渲染是可以中断的，React 不需要人为地 延迟 工作以避免卡顿。")])])])}),[],!1,null,null,null);e.default=n.exports}}]);