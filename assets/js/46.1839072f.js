(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{411:function(t,a,s){"use strict";s.r(a);var e=s(45),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"react-文档学习笔记"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-文档学习笔记"}},[t._v("#")]),t._v(" React 文档学习笔记")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("React")]),t._v("是一个用于构建用户界面的 JS 库，相当于 "),s("code",[t._v("MVC")]),t._v(" 中的"),s("code",[t._v("View")]),t._v("层。")])]),t._v(" "),s("h2",{attrs:{id:"设计思想"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计思想"}},[t._v("#")]),t._v(" 设计思想")]),t._v(" "),s("ul",[s("li",[t._v("React 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递。尽管如此，但这种需要显式声明的方法更有助于人们理解程序的运作方式。")]),t._v(" "),s("li",[t._v("state 只能由拥有它们的组件进行更改。")])]),t._v(" "),s("h2",{attrs:{id:"基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),s("h3",{attrs:{id:"对比-vue"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对比-vue"}},[t._v("#")]),t._v(" 对比 Vue")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("JSX")]),t._v(" 是一种扩展的 "),s("code",[t._v("XML")]),t._v(" 语言，最终 "),s("code",[t._v("JSX")]),t._v(" 写出的代码会被转换成 "),s("code",[t._v("React.createElement")]),t._v("的形式。")]),t._v(" "),s("li",[s("code",[t._v("JSX")]),t._v(" 中的表达式，是使用"),s("code",[t._v("{}")]),t._v("来插入；而 Vue 使用的是“Mustache”语法 (双大括号) 的文本插值。")]),t._v(" "),s("li",[t._v("跟 Vue 比较，更接近于原生 JS，比如少了指令、修饰符等一些语法糖。")]),t._v(" "),s("li",[s("code",[t._v("portal")]),t._v(" 跟 Vue 中的 "),s("code",[t._v("teloport")]),t._v(" 类似。")]),t._v(" "),s("li",[s("code",[t._v("props.children")]),t._v(" 跟 "),s("code",[t._v("slot")]),t._v("类似。")]),t._v(" "),s("li",[s("code",[t._v("Context")]),t._v(" 类似 "),s("code",[t._v("provider/inject")])])]),t._v(" "),s("h4",{attrs:{id:"指定属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#指定属性"}},[t._v("#")]),t._v(" 指定属性")]),t._v(" "),s("ul",[s("li",[t._v("通过引号来指定字符串字面量， "),s("code",[t._v('const element = <div dataIndex="o"></div>')])]),t._v(" "),s("li",[t._v("通过大括号，来指定表达式，"),s("code",[t._v("const el = <img src={url}></img>")])]),t._v(" "),s("li",[s("code",[t._v("React DOM")]),t._v(" 使用 "),s("code",[t._v("camelCase")]),t._v("（小驼峰命名）来定义属性的名称。")]),t._v(" "),s("li",[s("code",[t._v("React DOM")]),t._v(" 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。可以有效的防止XSS攻击。")])]),t._v(" "),s("h3",{attrs:{id:"生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),s("ul",[s("li",[t._v("挂载过程中会依次执行：\n"),s("ul",[s("li",[t._v("constructor")]),t._v(" "),s("li",[t._v("componentWillMount")]),t._v(" "),s("li",[t._v("render")]),t._v(" "),s("li",[t._v("componentDidMount,一般组件需要自己加载数据，放到这个函数中")])])])]),t._v(" "),s("h4",{attrs:{id:"更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#更新"}},[t._v("#")]),t._v(" 更新")]),t._v(" "),s("ul",[s("li",[t._v("有三种途径：父组件更新、自身的状态变化、强制更新")])]),t._v(" "),s("h3",{attrs:{id:"数据-state"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据-state"}},[t._v("#")]),t._v(" 数据 State")]),t._v(" "),s("ul",[s("li",[t._v("构造函数是唯一可以给 "),s("code",[t._v("this.state")]),t._v(" 赋值的地方。")]),t._v(" "),s("li",[t._v("出于性能考虑，"),s("code",[t._v("React")]),t._v(" 可能会把多个 "),s("code",[t._v("setState()")]),t._v(" 调用合并成一个调用。")]),t._v(" "),s("li",[t._v("数据是向下流动的，也称之为单向数据流。")])]),t._v(" "),s("h3",{attrs:{id:"组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件"}},[t._v("#")]),t._v(" 组件")]),t._v(" "),s("ul",[s("li",[t._v("所有 React 组件的 "),s("code",[t._v("props")]),t._v(" 不能更改。")])]),t._v(" "),s("h4",{attrs:{id:"functional-component"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#functional-component"}},[t._v("#")]),t._v(" Functional Component")]),t._v(" "),s("ul",[s("li",[t._v("函数式组件")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Welcome")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("props")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("h1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("props"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("h1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h4",{attrs:{id:"类组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类组件"}},[t._v("#")]),t._v(" 类组件")]),t._v(" "),s("ul",[s("li",[t._v("即：class 组件。")]),t._v(" "),s("li",[s("code",[t._v("Class")]),t._v(" 组件应该始终使用 "),s("code",[t._v("props")]),t._v(" 参数来调用父类的构造函数。")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Welcome")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("props")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("props"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("h1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("props"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("h1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h5",{attrs:{id:"purecomponent"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#purecomponent"}},[t._v("#")]),t._v(" PureComponent")]),t._v(" "),s("ul",[s("li",[t._v("15.3 引入的一个组件基类。")]),t._v(" "),s("li",[s("code",[t._v("shouldComponentUpdate")]),t._v("不会直接返回"),s("code",[t._v("true")]),t._v("，而是会对属性和状态进行浅层比较。")])]),t._v(" "),s("h4",{attrs:{id:"事件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件"}},[t._v("#")]),t._v(" 事件")]),t._v(" "),s("ul",[s("li",[t._v("不能通过返回 "),s("code",[t._v("false")]),t._v(" 的方式阻止默认行为。你必须显式的使用 "),s("code",[t._v("preventDefault")]),t._v("。")]),t._v(" "),s("li",[t._v("class 的方法默认不会绑定 this，需要手动绑定。有两种方法可以解决：\n"),s("ul",[s("li",[t._v("试验性质的"),s("code",[t._v("public class fields")]),t._v("语法，声明方法的时候："),s("code",[t._v("handleClick = () => {console.log()}")]),t._v(", 事件监听："),s("code",[t._v("<button onClick={this.handleClick}></button>")])]),t._v(" "),s("li",[t._v("或者可以使用箭头函数，"),s("code",[t._v("handleClick() {}")]),t._v("，事件监听："),s("code",[t._v("<button onClick={() => {this.handleClick()}></button")]),t._v("。这种写法有个问题，每次渲染的时候都会创建回调函数。如果是作为props传入子组件的话，会进行额外的重新渲染。")])])]),t._v(" "),s("li",[t._v("事件传参，有两种方式\n"),s("ul",[s("li",[s("code",[t._v("<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>")]),t._v("，这种需要显示的传递事件对象 e。")]),t._v(" "),s("li",[s("code",[t._v("<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>")]),t._v("，默认隐式传递。")])])])]),t._v(" "),s("h4",{attrs:{id:"渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#渲染"}},[t._v("#")]),t._v(" 渲染")]),t._v(" "),s("ul",[s("li",[t._v("条件渲染：\n"),s("ul",[s("li",[s("code",[t._v("condition && expression")])]),t._v(" "),s("li",[s("code",[t._v("condition ? expression1 : expression2")])])])]),t._v(" "),s("li",[t._v("在组件的 render 方法中返回 null 并不会影响组件的生命周期。")])]),t._v(" "),s("h4",{attrs:{id:"列表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#列表"}},[t._v("#")]),t._v(" 列表")]),t._v(" "),s("ul",[s("li",[t._v("如果列表项目的顺序可能会变化，我们不建议使用索引来用作 "),s("code",[t._v("key")]),t._v(" 值，因为这样做会导致性能变差，还可能引起组件状态的问题。")]),t._v(" "),s("li",[t._v("当我们生成两个不同的数组时，我们可以使用相同的 "),s("code",[t._v("key")]),t._v(" 值。")])]),t._v(" "),s("h3",{attrs:{id:"表单"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#表单"}},[t._v("#")]),t._v(" 表单")]),t._v(" "),s("ul",[s("li",[t._v("表单一般会设计为受控组件，它的状态，会收到用户交互影响而改变，从而也会导致UI层的改变。")]),t._v(" "),s("li",[t._v("当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。")]),t._v(" "),s("li",[s("code",[t._v("this.setState({[name]: value})")]),t._v("，这里利用了ES6 计算属性名称的语法。")]),t._v(" "),s("li",[t._v("在受控组件上指定 "),s("code",[t._v("value")]),t._v(" 的值， 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将value 设置为 undefined 或 null。")]),t._v(" "),s("li",[t._v("处理表单的时候，推荐使用受控组件。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。")])]),t._v(" "),s("h3",{attrs:{id:"组合、继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组合、继承"}},[t._v("#")]),t._v(" 组合、继承")]),t._v(" "),s("ul",[s("li",[t._v("推荐使用组合而非继承来实现组件间的代码重用。")]),t._v(" "),s("li",[t._v("通过"),s("code",[t._v("children prop")]),t._v(" 来将他们的子组件传递到渲染结果中，类似 Vue 中的插槽。也可以通过"),s("code",[t._v("prop")]),t._v("来传递组件。")]),t._v(" "),s("li",[t._v("React 中没有“槽”这一概念的限制，你可以将任何东西作为 props 进行传递。")]),t._v(" "),s("li",[t._v("如果想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入"),s("code",[t._v("（import）")]),t._v("而无需通过 "),s("code",[t._v("extend")]),t._v(" 继承它们。")])]),t._v(" "),s("h2",{attrs:{id:"高级部分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#高级部分"}},[t._v("#")]),t._v(" 高级部分")]),t._v(" "),s("h3",{attrs:{id:"代码分割"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码分割"}},[t._v("#")]),t._v(" 代码分割")]),t._v(" "),s("ul",[s("li",[t._v("使用 Create React App，该功能已开箱即用。")]),t._v(" "),s("li",[t._v("当使用 Babel 时，你要确保 Babel 能够解析动态 import 语法而不是将其进行转换。需要 "),s("code",[t._v("@babel/plugin-syntax-dynamic-import")]),t._v(" 插件。")]),t._v(" "),s("li",[s("code",[t._v("React.lazy")]),t._v("，可以动态引入组件。然后应在 Suspense 组件中渲染 lazy 组件，如此使得我们可以使用在等待加载 lazy 组件时做优雅降级。")]),t._v(" "),s("li",[t._v("如果动态加载的组件有带有样式的，需要做处理，那么打包跟 chunk 文件一起，这样的话 css 文件不会被异步加载。")]),t._v(" "),s("li",[t._v("注意："),s("code",[t._v("React.lazy")]),t._v(" 目前只支持默认导出（default exports）。")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" React"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("Suspense"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'react'")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" LazyComp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" React"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("lazy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./LazyComp'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MyComp")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t\t\t"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Suspense fallback"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("loading"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("LazyComp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t\t\t"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Suspense"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"context"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[t._v("#")]),t._v(" Context")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Context")]),t._v(" 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 "),s("code",[t._v("props")]),t._v("。")]),t._v(" "),s("li",[t._v("TOFILL")])]),t._v(" "),s("h3",{attrs:{id:"高阶组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件"}},[t._v("#")]),t._v(" 高阶组件")]),t._v(" "),s("ul",[s("li",[t._v("定义：将组件作为参数，并返回新组件的函数。")]),t._v(" "),s("li",[t._v("常见的组件就是：Redux 的 "),s("code",[t._v("connect")])]),t._v(" "),s("li",[t._v("解决的问题：我们需要一个抽象，允许我们在一个地方定义这个逻辑，并在许多组件之间共享它。")])]),t._v(" "),s("h2",{attrs:{id:"api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[t._v("#")]),t._v(" API")]),t._v(" "),s("h3",{attrs:{id:"createelement"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#createelement"}},[t._v("#")]),t._v(" createElement")]),t._v(" "),s("ul",[s("li",[t._v("跟 Vue3.0 中的 "),s("code",[t._v("h")]),t._v(" 函数很像")])]),t._v(" "),s("h2",{attrs:{id:"concurrent-模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrent-模式"}},[t._v("#")]),t._v(" Concurrent 模式")]),t._v(" "),s("ul",[s("li",[t._v("目前尚处于实验阶段，可能会在 "),s("code",[t._v("React 18")]),t._v(" 版本中落地。")]),t._v(" "),s("li",[t._v("概念："),s("code",[t._v("Concurrent")]),t._v(" 模式是一组 "),s("code",[t._v("React")]),t._v(" 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。在 "),s("code",[t._v("Concurrent")]),t._v(" 模式中，渲染不是阻塞的。它是可中断的。")]),t._v(" "),s("li",[t._v("产生卡顿的原因很简单：一旦渲染开始，就不能被终止。"),s("code",[t._v("Concurrent")]),t._v(" 模式减少了防抖和节流在 UI 中的需求。因为渲染是可以中断的，React 不需要人为地 延迟 工作以避免卡顿。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);