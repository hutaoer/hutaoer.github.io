(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{311:function(t,a,e){"use strict";e.r(a);var s=e(14),r=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"javascript-学习笔记"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-学习笔记"}},[t._v("#")]),t._v(" JavaScript 学习笔记")]),t._v(" "),a("h2",{attrs:{id:"函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[t._v("#")]),t._v(" 函数")]),t._v(" "),a("h3",{attrs:{id:"arguments"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arguments"}},[t._v("#")]),t._v(" arguments")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("arguments")]),t._v(" 对象是所有函数中都可用的局部变量，除头函数外。")]),t._v(" "),a("li",[a("code",[t._v("arguments")]),t._v(" 是类数组对象，除了length和索引外，没有其他的数组属性，也不能调用数组的方法。")]),t._v(" "),a("li",[a("code",[t._v("arguments")]),t._v(" 可以被遍历。")]),t._v(" "),a("li",[a("code",[t._v("arguments")]),t._v(" 转数组的方法：")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" args "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Array")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("slice")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arguments"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" args "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("slice")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arguments"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" args "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Array"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("from")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arguments"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" args "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("arguments"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" args "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Array")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("apply")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arguments"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("h3",{attrs:{id:"function-length"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#function-length"}},[t._v("#")]),t._v(" Function.length")]),t._v(" "),a("ul",[a("li",[t._v("指的是形参的个数。")]),t._v(" "),a("li",[t._v("形参的数量不包括剩余参数个数，仅包括第一个具有默认值之前的参数个数。")]),t._v(" "),a("li",[t._v("Function 构造器本身也是个Function。他的 length 属性值为 1 。")])]),t._v(" "),a("h3",{attrs:{id:"函数的-prototype"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数的-prototype"}},[t._v("#")]),t._v(" 函数的 prototype")]),t._v(" "),a("ul",[a("li",[t._v("函数的原型对象包含了"),a("code",[t._v("constructor")]),t._v("属性和"),a("code",[t._v("__proto__")]),t._v("属性")]),t._v(" "),a("li",[t._v("通过构造函数创建的对象的"),a("code",[t._v("__proto__")]),t._v("指向其构造函数的原型对象")])]),t._v(" "),a("h3",{attrs:{id:"注意"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意"}},[t._v("#")]),t._v(" 注意")]),t._v(" "),a("ul",[a("li",[t._v("箭头函数不存在 "),a("code",[t._v("arguments")]),t._v(" 对象。")]),t._v(" "),a("li",[a("code",[t._v("apply")]),t._v("调用的时候，参数上线是 65536 个。")])]),t._v(" "),a("h2",{attrs:{id:"语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[t._v("#")]),t._v(" 语法")]),t._v(" "),a("h3",{attrs:{id:"展开语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#展开语法"}},[t._v("#")]),t._v(" 展开语法")]),t._v(" "),a("ul",[a("li",[t._v("调用函数、数组构造、字面量构造的时候，将数组表达式展开，将对象表达式按照 "),a("code",[t._v("key-value")]),t._v(" 方式展开。")]),t._v(" "),a("li",[t._v("函数声明："),a("code",[t._v("const params = [1,2]; myFn(a,b) {console.log(a,b)}; myFn(...params)")])]),t._v(" "),a("li",[t._v("构造数组："),a("code",[t._v("const a = [1]; const b = [...a]")]),t._v(";")]),t._v(" "),a("li",[t._v("构造字面量："),a("code",[t._v("const o = {n: 123}; const d = {...o}")])])]),t._v(" "),a("h3",{attrs:{id:"剩余语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#剩余语法"}},[t._v("#")]),t._v(" 剩余语法")]),t._v(" "),a("ul",[a("li",[t._v("剩余参数用于解构数组和对象。从某种意义上说，剩余语法与展开语法是相反的：展开语法将数组展开为其中的各个元素，而剩余语法则是将多个元素收集起来并“凝聚”为单个元素。")]),t._v(" "),a("li",[t._v("与 "),a("code",[t._v("arguments")]),t._v(" 对象区别：\n"),a("ul",[a("li",[t._v("剩余参数只包含那些没有对应形参的实参，而 "),a("code",[t._v("arguments")]),t._v(" 对象包含了传给函数的 "),a("strong",[t._v("所有实参")])]),t._v(" "),a("li",[a("code",[t._v("arguments")]),t._v("对象不是一个真正的数组，而剩余参数是真正的 "),a("code",[t._v("Array")]),t._v("实例")]),t._v(" "),a("li",[a("code",[t._v("arguments")]),t._v("对象还有一些附加的属性 （如"),a("code",[t._v("callee")]),t._v("属性）。")])])])]),t._v(" "),a("h2",{attrs:{id:"数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),a("h3",{attrs:{id:"数组的存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组的存储"}},[t._v("#")]),t._v(" 数组的存储")]),t._v(" "),a("ul",[a("li",[t._v("两种方式：一快一慢。")]),t._v(" "),a("li",[a("code",[t._v("Fast")]),t._v("：快速的存储结构是 "),a("code",[t._v("FixedArray")]),t._v(" ，并且数组长度 "),a("code",[t._v("<= elements.length()")]),t._v(" ；快速的根据索\n引来直接定位， push 和 pop 操作会对数组进行动态的扩容和缩容。快数组以空间换时间，申请了连续内存，提高效率，但是比较占内存。")]),t._v(" "),a("li",[a("code",[t._v("Slow")]),t._v("：慢速的基于 "),a("code",[t._v("Hash")]),t._v(" 表来实现。慢数组以时间换空间，不需要申请连续的空间，节省了内存，但是效率较低。")])]),t._v(" "),a("h3",{attrs:{id:"splice"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#splice"}},[t._v("#")]),t._v(" splice")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("splice(index, count, insertElemnt, ...)")])]),t._v(" "),a("li",[t._v("splice 方法接收的第一个参数，表示想要删除或插入的元素的索引值。第二个参数是删除元素的个数（不删除元素，则传入 0）。第三个参数往后，就是要\n添加到数组里的值。")])]),t._v(" "),a("h3",{attrs:{id:"tostring-valueof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tostring-valueof"}},[t._v("#")]),t._v(" toString / valueOf")]),t._v(" "),a("ul",[a("li",[t._v("将数组的元素，作为字符串返回。"),a("code",[t._v('[1,2].toString() // "1,2"')])]),t._v(" "),a("li",[t._v("注意："),a("code",[t._v("valueOf")]),t._v(" 返回的值，还是数组 "),a("code",[t._v("[1,2].valueOf() // [1,2]")])])]),t._v(" "),a("h3",{attrs:{id:"reduce"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reduce"}},[t._v("#")]),t._v(" reduce")]),t._v(" "),a("ul",[a("li",[t._v("reduce 方法接收一个有如下四个参数的函数："),a("code",[t._v("previousValue、currentValue、index 和 array")]),t._v("。因为 index 和 array 是可选的参数，所以如果用不到它们\n的话，可以不传。")]),t._v(" "),a("li",[t._v("reducer 函数接收4个参数:\n"),a("ul",[a("li",[a("code",[t._v("Accumulator (acc) (累计器)")])]),t._v(" "),a("li",[a("code",[t._v("Current Value (cur) (当前值)")])]),t._v(" "),a("li",[a("code",[t._v("Current Index (idx) (当前索引)")]),t._v(": 数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。")]),t._v(" "),a("li",[a("code",[t._v("Source Array (src) (源数组)")])])])]),t._v(" "),a("li",[a("code",[t._v("reduce(reducer, initialValue)")]),t._v(" "),a("ul",[a("li",[t._v("如果提供了 "),a("code",[t._v("initialValue")]),t._v("，那么accumulator 初始值为 initialValue，currentValue取数组中的第一个值，idx 从 0 开始。")]),t._v(" "),a("li",[t._v("如果没有提供 "),a("code",[t._v("initialValue")]),t._v("，那么accumulator取数组中的第一个值，currentValue取数组中的第二个值。idx 从 1 开始。")])])])]),t._v(" "),a("h2",{attrs:{id:"object-create-null"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-create-null"}},[t._v("#")]),t._v(" {}, Object.create(null)")]),t._v(" "),a("h2",{attrs:{id:"textcontent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#textcontent"}},[t._v("#")]),t._v(" textContent")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("textContent")]),t._v(" 可以防止 XSS 攻击。")]),t._v(" "),a("li",[a("code",[t._v("textContent")]),t._v(" 相比较"),a("code",[t._v("innerHTML")]),t._v("通常具有更好的性能，因为文本不会被解析为HTML。")])]),t._v(" "),a("h2",{attrs:{id:"位运算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#位运算"}},[t._v("#")]),t._v(" 位运算")]),t._v(" "),a("ul",[a("li",[t._v("有符号整数使用 31 位表示整数的数值，用第 32 位表示整数的符号，0 表示正数，1 表示负数。数值范围从 -2147483648 到 2147483647。从第 1 位（位 0）开始。")]),t._v(" "),a("li",[t._v("ECMAScript 并不以二进制补码的形式显示，而是用数字绝对值的标准二进制代码前面加负号的形式输出。")]),t._v(" "),a("li",[t._v("记住，在处理有符号整数时，开发者不能访问 31 位。")])]),t._v(" "),a("h3",{attrs:{id:"负数存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#负数存储"}},[t._v("#")]),t._v(" 负数存储")]),t._v(" "),a("ul",[a("li",[t._v("负数也存储为二进制代码，不过采用的形式是二进制补码。")]),t._v(" "),a("li",[t._v("补码的计算步骤：\n"),a("ul",[a("li",[t._v("确定该数字的非负版本的二进制表示（例如，要计算 -18的二进制补码，首先要确定 18 的二进制表示）")]),t._v(" "),a("li",[t._v("求得二进制反码，即要把 0 替换为 1，把 1 替换为 0")]),t._v(" "),a("li",[t._v("在二进制反码上加 1")])])])]),t._v(" "),a("h2",{attrs:{id:"enumerable"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#enumerable"}},[t._v("#")]),t._v(" enumerable")]),t._v(" "),a("ul",[a("li",[t._v("可枚举性（enumerable）用来控制所描述的属性，是否将被包括在"),a("code",[t._v("for...in")]),t._v("循环之中。具体来说，如果一个属性的"),a("code",[t._v("enumerable")]),t._v("为"),a("code",[t._v("false")]),t._v("，下面三个操作不会取到该属性。\n"),a("ul",[a("li",[a("code",[t._v("for ... in")])]),t._v(" "),a("li",[a("code",[t._v("Object.keys")])]),t._v(" "),a("li",[a("code",[t._v("JSON.stringify")])])])]),t._v(" "),a("li",[a("code",[t._v("for...in")]),t._v("循环和"),a("code",[t._v("Object.keys")]),t._v("方法的区别，在于前者包括对象继承自原型对象的属性，而后者只包括对象本身的属性。如果需要获取对象自身的所有属性，不管"),a("code",[t._v("enumerable")]),t._v("的值，可以使用"),a("code",[t._v("Object.getOwnPropertyNames")]),t._v("方法。")])]),t._v(" "),a("h2",{attrs:{id:"常用api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用api"}},[t._v("#")]),t._v(" 常用API")]),t._v(" "),a("h3",{attrs:{id:"十进制、二进制转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十进制、二进制转换"}},[t._v("#")]),t._v(" 十进制、二进制转换")]),t._v(" "),a("ul",[a("li",[t._v("十进制转二进制："),a("code",[t._v("num.toString(2)")])]),t._v(" "),a("li",[t._v("二进制转十进制："),a("code",[t._v("parseInt(num, 2)")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);