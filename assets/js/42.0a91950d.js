(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{408:function(t,e,s){"use strict";s.r(e);var a=s(45),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"vue-文档学习笔记"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-文档学习笔记"}},[t._v("#")]),t._v(" Vue 文档学习笔记")]),t._v(" "),s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),s("ul",[s("li",[t._v("Vue 是一套用于构建用户界面的渐进式框架，自底向上逐层应用。一开始不需要你完全掌握它的全部功能特性，可以后续逐步增加功能。")]),t._v(" "),s("li",[t._v("MVVM响应式编程模型，避免直接操作DOM , 降低DOM操作的复杂性。\n"),s("ul",[s("li",[t._v("V: 对应 View，原生的DOM，前端展示页面。")]),t._v(" "),s("li",[t._v("M: 对应 Model，原生的JS 对象，即数据对象。")]),t._v(" "),s("li",[t._v("VM: ViewModel, 用于双向绑定数据和页面，即 Vue 实例。")])])]),t._v(" "),s("li",[t._v("渐进式框架：用你想用或者能用的功能特性，你不想用的部分功能可以不用。各个功能都是独立的，也能按需进行整合：\n"),s("ul",[s("li",[t._v("Declartive Rendering: 声明式渲染，采用简洁的模板语法来声明式地将数据渲染进 DOM，仅作为 View 层的渲染工具。")]),t._v(" "),s("li",[t._v("Component System: 代码组件化系统，单文件组件，用来提效、复用、抽象。")]),t._v(" "),s("li",[t._v("Client-Side Routing: 客户端路由。")]),t._v(" "),s("li",[t._v("Large Scale State Management: 大规模数据管理，构建大型项目。")]),t._v(" "),s("li",[t._v("Build System: 构建系统。")]),t._v(" "),s("li",[t._v("Server-Side Rendering: 支持服务端渲染。")]),t._v(" "),s("li",[t._v("支持TS")])])])]),t._v(" "),s("h2",{attrs:{id:"计算属性-computed"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计算属性-computed"}},[t._v("#")]),t._v(" 计算属性（computed）")]),t._v(" "),s("ul",[s("li",[t._v("对于任何包含响应式数据的复杂逻辑，你都应该使用计算属性。")]),t._v(" "),s("li",[t._v("比如："),s("code",[t._v("author.books.length > 0 ? 'Yes' : 'No' }}")]),t._v("，如果模板中多次使用，用计算属性可以缓存数据，提升性能。")]),t._v(" "),s("li",[t._v("跟方法不一样，"),s("strong",[t._v("计算属性")]),t._v(" 是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。如果"),s("code",[t._v("author.books")]),t._v("没有发生改变，计算属性会立即返回之前的计算结果，不需要再次执行函数。如果是调用方法，则每次都执行函数。")]),t._v(" "),s("li",[t._v("下面的计算属性，不会再更新，因为不是响应式依赖。")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("computed"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("now")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" Date"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("now")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("ul",[s("li",[t._v("计算属性默认只有"),s("code",[t._v("getter")]),t._v("，可以根据需要提供"),s("code",[t._v("setter")])])]),t._v(" "),s("h2",{attrs:{id:"侦听器-watch"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#侦听器-watch"}},[t._v("#")]),t._v(" 侦听器（watch）")]),t._v(" "),s("ul",[s("li",[t._v("通过使用 "),s("code",[t._v("watch")]),t._v(" 选项允许我们执行异步操作 (比如访问一个"),s("code",[t._v("API")]),t._v(")，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。")]),t._v(" "),s("li",[t._v("不要滥用"),s("code",[t._v("watch")]),t._v("，当需要一些数据随着其依赖的数据变动时，通常更好的做法是使用计算属性。")])]),t._v(" "),s("h2",{attrs:{id:"class-与-style-绑定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#class-与-style-绑定"}},[t._v("#")]),t._v(" Class 与 Style 绑定")]),t._v(" "),s("ul",[s("li",[t._v("对象语法："),s("code",[t._v(":class=\"{ active: isActive, 'text-danger': hasError }\"")])]),t._v(" "),s("li",[t._v("通过计算属性达到一样的效果")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("computed"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("classObject")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      active"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" expression"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'text-danger'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" expression\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("ul",[s("li",[t._v("数组语法:"),s("code",[t._v('<div :class="[activeClass, errorClass]"></div>')])]),t._v(" "),s("li",[t._v("可以使用三元表达式: "),s("code",[t._v("<div :class=\"[isActive ? activeClass : '', errorClass]\"></div>")])]),t._v(" "),s("li",[t._v("在数组语法中也可以使用对象语法:"),s("code",[t._v('<div :class="[{ active: isActive }, errorClass]"></div>')])]),t._v(" "),s("li",[t._v("内联样式支持对象语法："),s("code",[t._v("<div :style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>")])]),t._v(" "),s("li",[t._v("内联样式支持数组语法："),s("code",[t._v('<div :style="[baseStyles, overridingStyles]"></div>')])])]),t._v(" "),s("h2",{attrs:{id:"条件渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#条件渲染"}},[t._v("#")]),t._v(" 条件渲染")]),t._v(" "),s("h3",{attrs:{id:"v-show"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-show"}},[t._v("#")]),t._v(" v-show")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("v-show")]),t._v(" 只是简单地切换元素的 "),s("code",[t._v("CSS property display")]),t._v("。")]),t._v(" "),s("li",[s("code",[t._v("v-show")]),t._v(" 不支持 "),s("code",[t._v("<template>")]),t._v(" 元素，也不支持 "),s("code",[t._v("v-else")]),t._v("。")])]),t._v(" "),s("h3",{attrs:{id:"v-show-对比-v-if"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-show-对比-v-if"}},[t._v("#")]),t._v(" v-show 对比 v-if")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("v-if")]),t._v("会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建。")]),t._v(" "),s("li",[t._v("一般来说，"),s("code",[t._v("v-if")]),t._v(" 有更高的切换开销，而 "),s("code",[t._v("v-show")]),t._v(" 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 "),s("code",[t._v("v-show")]),t._v(" 较好；如果在运行时条件很少改变，则使用 "),s("code",[t._v("v-if")]),t._v(" 较好。")])]),t._v(" "),s("h3",{attrs:{id:"v-if-与-v-for-一起使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-if-与-v-for-一起使用"}},[t._v("#")]),t._v(" v-if 与 v-for 一起使用")]),t._v(" "),s("ul",[s("li",[t._v("当 "),s("code",[t._v("v-if")]),t._v(" 与 "),s("code",[t._v("v-for")]),t._v(" 一起使用时，"),s("code",[t._v("v-if")]),t._v("具有比 "),s("code",[t._v("v-for")]),t._v("更高的优先级。")]),t._v(" "),s("li",[s("code",[t._v("v-if")]),t._v(" 将没有权限访问 "),s("code",[t._v("v-for")]),t._v(" 里的变量。可以通过调整嵌套关系来实现。")])]),t._v(" "),s("h2",{attrs:{id:"列表渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#列表渲染"}},[t._v("#")]),t._v(" 列表渲染")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("v-for")]),t._v(" 指令需要使用 "),s("code",[t._v("(item, index )in items")]),t._v("形式的特殊语法，也可以使用"),s("code",[t._v("item of items")])]),t._v(" "),s("li",[t._v("也可以用 "),s("code",[t._v("v-for")]),t._v(" 来遍历一个对象的 "),s("code",[t._v("property")]),t._v("，第二个的参数为 property 名称 (也就是键名 key)，"),s("code",[t._v("(value, name) of myObject")]),t._v("。还支持第三个参数：索引："),s("code",[t._v("(value, name, index) of myObject")]),t._v("。在遍历对象时，会按 "),s("code",[t._v("Object.keys()")]),t._v(" 的结果遍历，但是不能保证它在不同 JavaScript 引擎下的结果都一致。")])]),t._v(" "),s("h3",{attrs:{id:"数组更新检测"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组更新检测"}},[t._v("#")]),t._v(" 数组更新检测")]),t._v(" "),s("ul",[s("li",[t._v("Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：\n"),s("ul",[s("li",[s("code",[t._v("push()")])]),t._v(" "),s("li",[s("code",[t._v("pop()")])]),t._v(" "),s("li",[s("code",[t._v("shift()")])]),t._v(" "),s("li",[s("code",[t._v("unshift()")])]),t._v(" "),s("li",[s("code",[t._v("splice()")])]),t._v(" "),s("li",[s("code",[t._v("sort()")])]),t._v(" "),s("li",[s("code",[t._v("reverse()")])])])]),t._v(" "),s("li",[t._v("替换数组。"),s("code",[t._v("filter()")]),t._v("、"),s("code",[t._v("concat()")]),t._v(" 和 "),s("code",[t._v("slice()")]),t._v("。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组.")])]),t._v(" "),s("h2",{attrs:{id:"事件处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件处理"}},[t._v("#")]),t._v(" 事件处理")]),t._v(" "),s("ul",[s("li",[t._v("监听事件："),s("code",[t._v('v-on:click="methodName"')]),t._v("或使用快捷方式 "),s("code",[t._v('@click="methodName"')])]),t._v(" "),s("li",[t._v("如果在监听的事件方法的地方，不带参数，那么在方法定义的地方，默认参数就是 "),s("code",[t._v("event")]),t._v("对象。")]),t._v(" "),s("li",[t._v("如果在监听的事件方法的地方，传了参数，默认不会传 "),s("code",[t._v("event")]),t._v("对象，需要显示传入"),s("code",[t._v("$event")]),t._v("关键字，例如："),s("code",[t._v("<button @click=\"say('what', $event)\">Say what</button>")])]),t._v(" "),s("li",[t._v("绑定多个事件处理器："),s("code",[t._v('<button @click="one($event), two($event)">Submit</button>')])])]),t._v(" "),s("h2",{attrs:{id:"组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件"}},[t._v("#")]),t._v(" 组件")]),t._v(" "),s("h3",{attrs:{id:"监听子组件事件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#监听子组件事件"}},[t._v("#")]),t._v(" 监听子组件事件")]),t._v(" "),s("ul",[s("li",[t._v("父级组件可以像处理原生 DOM 事件一样通过 "),s("code",[t._v("v-on")]),t._v(" 或 "),s("code",[t._v("@")]),t._v("监听子组件实例的任意事件：")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 方式一 通过表达式处理, $event 获取子组件中的传参")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("child @doSomeThing"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"$event + 1"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("child"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 方式二,调用在父组件中的方法`doItInParent`")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("child @doSomeThing"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"doItInParent"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("child"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),s("ul",[s("li",[t._v("子组件中触发自定义事件")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在组件的 emits 选项中列出已抛出的事件")]),t._v("\napp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("component")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'child'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  emits"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'doSomeThing'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 触发事件")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("button @click"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("\"$emit('doSomeThing', 333)\"")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("触发事件"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("button"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  在子组件的方法中触发")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tmethods"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("handleClick")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("$emit")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'doSomeThing'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"组件绑定-v-model"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件绑定-v-model"}},[t._v("#")]),t._v(" 组件绑定 v-model")]),t._v(" "),s("ul",[s("li",[t._v("将其 "),s("code",[t._v("value attribute")]),t._v(" 绑定到一个名叫 "),s("code",[t._v("modelValue")]),t._v(" 的 "),s("code",[t._v("prop")]),t._v(" 上")]),t._v(" "),s("li",[t._v("在其 组件 事件被触发时，将新的值通过自定义的 "),s("code",[t._v("update:modelValue")]),t._v(" 事件抛出，以"),s("code",[t._v("input")]),t._v("组件为例")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("app"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("component")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'custom-input'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  props"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'modelValue'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  emits"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'update:modelValue'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  template"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('\n    <input\n      :value="modelValue"\n      @input="$emit(\'update:modelValue\', $event.target.value)"\n    >\n  ')]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h3",{attrs:{id:"动态子组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态子组件"}},[t._v("#")]),t._v(" 动态子组件")]),t._v(" "),s("ul",[s("li",[t._v("通过 "),s("code",[t._v("Vue")]),t._v(" 的 "),s("code",[t._v("<component>")]),t._v(" 元素加一个特殊的 "),s("code",[t._v("is attribute")]),t._v(" 来实现。")]),t._v(" "),s("li",[t._v("使用"),s("code",[t._v("keep-alive")]),t._v("来缓存组件")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("keep"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("alive"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("component "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("is"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"currentTabComponent"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("component"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("keep"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("alive"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),s("h3",{attrs:{id:"异步组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步组件"}},[t._v("#")]),t._v(" 异步组件")]),t._v(" "),s("h4",{attrs:{id:"vue-2-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-2-0"}},[t._v("#")]),t._v(" Vue 2.0")]),t._v(" "),s("ul",[s("li",[t._v("方式一：接收一个"),s("code",[t._v("resolve")]),t._v("回调。或者通过 webpack 和 ES6 语法，动态导入")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("Vue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("component")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'async-example'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("resolve"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" reject")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTimeout")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 向 `resolve` 回调传递组件定义")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      template"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'<div>I am async!</div>'")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\nVue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("component")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'async-webpack-example'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("resolve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这个特殊的 `require` 语法将会告诉 webpack")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 自动将你的构建代码切割成多个包，这些包")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 会通过 Ajax 请求加载")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./my-async-component'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" resolve"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n  components"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  \t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 动态导入，返回一个 Promise 对象")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'my-component'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./my-async-component'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("ul",[s("li",[t._v("方式二：通过配置，功能会更加强大些。")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("AsyncComponent")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 需要加载的组件 (应该是一个 `Promise` 对象)")]),t._v("\n  component"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./MyComponent.vue'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 异步组件加载时使用的组件")]),t._v("\n  loading"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" LoadingComponent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 加载失败时使用的组件")]),t._v("\n  error"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ErrorComponent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 展示加载时组件的延时时间。默认值是 200 (毫秒)")]),t._v("\n  delay"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果提供了超时时间且组件加载也超时了，")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 则使用加载失败时使用的组件。默认值是：`Infinity`")]),t._v("\n  timeout"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3000")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n  components"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'my-component'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" AsyncComponent\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h4",{attrs:{id:"vue-3-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-0"}},[t._v("#")]),t._v(" Vue 3.0")]),t._v(" "),s("ul",[s("li",[t._v("Vue 3.0 中，需要调用"),s("code",[t._v("defineAsyncComponent")]),t._v("，它接受一个函数，改函数必须返回一个"),s("code",[t._v("Promise")]),t._v("，将组件"),s("code",[t._v("resolve")]),t._v("。或者通过"),s("code",[t._v("import")]),t._v("方式引入。")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" createApp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" defineAsyncComponent "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Vue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" AsyncComp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("defineAsyncComponent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Promise")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("resolve"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" reject")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        template"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'<div>I am async!</div>'")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" AsyncComp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("defineAsyncComponent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./components/AsyncComponent.vue'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 注意这里是直接 return import('component.vue')")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),s("ul",[s("li",[t._v("同样也可以通过配置方式实现，跟2.0相比，"),s("code",[t._v("component")]),t._v(" 选项现在被重命名为 "),s("code",[t._v("loader")]),t._v(":")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" asyncPageWithOptions "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("defineAsyncComponent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("loader")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./NextPage.vue'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  delay"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  timeout"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  errorComponent"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ErrorComponent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  loadingComponent"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" LoadingComponent\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h3",{attrs:{id:"props"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#props"}},[t._v("#")]),t._v(" props")]),t._v(" "),s("ul",[s("li",[t._v("传入静态数组："),s("code",[t._v(':data="[1,2,3]"')])]),t._v(" "),s("li",[t._v("传入静态数字："),s("code",[t._v(':num="333"')])]),t._v(" "),s("li",[t._v("传入静态对象："),s("code",[t._v('{name: "hutaoer"}')])]),t._v(" "),s("li",[t._v("如果想要将一个对象的所有 "),s("code",[t._v("property")]),t._v(" 都作为 "),s("code",[t._v("prop")]),t._v(" 传入，你可以使用不带参数的 "),s("code",[t._v("v-bind")]),t._v(" (取代 "),s("code",[t._v("v-bind:prop-name")]),t._v(")。"),s("code",[t._v('v-bind="data"')])]),t._v(" "),s("li",[s("code",[t._v("prop")]),t._v(" 会在一个组件实例创建之前进行验证，所以实例的 "),s("code",[t._v("property")]),t._v("，在属性校验的方法"),s("code",[t._v("validator()")]),t._v("，"),s("code",[t._v("default()")]),t._v("中不能使用。")]),t._v(" "),s("li",[t._v("类型检查的类型包括："),s("code",[t._v("String")]),t._v(","),s("code",[t._v("Number")]),t._v(","),s("code",[t._v("Boolean")]),t._v(","),s("code",[t._v("Object")]),t._v(","),s("code",[t._v("Symbol")]),t._v(","),s("code",[t._v("Array")]),t._v(","),s("code",[t._v("Date")]),t._v(","),s("code",[t._v("Function")]),t._v("，此外也是可以使用自定义"),s("code",[t._v("class")])]),t._v(" "),s("li",[t._v("当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名.")])]),t._v(" "),s("h3",{attrs:{id:"单向数据流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单向数据流"}},[t._v("#")]),t._v(" 单向数据流")]),t._v(" "),s("ul",[s("li",[t._v("每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。")]),t._v(" "),s("li",[t._v("你不应该在一个子组件内部改变 prop。")]),t._v(" "),s("li",[t._v("对象和数组是通过引用传入的，所以对于一个数组或对象类型的 "),s("code",[t._v("prop")]),t._v(" 来说，在子组件中改变变更这个对象或数组本身将会影响到父组件的状态。")])]),t._v(" "),s("h3",{attrs:{id:"attribute-继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#attribute-继承"}},[t._v("#")]),t._v(" Attribute 继承")]),t._v(" "),s("ul",[s("li",[t._v("当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。")]),t._v(" "),s("li",[t._v("同样的规则也适用于事件监听器。")]),t._v(" "),s("li",[t._v("如果不希望组件的根元素继承 attribute，你可以在组件的选项中设置 "),s("code",[t._v("inheritAttrs: false")]),t._v("。禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。")])]),t._v(" "),s("h2",{attrs:{id:"插槽"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#插槽"}},[t._v("#")]),t._v(" 插槽")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("v-slot")]),t._v(" 只能添加在 "),s("code",[t._v("<template>")]),t._v(" 上，有一种情况例外：仅使用默认插槽时候。当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样我们就可以把 "),s("code",[t._v("v-slot")]),t._v(" 直接用在组件上：")]),t._v(" "),s("li",[t._v("作用域插槽：让插槽内容能够访问子组件中才有的数据。")]),t._v(" "),s("li",[t._v("默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确。")]),t._v(" "),s("li",[t._v("具名插槽的缩写：例如 "),s("code",[t._v("v-slot:header")]),t._v(" 可以被重写为 "),s("code",[t._v("#header")]),t._v("。该缩写只在其有参数的时候才可用。")])]),t._v(" "),s("h2",{attrs:{id:"provide-inject"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#provide-inject"}},[t._v("#")]),t._v(" Provide / Inject")]),t._v(" "),s("ul",[s("li",[t._v("用来解决嵌套组件直接的数据传递问题。")]),t._v(" "),s("li",[t._v("这个特性有两个部分：父组件有一个 "),s("code",[t._v("provide")]),t._v(" 选项来提供数据，子组件有一个 "),s("code",[t._v("inject")]),t._v(" 选项来开始使用这些数据。")]),t._v(" "),s("li",[t._v("父组件不需要知道哪些子组件使用它 "),s("code",[t._v("provide 的 property")])]),t._v(" "),s("li",[t._v("子组件不需要知道 "),s("code",[t._v("inject")]),t._v(" 的 "),s("code",[t._v("property")]),t._v(" 来自哪里.")]),t._v(" "),s("li",[t._v("要访问组件实例 "),s("code",[t._v("property")]),t._v("，我们需要将 "),s("code",[t._v("provide")]),t._v(" 转换为返回对象的 "),s("strong",[t._v("函数")]),t._v(" ，即："),s("code",[t._v("provide() {return {}}")])]),t._v(" "),s("li",[t._v("默认情况下，"),s("code",[t._v("provide/inject")]),t._v(" 绑定并不是响应式的。如果我们想对祖先组件中的更改做出响应，我们需要为 "),s("code",[t._v("provide")]),t._v(" 的"),s("code",[t._v("property")]),t._v("分配一个组合式 "),s("code",[t._v("API computed property")]),t._v("："),s("code",[t._v("property:Vue.computed(() => {// return property value})")])])]),t._v(" "),s("h2",{attrs:{id:"过渡-动画"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#过渡-动画"}},[t._v("#")]),t._v(" 过渡 & 动画")]),t._v(" "),s("ul",[s("li",[t._v("如果要对一个元素进行硬件加速，使用下面任何一个属性均可：\n"),s("ul",[s("li",[s("code",[t._v("perspective: 1000px;")])]),t._v(" "),s("li",[s("code",[t._v("backface-visibility: hidden;")])]),t._v(" "),s("li",[s("code",[t._v("transform: translateZ(0);")])])])])]),t._v(" "),s("h2",{attrs:{id:"组合式api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组合式api"}},[t._v("#")]),t._v(" 组合式API")]),t._v(" "),s("h3",{attrs:{id:"setup"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#setup"}},[t._v("#")]),t._v(" setup")]),t._v(" "),s("ul",[s("li",[t._v("接收两个参数"),s("code",[t._v("(props, context)")])]),t._v(" "),s("li",[t._v("因为 "),s("code",[t._v("props")]),t._v(" 是响应式的，你不能使用 "),s("code",[t._v("ES6")]),t._v(" 解构，它会消除 "),s("code",[t._v("prop")]),t._v(" 的响应性。如果需要解构 "),s("code",[t._v("prop")]),t._v("，可以在 "),s("code",[t._v("setup")]),t._v(" 函数中使用 "),s("code",[t._v("toRefs")]),t._v(" 函数来完成此操作。")]),t._v(" "),s("li",[s("code",[t._v("context")]),t._v(" 是一个普通的 JavaScript 对象，它暴露组件的三个 "),s("code",[t._v("property：attrs, slots, emit")])]),t._v(" "),s("li",[t._v("执行"),s("code",[t._v("setup")]),t._v("时候，组件实例还未创建。只能访问："),s("code",[t._v("props, attrs, slots, emit")]),t._v("，不能访问"),s("code",[t._v("data, computed, methods")]),t._v(".")]),t._v(" "),s("li",[t._v("如果 "),s("code",[t._v("setup")]),t._v(" 返回一个对象，那么该对象的 "),s("code",[t._v("property")]),t._v(" 以及传递给 "),s("code",[t._v("setup")]),t._v(" 的 "),s("code",[t._v("props")]),t._v(" 参数中的 "),s("code",[t._v("property")]),t._v(" 就都可以在模板中访问到。"),s("code",[t._v("props")]),t._v("不需要再从"),s("code",[t._v("setup")]),t._v("中"),s("code",[t._v("return")]),t._v("出去。")]),t._v(" "),s("li",[t._v("从 "),s("code",[t._v("setup")]),t._v(" 返回的 "),s("code",[t._v("refs")]),t._v(" 在"),s("code",[t._v("模板")]),t._v("中访问时是被"),s("code",[t._v("自动浅解包")]),t._v("的，不需要在模板中使用 "),s("code",[t._v(".value")]),t._v("。")]),t._v(" "),s("li",[s("code",[t._v("setup")]),t._v(" 还可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态，会覆盖掉"),s("code",[t._v("template")]),t._v("中的内容。")]),t._v(" "),s("li",[s("code",[t._v("setup")]),t._v(" 中的"),s("code",[t._v("this")]),t._v("不是指向当前组件实例，不能同选项式"),s("code",[t._v("API")]),t._v("混用。")])]),t._v(" "),s("h3",{attrs:{id:"生命周期钩子"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期钩子"}},[t._v("#")]),t._v(" 生命周期钩子")]),t._v(" "),s("ul",[s("li",[t._v("选项式API: "),s("code",[t._v("beforeCreate")]),t._v(","),s("code",[t._v("created")]),t._v(","),s("code",[t._v("beforeMount")]),t._v(","),s("code",[t._v("mounted")]),t._v(","),s("code",[t._v("beforeUpdate")]),t._v(","),s("code",[t._v("updated")]),t._v(","),s("code",[t._v("beforeUnmount")]),t._v(","),s("code",[t._v("unmounted")]),t._v("。")]),t._v(" "),s("li",[s("code",[t._v("onBeforeMount")]),t._v(","),s("code",[t._v("onMounted")]),t._v(","),s("code",[t._v("onBeforeUpdate")]),t._v(","),s("code",[t._v("onUpdated")]),t._v(","),s("code",[t._v("onBeforeUnmount")]),t._v(","),s("code",[t._v("onUnMounted")]),t._v("，"),s("code",[t._v("setup")]),t._v("是围绕"),s("code",[t._v("beforeCreate")]),t._v("和"),s("code",[t._v("created")]),t._v("生命周期钩子运行的，所以不需要显示定义它们。")])]),t._v(" "),s("h3",{attrs:{id:"provide-inject-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#provide-inject-2"}},[t._v("#")]),t._v(" provide / inject")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("setup")]),t._v("中使用"),s("code",[t._v("provide/inject")]),t._v("都需要显示导入。")]),t._v(" "),s("li",[t._v("使用字面量："),s("code",[t._v("provide('key', 'string')")]),t._v(", "),s("code",[t._v("inject('key')")])]),t._v(" "),s("li",[t._v("使用响应式对象："),s("code",[t._v("provide('key', ref('string'))")]),t._v("，"),s("code",[t._v("provide('key', reactive({}))")])]),t._v(" "),s("li",[t._v("当使用响应式 "),s("code",[t._v("provide / inject")]),t._v(" 值时，建议尽可能将对响应式 "),s("code",[t._v("property")]),t._v(" 的所有修改限制在定义 "),s("code",[t._v("provide")]),t._v(" 的组件内部。")]),t._v(" "),s("li",[t._v("需要在注入数据的组件内部更新 inject 的数据。在这种情况下，我们建议 provide 一个方法来负责改变响应式 property。")]),t._v(" "),s("li",[t._v("如果要确保通过 "),s("code",[t._v("provide")]),t._v(" 传递的数据不会被 "),s("code",[t._v("inject")]),t._v(" 的组件更改，我们建议对提供者的 "),s("code",[t._v("property")]),t._v(" 使用 "),s("code",[t._v("readonly")]),t._v("，比如："),s("code",[t._v("provide('key', readonly(reactiveData))")])])]),t._v(" "),s("h3",{attrs:{id:"mixin"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mixin"}},[t._v("#")]),t._v(" mixin")]),t._v(" "),s("ul",[s("li",[t._v("Vue 2 中，mixin是组件逻辑抽象的主要工具。")]),t._v(" "),s("li",[t._v("但它存在一些缺点：1. 容易产生冲突；2. 复用性有限，不能向 mixin 传递任何参数来改变它的逻辑。")]),t._v(" "),s("li",[t._v("Vue 3 中，使用组合式API来代替 mixin")])]),t._v(" "),s("h3",{attrs:{id:"注意"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注意"}},[t._v("#")]),t._v(" 注意")]),t._v(" "),s("ul",[s("li",[t._v("在 setup 中你应该避免使用 this，因为它不会找到组件实例。setup 的调用发生在 data property、computed property 或 methods 被解析之前，所以它们无法在 setup 中被获取。")])]),t._v(" "),s("h2",{attrs:{id:"自定义指令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自定义指令"}},[t._v("#")]),t._v(" 自定义指令")]),t._v(" "),s("ul",[s("li",[t._v("自定义指令总是会被应用在组件的根节点上。")])]),t._v(" "),s("h2",{attrs:{id:"teleport"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#teleport"}},[t._v("#")]),t._v(" teleport")]),t._v(" "),s("ul",[s("li",[t._v("允许我们控制在 DOM 中哪个父节点下渲染了 HTML，而不必求助于全局状态或将其拆分为两个组件。")]),t._v(" "),s("li",[s("code",[t._v('<teleport to="body"></teleport>')]),t._v("，渲染到"),s("code",[t._v("body")]),t._v("标签。")]),t._v(" "),s("li",[t._v("如果"),s("code",[t._v("teleport")]),t._v("中存在Vue子组件，虽然在DOM节点中，可能不是父子关系，但子组件在 "),s("code",[t._v("Vue Devtools")]),t._v(" 中的，仍然在父组件之下，而不是放在实际内容移动到的位置。父子组件之间的通信没有变化。")]),t._v(" "),s("li",[t._v("如果有多个"),s("code",[t._v("teleport")]),t._v("都挂载到同一个DOM节点，那么其顺序将是一个简单的追加——稍后挂载将位于目标元素中较早的挂载之后，跟组件在模板中出现的顺序保持一致。")])]),t._v(" "),s("h2",{attrs:{id:"渲染函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#渲染函数"}},[t._v("#")]),t._v(" 渲染函数")]),t._v(" "),s("ul",[s("li",[t._v("DOM树：每个元素都是一个节点。每段文字也是一个节点。甚至注释也都是节点。一个节点就是页面的一个部分。")]),t._v(" "),s("li",[t._v("虚拟节点，简称为"),s("code",[t._v("VNode")]),t._v(", 虚拟DOM是我们对由 Vue 组件树建立起来的整个 "),s("code",[t._v("VNode")]),t._v(" 树的称呼。")])]),t._v(" "),s("h3",{attrs:{id:"h函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#h函数"}},[t._v("#")]),t._v(" h函数")]),t._v(" "),s("ul",[s("li",[t._v("用于创建"),s("code",[t._v("VNode")]),t._v("，接受三个参数：\n"),s("ul",[s("li",[s("code",[t._v("{String | Object | Function} tag")]),t._v("，一个HTML标签名，一个组件，一个异步组件或一个函数式组件。必须的。")]),t._v(" "),s("li",[s("code",[t._v("{Object} props")]),t._v(",与 attribute、prop 和事件相对应的对象。可选的。")]),t._v(" "),s("li",[s("code",[t._v("{String | Array | Object} children")]),t._v("，子 "),s("code",[t._v("VNodes")]),t._v("，可选的。")])])]),t._v(" "),s("li",[t._v("如果没有 "),s("code",[t._v("prop")]),t._v("，那么通常可以将 "),s("code",[t._v("children")]),t._v(" 作为第二个参数传入。如果会产生歧义，可以将 "),s("code",[t._v("null")]),t._v(" 作为第二个参数传入，将 "),s("code",[t._v("children")]),t._v(" 作为第三个参数传入。")]),t._v(" "),s("li",[t._v("要为某个组件创建一个 "),s("code",[t._v("VNode")]),t._v("，传递给 "),s("code",[t._v("h")]),t._v(" 的第一个参数应该是组件本身。")]),t._v(" "),s("li",[s("code",[t._v("<template>")]),t._v("的优先级高于"),s("code",[t._v("render")]),t._v("函数。")]),t._v(" "),s("li",[t._v("模板使用 "),s("code",[t._v("resolveDynamicComponent")]),t._v(" 来实现 "),s("code",[t._v("is attribute")])]),t._v(" "),s("li",[t._v("诸如 "),s("code",[t._v("<keep-alive>、<transition>、<transition-group> 和 <teleport>")]),t._v("等内置组件默认并没有被全局注册。这使得打包工具可以 "),s("code",[t._v("tree-shake")]),t._v("，因此这些组件只会在被用到的时候被引入构建。")]),t._v(" "),s("li",[t._v("Vue 的模板实际上被编译成了渲染函数。")])]),t._v(" "),s("h2",{attrs:{id:"插件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#插件"}},[t._v("#")]),t._v(" 插件")]),t._v(" "),s("ul",[s("li",[t._v("插件是自包含的代码，通常向 Vue 添加全局级功能。它可以是公开 "),s("code",[t._v("install()")]),t._v(" 方法的对象，也可以是 "),s("code",[t._v("function")]),t._v(".")])]),t._v(" "),s("h2",{attrs:{id:"响应性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#响应性"}},[t._v("#")]),t._v(" 响应性")]),t._v(" "),s("h3",{attrs:{id:"响应性原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#响应性原理"}},[t._v("#")]),t._v(" 响应性原理")]),t._v(" "),s("ul",[s("li",[t._v("Vue 3 使用"),s("code",[t._v("Proxy")]),t._v("来实现，在"),s("code",[t._v("get")]),t._v("的时候，添加"),s("code",[t._v("track")]),t._v("函数，来追踪依赖；在"),s("code",[t._v("set")]),t._v("的是时候，添加了"),s("code",[t._v("trigger")]),t._v("，触发依赖。")]),t._v(" "),s("li",[s("code",[t._v("Proxy")]),t._v(" 是一个对象，它包装了另一个对象，并允许你拦截对该对象的任何交互。ES6 引入了另一个名为 "),s("code",[t._v("Reflect")]),t._v(" 的新特性。")]),t._v(" "),s("li",[s("code",[t._v("Proxy")]),t._v(" 实现响应性的第一步就是跟踪一个 "),s("code",[t._v("property")]),t._v(" 何时被读取。我们在一个名为 "),s("code",[t._v("track")]),t._v("的处理器函数中执行此操作，该函数可以传入 "),s("code",[t._v("target")]),t._v(" 和 "),s("code",[t._v("property")]),t._v(" 两个参数。它将检查当前运行的是哪个副作用，并将其与 target 和 property 记录在一起。这就是 Vue 如何知道这个 "),s("code",[t._v("property")]),t._v(" 是该副作用的依赖项。")]),t._v(" "),s("li",[t._v("需要在 "),s("code",[t._v("property")]),t._v(" 值更改时重新运行这个副作用。"),s("code",[t._v("trigger(target, property)")])])]),t._v(" "),s("h3",{attrs:{id:"具体过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#具体过程"}},[t._v("#")]),t._v(" 具体过程")]),t._v(" "),s("ul",[s("li",[t._v("当一个值被读取时进行追踪：proxy 的 get 处理函数中 track 函数记录了该 property 和当前副作用。")]),t._v(" "),s("li",[t._v("当某个值改变时进行检测：在 proxy 上调用 set 处理函数。")]),t._v(" "),s("li",[t._v("重新运行代码来读取原始值：trigger 函数查找哪些副作用依赖于该 property 并执行它们。")]),t._v(" "),s("li",[t._v("如果这些 property 中的任何一个随后发生了变化，它将触发副作用再次运行，重新运行 "),s("code",[t._v("render")]),t._v(" 函数以生成新的 "),s("code",[t._v("VNodes")]),t._v("。")])]),t._v(" "),s("h3",{attrs:{id:"响应性基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#响应性基础"}},[t._v("#")]),t._v(" 响应性基础")]),t._v(" "),s("ul",[s("li",[t._v("为对象创建响应式状态，可以使用 "),s("code",[t._v("reactive")]),t._v(" 方法。当从组件中的 "),s("code",[t._v("data()")]),t._v(" 返回一个对象时，它在内部交由 "),s("code",[t._v("reactive()")]),t._v(" 使其成为响应式对象。")]),t._v(" "),s("li",[t._v("把值类型数据变成响应式，可以使用"),s("code",[t._v("ref")]),t._v("。")]),t._v(" "),s("li",[s("code",[t._v("ref")]),t._v("解包：当 "),s("code",[t._v("ref")]),t._v(" 作为渲染上下文 (从 setup() 中返回的对象) 上的 "),s("code",[t._v("property")]),t._v(" 返回并可以在模板中被访问时，它将自动浅层次解包内部值。不需要再通过"),s("code",[t._v(".value")]),t._v("的方式去访问。只有访问嵌套的"),s("code",[t._v("ref")]),t._v("时，需要在模板中使用"),s("code",[t._v(".value")]),t._v("访问。"),s("code",[t._v("Ref")]),t._v(" 解包仅发生在被响应式 "),s("code",[t._v("Object")]),t._v(" 嵌套的时候。当从"),s("code",[t._v("Array")]),t._v("或原生集合类型如 "),s("code",[t._v("Map")]),t._v("访问 "),s("code",[t._v("ref")]),t._v("时，不会进行解包。")]),t._v(" "),s("li",[t._v("当 "),s("code",[t._v("ref")]),t._v(" 作为响应式对象的 "),s("code",[t._v("property")]),t._v("被访问或更改时，为使其行为类似于普通 "),s("code",[t._v("property")]),t._v("，它会自动解包内部值。")]),t._v(" "),s("li",[t._v("如果将新的 "),s("code",[t._v("ref")]),t._v(" 赋值给现有 "),s("code",[t._v("ref")]),t._v(" 的 "),s("code",[t._v("property")]),t._v("，将会替换旧的 "),s("code",[t._v("ref")]),t._v(".")]),t._v(" "),s("li",[t._v("结构一个"),s("code",[t._v("reactive")]),t._v("创建的对象："),s("code",[t._v("const info = reactive({name:'hutaoer'})")]),t._v("，会丢失响应性。可以使用"),s("code",[t._v("toRefs")]),t._v("转为"),s("code",[t._v("ref")]),t._v("，这样就可以保留与源对象的响应式关联:"),s("code",[t._v("let {name} = toRefs(info)")]),t._v(","),s("code",[t._v("name.value='yilin'")])])]),t._v(" "),s("h3",{attrs:{id:"计算值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计算值"}},[t._v("#")]),t._v(" 计算值")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("computed")]),t._v("方法，有两种方式：1. 一个参数的时候，默认为getter函数，并返回一个不可变的响应式"),s("code",[t._v("ref")]),t._v("对象；2. 接受一个带有"),s("code",[t._v("get")]),t._v("和"),s("code",[t._v("set")]),t._v("函数的对象，返回一个可写的"),s("code",[t._v("ref")]),t._v("对象。")])]),t._v(" "),s("h3",{attrs:{id:"注意-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注意-2"}},[t._v("#")]),t._v(" 注意")]),t._v(" "),s("ul",[s("li",[t._v("被代理对象与原始对象不相等")]),t._v(" "),s("li",[t._v("最佳实践是永远不要持有对原始对象的引用，而只使用响应式版本。")]),t._v(" "),s("li",[t._v("Vue 的 计算属性 (computed) 中应当仅包含用于返回值的计算，不应该包含 DOM操作，修改外部变量，异步操作 等。这些操作应该在 侦听器 (watch) 中实现。否则会提示"),s("code",[t._v("Unexpected side effect in “...“ computed property")])])]),t._v(" "),s("h2",{attrs:{id:"副作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#副作用"}},[t._v("#")]),t._v(" 副作用")]),t._v(" "),s("h3",{attrs:{id:"纯函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#纯函数"}},[t._v("#")]),t._v(" 纯函数")]),t._v(" "),s("ul",[s("li",[t._v("纯函数需要满足以下条件：1.它应始终返回相同的值。2.它不应修改程序的状态或引起副作用。")]),t._v(" "),s("li",[t._v("纯函数中的副作用（side effect）就是如果有一个函数在输入和输出之外还做了其他的事情，那么这个函数额外做的事情就被称为副作用。")])]),t._v(" "),s("h3",{attrs:{id:"watcheffect"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#watcheffect"}},[t._v("#")]),t._v(" watchEffect")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Vue3")]),t._v("中的"),s("code",[t._v("watchEffect")]),t._v("函数的"),s("code",[t._v("onInvalidate")]),t._v("方法就是用来清除副作用的。清除副作用实际上是Vue3提供给用户的一种取消异步副作用的实现方法。")]),t._v(" "),s("li",[s("code",[t._v("onInvalidate")]),t._v("只作用于异步函数，并且只有在如下两种情况下才会被调用：1. "),s("code",[t._v("effect")]),t._v("重新调用时；2.监听器被注销，比如组件被卸载。")]),t._v(" "),s("li",[t._v("如果希望副作用函数在组件更新后发生，可以将"),s("code",[t._v("flush")]),t._v("设为"),s("code",[t._v("post")]),t._v("（默认是"),s("code",[t._v("pre")]),t._v("）")]),t._v(" "),s("li",[t._v("与"),s("code",[t._v("watch")]),t._v("区别：\n-（1）不需要手动传入依赖\n-（2）每次初始化时会执行一次回调函数来自动获取依赖\n-（3）无法获取到原值，只能得到变化后的值")]),t._v(" "),s("li",[s("code",[t._v("onTrack")]),t._v(" 和 "),s("code",[t._v("onTrigger")]),t._v(" 只能在开发模式下工作。")])]),t._v(" "),s("h3",{attrs:{id:"watch"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[t._v("#")]),t._v(" watch")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("watch")]),t._v(" 需要侦听特定的数据源，并在回调函数中执行副作用。")]),t._v(" "),s("li",[t._v("默认情况下，它也是惰性的，即只有当被侦听的源发生变化时才执行回调。")]),t._v(" "),s("li",[t._v("同"),s("code",[t._v("watchEffect")]),t._v("区别：\n"),s("ul",[s("li",[t._v("懒执行副作用；")]),t._v(" "),s("li",[t._v("更具体地说明什么状态应该触发侦听器重新运行；")]),t._v(" "),s("li",[t._v("访问侦听状态变化前后的值。")])])]),t._v(" "),s("li",[t._v("检查深度嵌套对象或数组中的 "),s("code",[t._v("property")]),t._v(" 变化时，仍然需要 "),s("code",[t._v("deep")]),t._v(" 选项设置为 "),s("code",[t._v("true")]),t._v("。")])]),t._v(" "),s("h2",{attrs:{id:"vue-2-中的更改检测"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-2-中的更改检测"}},[t._v("#")]),t._v(" Vue 2 中的更改检测")]),t._v(" "),s("h3",{attrs:{id:"对于对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对于对象"}},[t._v("#")]),t._v(" 对于对象")]),t._v(" "),s("ul",[s("li",[t._v("Vue 无法检测到 property 的添加或删除。")]),t._v(" "),s("li",[t._v("Vue 不允许动态添加 "),s("strong",[t._v("根级别")]),t._v(" 的响应式 property。\n"),s("ul",[s("li",[t._v("可以使用 "),s("code",[t._v("Vue.set(object, propertyName, value)")]),t._v(" 方法向 "),s("strong",[t._v("嵌套对象")]),t._v(" 添加响应式 "),s("code",[t._v("property")])]),t._v(" "),s("li",[t._v("也可以使用"),s("code",[t._v("vm.$set 实例方法，这也是全局 Vue.set 方法的别名")])])])]),t._v(" "),s("li",[t._v("为已有对象赋值多个新 property，比如使用 "),s("code",[t._v("Object.assign()")]),t._v(" 或 "),s("code",[t._v("_.extend()")]),t._v("。但是，这样添加到对象上的新 "),s("code",[t._v("property")]),t._v(" 不会触发更新。应该用原对象与要混合进去的对象的 property 一起创建一个新的对象。"),s("code",[t._v("this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })")])])]),t._v(" "),s("h3",{attrs:{id:"对于数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对于数组"}},[t._v("#")]),t._v(" 对于数组")]),t._v(" "),s("ul",[s("li",[t._v("Vue 不能检测以下数组的变动：1. 直接通过索引设置元素；2.修改数组长度。")]),t._v(" "),s("li",[t._v("解决方法：\n"),s("ul",[s("li",[t._v("全局方法："),s("code",[t._v("Vue.set(vm.items, indexOfItem, newValue)")])]),t._v(" "),s("li",[t._v("实例方法："),s("code",[t._v("vm.$set(vm.items, indexOfItem, newValue)")])]),t._v(" "),s("li",[t._v("通过"),s("code",[t._v("splice")]),t._v("，"),s("code",[t._v("vm.items.splice(indexOfItem, 1, newValue)")])])])])]),t._v(" "),s("h3",{attrs:{id:"异步更新队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步更新队列"}},[t._v("#")]),t._v(" 异步更新队列")]),t._v(" "),s("ul",[s("li",[t._v("只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个侦听器被多次触发，它只会被推入到队列中一次。")]),t._v(" "),s("li",[t._v("在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 "),s("code",[t._v("Promise.then、MutationObserver 和 setImmediate")]),t._v("，如果执行环境不支持，则会采用 "),s("code",[t._v("setTimeout(fn, 0)")]),t._v(" 代替。")])]),t._v(" "),s("h2",{attrs:{id:"ts支持"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ts支持"}},[t._v("#")]),t._v(" TS支持")]),t._v(" "),s("ul",[s("li",[t._v("要让 "),s("code",[t._v("TypeScript")]),t._v(" 正确推断 "),s("code",[t._v("Vue")]),t._v(" 组件选项中的类型，需要使用 "),s("code",[t._v("defineComponent")]),t._v(" 全局方法定义组件。")]),t._v(" "),s("li",[t._v("推荐配置")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// tsconfig.json")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"compilerOptions"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"target"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"esnext"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"module"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"esnext"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这样就可以对 `this` 上的数据属性进行更严格的推断")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"strict"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"jsx"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"preserve"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"moduleResolution"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"node"')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"与组合式-api-一起使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#与组合式-api-一起使用"}},[t._v("#")]),t._v(" 与组合式 API 一起使用")]),t._v(" "),s("ul",[s("li",[t._v("在 "),s("code",[t._v("setup()")]),t._v(" 函数中，不需要将类型传递给 "),s("code",[t._v("props")]),t._v(" 参数，因为它将从 "),s("code",[t._v("props")]),t._v(" 组件选项推断类型。")])]),t._v(" "),s("h4",{attrs:{id:"类型声明-reactive"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类型声明-reactive"}},[t._v("#")]),t._v(" 类型声明 "),s("code",[t._v("reactive")])]),t._v(" "),s("ul",[s("li",[t._v("三种创建方式")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Book")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\ttitle"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" string\n\tprice"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("defineComponent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setup")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" book "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" reactive"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Book"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("title"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Vue'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" book"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("Book "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("reactive")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("title"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Vue'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" book "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("reactive")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("title"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Vue'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" Book\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h4",{attrs:{id:"类型声明-computed"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类型声明-computed"}},[t._v("#")]),t._v(" 类型声明 computed")]),t._v(" "),s("ul",[s("li",[t._v("计算值将根据返回值自动推断类型")])]),t._v(" "),s("h4",{attrs:{id:"为事件处理器添加类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为事件处理器添加类型"}},[t._v("#")]),t._v(" 为事件处理器添加类型")]),t._v(" "),s("ul",[s("li",[t._v("添加事件类型注解")]),t._v(" "),s("li",[t._v("断言 "),s("code",[t._v("target")]),t._v("为 html 标签元素。")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("handleEvent")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("evnt"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Event")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("event"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("target "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" HTMLInputElement"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h2",{attrs:{id:"代码风格"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码风格"}},[t._v("#")]),t._v(" 代码风格")]),t._v(" "),s("ul",[s("li",[t._v("组件名为多个单词。")]),t._v(" "),s("li",[t._v("prop 的定义应该尽量详细，至少指定其类型。")]),t._v(" "),s("li",[t._v("单文件组件的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 JS(X) 和模板中引用组件的方式尽可能地一致。例如："),s("code",[t._v("components/MyComponent.vue")]),t._v(" 或者"),s("code",[t._v("components/my-component.vue")])]),t._v(" "),s("li")]),t._v(" "),s("h3",{attrs:{id:"v-if-v-for"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-if-v-for"}},[t._v("#")]),t._v(" v-if, v-for")]),t._v(" "),s("ul",[s("li",[t._v("在 vue 2.x 中，在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用。")]),t._v(" "),s("li",[t._v("在 vue 3.x 中，v-if 总是优先于 v-for 生效。")])]),t._v(" "),s("h3",{attrs:{id:"组件样式作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件样式作用域"}},[t._v("#")]),t._v(" 组件样式作用域")]),t._v(" "),s("ul",[s("li",[t._v("对于单文件组件，推荐"),s("code",[t._v("scoped css")]),t._v("，作用域也可以通过 CSS Modules (一个基于 class 的，类似 BEM 的策略) 或者其它的库/约定来实现。")]),t._v(" "),s("li",[t._v("对于组件库来说，我们应该更倾向于选用基于 class 的策略，而不是 scoped attribute。")]),t._v(" "),s("li",[t._v("覆写内部样式变得更容易。")])]),t._v(" "),s("h2",{attrs:{id:"配置选型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#配置选型"}},[t._v("#")]),t._v(" 配置选型")]),t._v(" "),s("h3",{attrs:{id:"emits"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#emits"}},[t._v("#")]),t._v(" emits")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("emits")]),t._v(" 选项中列出的事件不会从组件的根元素继承，也将从 "),s("code",[t._v("$attrs property")]),t._v(" 中移除。")])]),t._v(" "),s("h3",{attrs:{id:"dom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dom"}},[t._v("#")]),t._v(" DOM")]),t._v(" "),s("ul",[s("li",[t._v("如果 Vue 选项中包含渲染函数，模板将被忽略。")]),t._v(" "),s("li",[s("code",[t._v("render")]),t._v(" 函数的优先级高于根据 "),s("code",[t._v("template")]),t._v(" 选项或挂载元素的 "),s("code",[t._v("DOM")]),t._v(" 内 "),s("code",[t._v("HTML")]),t._v(" 模板编译的渲染函数。")])]),t._v(" "),s("h3",{attrs:{id:"生命周期钩子-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期钩子-2"}},[t._v("#")]),t._v(" 生命周期钩子")]),t._v(" "),s("ul",[s("li",[t._v("所有生命周期钩子的 this 上下文将自动绑定至实例中，因此你可以访问 "),s("code",[t._v("data、computed 和 methods")]),t._v("。")]),t._v(" "),s("li",[t._v("这意味着你不应该使用箭头函数来定义一个生命周期方法。")]),t._v(" "),s("li",[s("code",[t._v("beforeCreate")]),t._v(": 实例初始化之后，进行数据侦听和事件/侦听器的配置之前同步调用。")]),t._v(" "),s("li",[s("code",[t._v("created")]),t._v(": 实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。挂载还未开始，"),s("code",[t._v("$el")]),t._v("不可使用。")]),t._v(" "),s("li",[s("code",[t._v("beforeMount")]),t._v(": "),s("code",[t._v("render")]),t._v("函数首次被调用，在SSR的时候不能使用。")]),t._v(" "),s("li",[s("code",[t._v("mounted")]),t._v(": 实例挂载完成，但不会保证所有子组件挂载完成。如果你希望等待整个视图都渲染完毕，可以在 "),s("code",[t._v("mounted")]),t._v(" 内部使用 "),s("code",[t._v("vm.$nextTick")]),t._v("。SSR期间不可用。")]),t._v(" "),s("li",[s("code",[t._v("beforeUpdate")]),t._v(": 在数据发生改变后，DOM 被更新之前被调用。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。")]),t._v(" "),s("li",[s("code",[t._v("updated")]),t._v(": 在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。"),s("code",[t._v("updated")]),t._v(" 不会保证所有的子组件也都被重新渲染完毕。如果你希望等待整个视图都渲染完毕，可以在 "),s("code",[t._v("updated")]),t._v(" 内部使用 "),s("code",[t._v("vm.$nextTick")]),t._v("。该钩子在SSR期间不被调用。")]),t._v(" "),s("li",[s("code",[t._v("activated")]),t._v(": "),s("code",[t._v("keep-alive")]),t._v("缓存的组件激活时候调用。SSR不可用。")]),t._v(" "),s("li",[s("code",[t._v("deactivated")]),t._v(": 被 "),s("code",[t._v("keep-alive")]),t._v(" 缓存的组件失活时调用。SSR不可用。")]),t._v(" "),s("li",[s("code",[t._v("beforeUnmount")]),t._v(": 卸载组件实例前调用。SSR不可用。")]),t._v(" "),s("li",[s("code",[t._v("unmounted")]),t._v(": 卸载组件实例后调用。调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。SSR不可用。")]),t._v(" "),s("li",[s("code",[t._v("errorCaptured")]),t._v(": 捕获一个来自后代的错误时被调用。")]),t._v(" "),s("li",[s("code",[t._v("renderTracked")]),t._v(": 跟踪虚拟DOM重新渲染时候调用。")]),t._v(" "),s("li",[s("code",[t._v("renderTriggered")]),t._v(": 虚拟DOM重新渲染被触发时调用。")])]),t._v(" "),s("h3",{attrs:{id:"mixins"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mixins"}},[t._v("#")]),t._v(" mixins")]),t._v(" "),s("ul",[s("li",[t._v("可定义多个"),s("code",[t._v("mixin")]),t._v(", 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。")]),t._v(" "),s("li",[s("code",[t._v("const mixin = {created() {}}")])]),t._v(" "),s("li",[s("code",[t._v("{mixins: [mixin]")])])]),t._v(" "),s("h3",{attrs:{id:"provide-inject-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#provide-inject-3"}},[t._v("#")]),t._v(" provide / inject")]),t._v(" "),s("ul",[s("li",[t._v("跟"),s("code",[t._v("React")]),t._v("的"),s("code",[t._v("context")]),t._v("类似。")])]),t._v(" "),s("h3",{attrs:{id:"setup-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#setup-2"}},[t._v("#")]),t._v(" setup")]),t._v(" "),s("ul",[s("li",[t._v("它是组件内部使用组合式 API 的入口点。")]),t._v(" "),s("li",[t._v("在创建组件实例时，在初始 "),s("code",[t._v("prop")]),t._v(" 解析之后立即调用 "),s("code",[t._v("setup")]),t._v("。在生命周期方面，它是在 "),s("code",[t._v("beforeCreate")]),t._v(" 钩子之前调用的。")]),t._v(" "),s("li",[t._v("从 "),s("code",[t._v("setup")]),t._v(" 返回的 "),s("code",[t._v("refs")]),t._v(" 在模板中访问时会自动解包，因此模板中不需要 "),s("code",[t._v(".value")]),t._v("。")]),t._v(" "),s("li",[s("code",[t._v("setup")]),t._v(" 还可以返回一个渲染函数.")]),t._v(" "),s("li",[s("code",[t._v("setup")]),t._v(" 的第一个参数是 "),s("code",[t._v("props")]),t._v(",此 "),s("code",[t._v("props")]),t._v(" 对象是响应式的。在传入新的 "),s("code",[t._v("props")]),t._v(" 时会对其进行更新。不要解构 "),s("code",[t._v("props")]),t._v(" 对象，因为它会失去响应式.")])]),t._v(" "),s("h3",{attrs:{id:"name"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#name"}},[t._v("#")]),t._v(" name")]),t._v(" "),s("ul",[s("li",[t._v("设置组件名称，便于调试。")])]),t._v(" "),s("h3",{attrs:{id:"inheritattrs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#inheritattrs"}},[t._v("#")]),t._v(" inheritAttrs")]),t._v(" "),s("ul",[s("li",[t._v("默认值为true。默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。")]),t._v(" "),s("li",[t._v("通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过实例 property $attrs 可以让这些 attribute 生效，且可以通过 v-bind 显性的绑定到非根元素上。")])]),t._v(" "),s("h2",{attrs:{id:"实例属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实例属性"}},[t._v("#")]),t._v(" 实例属性")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("$data")]),t._v(": 组件实例监听的数据对象。")]),t._v(" "),s("li",[s("code",[t._v("$props")]),t._v(": 组件接收的"),s("code",[t._v("props")]),t._v("对象。")]),t._v(" "),s("li",[s("code",[t._v("$el")]),t._v(":实例正在使用的根 DOM 元素。")])]),t._v(" "),s("h2",{attrs:{id:"实例方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实例方法"}},[t._v("#")]),t._v(" 实例方法")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("$watch")]),t._v(" "),s("ul",[s("li",[t._v("当侦听的值是一个对象或者数组时，对其属性或元素的任何更改都不会触发侦听器，因为它们引用相同的对象/数组。")]),t._v(" "),s("li",[s("code",[t._v("$watch")]),t._v(" 返回一个取消侦听函数，用来停止触发回调。")]),t._v(" "),s("li",[t._v("选项："),s("code",[t._v("deep")]),t._v("，为了发现对象内部值的变化。")]),t._v(" "),s("li",[t._v("选项："),s("code",[t._v("immediate")]),t._v("，指定 "),s("code",[t._v("immediate: true")]),t._v(" 将立即以表达式的当前值触发回调。")]),t._v(" "),s("li",[t._v("选项："),s("code",[t._v("flush")]),t._v("。默认值是 "),s("code",[t._v("pre")]),t._v("，指定的回调应该在渲染前被调用。")])])]),t._v(" "),s("li",[t._v("$forceUpdate: 迫使组件实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件.")]),t._v(" "),s("li",[t._v("$nextTick: 它跟全局方法 "),s("code",[t._v("nextTick")]),t._v(" 一样，不同的是回调中的 "),s("code",[t._v("this")]),t._v(" 自动绑定到调用它的实例上。")])]),t._v(" "),s("h2",{attrs:{id:"指令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#指令"}},[t._v("#")]),t._v(" 指令")]),t._v(" "),s("ul",[s("li",[t._v("v-memo：通常用于长列表优化。该指令接收一个固定长度的数组作为依赖值进行记忆比对。如果数组中的每个值都和上次渲染的时候相同，则整个该子树的更新会被跳过。在 v-for 中使用 v-memo 时，确保它们被用在了同一个元素上。 v-memo 在 v-for 内部是无效的。")])]),t._v(" "),s("h2",{attrs:{id:"特殊属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特殊属性"}},[t._v("#")]),t._v(" 特殊属性")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("key")]),t._v(": 有相同父元素的子元素必须有唯一的 "),s("code",[t._v("key")]),t._v("。它也可以用于强制替换元素/组件而不是重复使用它。")]),t._v(" "),s("li",[s("code",[t._v("ref")]),t._v(": "),s("code",[t._v("ref")]),t._v(" 被用来给元素或子组件注册引用信息。引用信息将会被注册在父组件的 "),s("code",[t._v("$refs")]),t._v(" 对象上。")]),t._v(" "),s("li",[s("code",[t._v("is")]),t._v(": 有的时候你可能需要 Vue 将一个原生元素替换为一个 Vue 组件。这是你可以把 is attribute 的值加上 vue: 前缀，这样 Vue 就会将这些元素换为 Vue 组件进行渲染。")])]),t._v(" "),s("h2",{attrs:{id:"内置组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内置组件"}},[t._v("#")]),t._v(" 内置组件")]),t._v(" "),s("ul",[s("li",[t._v("可以直接在模板中使用，不需要注册。")]),t._v(" "),s("li",[s("code",[t._v("<keep-alive>、<transition>、<transition-group> 和 <teleport>")]),t._v(" 组件都可以被打包工具 "),s("code",[t._v("tree-shake")]),t._v("。")])])])}),[],!1,null,null,null);e.default=v.exports}}]);