(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{410:function(t,o,e){"use strict";e.r(o);var a=e(45),s=Object(a.a)({},(function(){var t=this,o=t.$createElement,e=t._self._c||o;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react-hooks-vs-vue-composition-api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks-vs-vue-composition-api"}},[t._v("#")]),t._v(" React Hooks VS Vue Composition API")]),t._v(" "),e("h2",{attrs:{id:"对比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对比"}},[t._v("#")]),t._v(" 对比")]),t._v(" "),e("ul",[e("li",[t._v("Compotision API 受到了 Hooks 的启发，规避了一些 Hooks 的问题。")]),t._v(" "),e("li",[t._v("Hooks 是纯函数。两者的思想是不同的。")]),t._v(" "),e("li",[t._v("使用 React Hooks 就要尽量采用 immutable 变量，降低函数调用过频影响性能（部分 React 调度策略兜底）；使用 Vue 就尽量不要依赖跟踪丢失或者滥用依赖跟踪导致行为不可预测。")])]),t._v(" "),e("h2",{attrs:{id:"兼容性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#兼容性"}},[t._v("#")]),t._v(" 兼容性")]),t._v(" "),e("ul",[e("li",[t._v("可以在 Vue 2.x 中通过 @vue/composition-api 插件尝试新 API")]),t._v(" "),e("li",[t._v("React 不反对类组件。")])]),t._v(" "),e("h2",{attrs:{id:"差别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#差别"}},[t._v("#")]),t._v(" 差别")]),t._v(" "),e("ul",[e("li",[t._v("React Hook 底层是基于链表实现，调用的条件是每次组件被 render 的时候都会顺序执行所有的 Hooks。每一个 Hook 的 next 是指向下一个 Hook 的，if 会导致顺序不正确，从而导致报错。")]),t._v(" "),e("li",[t._v("Vue Hook 只会被注册调用一次，Vue 能避开这些麻烦的问题，原因在于它对数据的响应是基于 proxy 的，对数据直接代理观察。")]),t._v(" "),e("li",[t._v("由于 React Hooks 会多次运行，所以 render 方法必须遵守某些规则，比如:\n"),e("ul",[e("li",[t._v("不要在循环内部、条件语句中或嵌套函数里调用 Hooks")])])])]),t._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://juejin.cn/post/6847902223918170126",target:"_blank",rel:"noopener noreferrer"}},[t._v("翻译：Vue Composition API 和 React Hooks 对比"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);o.default=s.exports}}]);