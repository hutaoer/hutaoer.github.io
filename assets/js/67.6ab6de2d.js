(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{461:function(e,v,t){"use strict";t.r(v);var _=t(3),r=Object(_.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"git-rebase-和-git-merge"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#git-rebase-和-git-merge"}},[e._v("#")]),e._v(" git rebase 和 git merge")]),e._v(" "),v("h2",{attrs:{id:"git-pull"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#git-pull"}},[e._v("#")]),e._v(" git pull")]),e._v(" "),v("ul",[v("li",[e._v("举例：拉取远程的分支"),v("code",[e._v("B1")]),e._v("。")]),e._v(" "),v("li",[e._v("拉取代码，使用"),v("code",[e._v("git pull origin B1 --rebase")]),e._v(" 而不是 "),v("code",[e._v("git pull origin B1")])]),e._v(" "),v("li",[e._v("平时使用 rebase 注意的一点，"),v("code",[e._v("git pull")]),e._v(" 这条命令默认使用了 "),v("code",[e._v("--merge")]),e._v(" 的方式更新代码，如果你不指定用 "),v("code",[e._v("--rebase")]),e._v("，有的时候就会发现日志里有这样的一次提交 "),v("code",[e._v("Merge")])]),e._v(" "),v("li",[e._v("这时候直接使用 "),v("code",[e._v("git push origin B1")]),e._v(" 提示也说明了提交失败的原因。使用 "),v("code",[e._v("rebase")]),e._v(" 之后，master分支上比B1分支上多的修改，直接“插入”到了B1分支修改的内容之后，也就是 master 分支的修改在 B1 分支上重演了一遍，相对远程 B1 分支而言，本地仓库的B1分支的“基底”已经变化了，直接 push 是不行的，所以确保没有问题的情况下必须使用 "),v("code",[e._v("--force")]),e._v(" 参数才能提交。")])]),e._v(" "),v("h2",{attrs:{id:"git-merge"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#git-merge"}},[e._v("#")]),e._v(" git merge")]),e._v(" "),v("ul",[v("li",[e._v("当我们合并两个没有上下游关系的分支时，git会自动替我们生成一个"),v("code",[e._v("merge commit")]),e._v("，记录此次的"),v("code",[e._v("merge")]),e._v("。记录"),v("code",[e._v("merge")]),e._v("操作没有什么问题，问题是如果我们遇到特殊情况需要反复"),v("code",[e._v("merge")]),e._v("的时候，就会导致"),v("code",[e._v("commit")]),e._v("的提交记录非常混乱。")]),e._v(" "),v("li",[e._v("git merge 有如下几种方式：")])]),e._v(" "),v("h3",{attrs:{id:"ff"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ff"}},[e._v("#")]),e._v(" --ff")]),e._v(" "),v("ul",[v("li",[e._v("这是默认的行为， 即 "),v("code",[e._v("fast-forward")]),e._v(" 方式，又叫快进式合并，仅仅是指针的移动。缺点是：分支删除的时候，会丢失merge分支信息。")]),e._v(" "),v("li",[e._v("When the merge resolves as a fast-forward, only update the branch pointer, without creating a merge commit. This is the default behavior.")])]),e._v(" "),v("h3",{attrs:{id:"squash"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#squash"}},[e._v("#")]),e._v(" –-squash")]),e._v(" "),v("ul",[v("li",[e._v("把一些不必要commit进行压缩。最终形成一个"),v("code",[e._v("commit")]),e._v("，作为一个总结式的"),v("code",[e._v("message")])]),e._v(" "),v("li",[e._v("在"),v("code",[e._v("merge pr")]),e._v("的时候，有个选项是"),v("code",[e._v("merge squash")]),e._v("。比如我们有个"),v("code",[e._v("feature/dev")]),e._v("分支，开发测试完成后，要想主干分支合并，可以这样操作：\n"),v("ul",[v("li",[v("code",[e._v("git checkout master")])]),e._v(" "),v("li",[v("code",[e._v("git merge --squash feature/dev")])])])]),e._v(" "),v("li",[e._v("注意：这里merge的时候，commit的作者是执行操作的同学。那么历史记录中的提交者信息可能会丢失。")])]),e._v(" "),v("h3",{attrs:{id:"no-ff"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#no-ff"}},[e._v("#")]),e._v(" --no-ff")]),e._v(" "),v("ul",[v("li",[e._v("关闭"),v("code",[e._v("fast-forward")]),e._v("式的合并。")])]),e._v(" "),v("h2",{attrs:{id:"git-rebase-使用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#git-rebase-使用场景"}},[e._v("#")]),e._v(" git rebase 使用场景")]),e._v(" "),v("ul",[v("li",[e._v("所谓的变基其实就是找到两个分支共同的祖先，然后在当前分支上合并从共同祖先到现在的所有 "),v("code",[e._v("commit")])]),e._v(" "),v("li",[e._v("当我们"),v("code",[e._v("rebase")]),e._v("了之后再提交合并请求我们的合并记录里面会非常干净，没有多余"),v("code",[e._v("merge")]),e._v("的信息。对于多人协同开发的场景非常有帮助。")]),e._v(" "),v("li",[e._v("拉取远程代码\n"),v("ul",[v("li",[v("code",[e._v("git pull origin master --rebase")])])])]),e._v(" "),v("li",[e._v("合并多次提交\n"),v("ul",[v("li",[v("code",[e._v("git rebase -i")])]),e._v(" "),v("li",[e._v("进入交互界面后，将除第一行的pick外，其余的pick都改成 squash ，退出编辑模式，保存即可。")]),e._v(" "),v("li",[e._v("这样就把几次的commit汇总到了一次commit中。")])])]),e._v(" "),v("li",[e._v("合并某个"),v("code",[e._v("feature")]),e._v("分支到"),v("code",[e._v("master")]),e._v("分支的步骤：\n"),v("ul",[v("li",[v("code",[e._v("git checkout feature/xxx")])]),e._v(" "),v("li",[v("code",[e._v("git rebase master")])]),e._v(" "),v("li",[v("code",[e._v("git checkout master")])]),e._v(" "),v("li",[v("code",[e._v("git merge feature/xxx")])])])]),e._v(" "),v("li",[v("code",[e._v("rebase")]),e._v("过程中，如果碰到文件冲突，那么就解决冲突，然后再继续"),v("code",[e._v("git rebase continue")])]),e._v(" "),v("li",[e._v("使用"),v("code",[e._v("git rebase")]),e._v("可以使得我们本地的提交基于远程的最新提交。")])]),e._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),v("ul",[v("li",[e._v("feature 分支合并到主干分支（比如master）的时候，先在feature分支使用"),v("code",[e._v("git rebase master")]),e._v("，然后再到主干分支进行合并"),v("code",[e._v("feature")]),e._v("分支。")]),e._v(" "),v("li",[e._v("要经常从上游分支更新代码，如果长时间不更新上游分支代码容易出现大量冲突。")]),e._v(" "),v("li",[e._v("rebase 可以尽可能保持 master 分支干净整洁，并且易于识别 author")]),e._v(" "),v("li",[e._v("squash 也可以保持 master 分支干净，但是 master 中 author 都是 maintainer，而不是原 owner")]),e._v(" "),v("li",[e._v("merge 不能保持 master 分支干净，但是保持了所有的 commit history。")])])])}),[],!1,null,null,null);v.default=r.exports}}]);