(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{375:function(t,a,s){"use strict";s.r(a);var e=s(45),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"typescript-学习笔记-基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#typescript-学习笔记-基础"}},[t._v("#")]),t._v(" TypeScript 学习笔记 —— 基础")]),t._v(" "),s("h2",{attrs:{id:"什么是-typescript"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-typescript"}},[t._v("#")]),t._v(" 什么是 TypeScript")]),t._v(" "),s("ul",[s("li",[t._v("TypeScript 是一种结构类型。")]),t._v(" "),s("li",[t._v("TypeScript 是对所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。")])]),t._v(" "),s("h2",{attrs:{id:"类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类型"}},[t._v("#")]),t._v(" 类型")]),t._v(" "),s("h3",{attrs:{id:"数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),s("ul",[s("li",[t._v("两种定义数组的方式："),s("code",[t._v("Array<类型>")]),t._v(" 和 "),s("code",[t._v("类型[]")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("let arr: number[] = [1,2,3]")])]),t._v(" "),s("li",[s("code",[t._v("let arr1: Array<number> = [4,5,6]")])])])])]),t._v(" "),s("h3",{attrs:{id:"any"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#any"}},[t._v("#")]),t._v(" any")]),t._v(" "),s("ul",[s("li",[t._v("任何类型都可以归为 "),s("code",[t._v("any")]),t._v(" 类型，它是 "),s("code",[t._v("TS")]),t._v(" 中的顶级类型。")]),t._v(" "),s("li",[t._v("给一个变量声明为 any，相当于关闭了类型检查。any 类型的变量可以赋值给任意类型。不会校验出错。")])]),t._v(" "),s("h3",{attrs:{id:"undefined-和-null"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#undefined-和-null"}},[t._v("#")]),t._v(" undefined 和 null")]),t._v(" "),s("ul",[s("li",[t._v("默认情况下 null 和 undefined 是所有类型的子类型。")])]),t._v(" "),s("h3",{attrs:{id:"never"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#never"}},[t._v("#")]),t._v(" never")]),t._v(" "),s("ul",[s("li",[t._v("never 类型是任何类型的子类型，也可以赋值给任何类型。没有类型是 never 的子类型或可以赋值给 never 类型")]),t._v(" "),s("li",[t._v("never 类型表示那些永不存在的值的类型。")]),t._v(" "),s("li",[t._v("使用场景：\n"),s("ul",[s("li",[t._v("抛出异常的函数表达式，返回值类型为"),s("code",[t._v("never")])]),t._v(" "),s("li",[t._v("不能取得值的地方，比如 switch case 语句中的 default 分支。")])])])]),t._v(" "),s("h3",{attrs:{id:"unknown"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#unknown"}},[t._v("#")]),t._v(" unknown")]),t._v(" "),s("ul",[s("li",[t._v("unknown 类型作为 any 类型对应的安全类型使用起来更加安全，如果有 any 类型的使用需求，应尽量使用 unknown 类型来替代 any 类型。")]),t._v(" "),s("li",[t._v("unknown 类型是 any 类型对应的安全类型。")]),t._v(" "),s("li",[t._v("unknown 类型只能分配给 any 类型和 unknown 类型本身。")]),t._v(" "),s("li",[t._v("unknown 类型在被确定为某个类型之前，不能被进行诸如函数执行、实例化等操作，一定程度上对类型进行了保护。")])]),t._v(" "),s("h2",{attrs:{id:"is-类型谓词"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#is-类型谓词"}},[t._v("#")]),t._v(" is 类型谓词")]),t._v(" "),s("ul",[s("li",[t._v("用来判断一个变量属于某个接口或类型。")])]),t._v(" "),s("h2",{attrs:{id:"枚举"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#枚举"}},[t._v("#")]),t._v(" 枚举")]),t._v(" "),s("ul",[s("li",[t._v("用于定义一组相同主题的常量数据")]),t._v(" "),s("li",[t._v("字符串枚举成员不会生成反向映射。")])]),t._v(" "),s("h2",{attrs:{id:"字面量类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字面量类型"}},[t._v("#")]),t._v(" 字面量类型")]),t._v(" "),s("ul",[s("li",[t._v("主要有字符串、数字、布尔值、对象等几种字面量类型。")])]),t._v(" "),s("h2",{attrs:{id:"接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[t._v("#")]),t._v(" 接口")]),t._v(" "),s("ul",[s("li",[t._v("使用接口来定义契约，如类型命名、属性检查、函数类型定义等。")]),t._v(" "),s("li",[t._v("不能把 interface 定义的内容当做变量进行使用。")]),t._v(" "),s("li",[t._v("接口的首字母需要大写。只需要关注值的类型，不同于其他语言，定义接口是为了实现。")]),t._v(" "),s("li",[t._v("使用场景：在声明一个对象、函数或者类时，先定义接口，确保其数据结构的一致性。多人协作时候，尤其重要。")]),t._v(" "),s("li",[t._v("readonly vs const 区别：\n"),s("ul",[s("li",[t._v("做为 变量 使用的话用 const，若做为 属性 则使用 readonly。")]),t._v(" "),s("li",[s("code",[t._v("ReadonlyArray<T>")]),t._v(" 设置数组为只读，那么它的所有写方法都会失效。")])])]),t._v(" "),s("li",[t._v("希望接口允许有任意的属性，语法是用 [] 将属性包裹起来，使用字符串索引")]),t._v(" "),s("li",[t._v("接口可以合并和继承。")]),t._v(" "),s("li",[t._v("接口在继承的时候，可以被覆盖，规则：只能是required覆盖optional，optional不能覆盖required。")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Obj")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("propName"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" string"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用 unknown 是否会更好些？")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"函数类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数类型"}},[t._v("#")]),t._v(" 函数类型")]),t._v(" "),s("ul",[s("li",[t._v("使用调用签名来表示函数类型。包括：参数列表和返回类型。")]),t._v(" "),s("li",[t._v("类型检查的时候，函数的参数名不需要与接口中的参数名保持一致。")]),t._v(" "),s("li",[t._v("接口中的函数类型带有函数名，下面两种书写方式是等价的：")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Calculate")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number\n  "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("multiply")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" number\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),s("h3",{attrs:{id:"可索引类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可索引类型"}},[t._v("#")]),t._v(" 可索引类型")]),t._v(" "),s("ul",[s("li",[t._v("索引类型签名包括两种：字符串类型和 number 类型。")]),t._v(" "),s("li",[t._v("可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。")]),t._v(" "),s("li",[t._v("因为当使用 number 来索引时，JavaScript 会将它转换成 string 然后再去索引对象。")])]),t._v(" "),s("h3",{attrs:{id:"类类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类类型"}},[t._v("#")]),t._v(" 类类型")]),t._v(" "),s("ul",[s("li",[t._v("类接口需要通过 "),s("code",[t._v("implements")]),t._v(" 来实现")]),t._v(" "),s("li",[t._v("也可以通过 "),s("code",[t._v("extends")]),t._v(" 继承。这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。")]),t._v(" "),s("li",[t._v("一个接口可以继承多个接口。")])]),t._v(" "),s("h3",{attrs:{id:"混合类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#混合类型"}},[t._v("#")]),t._v(" 混合类型")]),t._v(" "),s("ul",[s("li",[t._v("声明一个接口，如果只有"),s("code",[t._v("(start: number): string")]),t._v(" 一个成员，那么这个接口就是函数接口，同时还具有其他两个成员，可以用来描述对象的属性和方法，这样就构成了一个混合接口。")])]),t._v(" "),s("h3",{attrs:{id:"interface-与-type-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#interface-与-type-区别"}},[t._v("#")]),t._v(" interface 与 type 区别")]),t._v(" "),s("ul",[s("li",[t._v("都可以描述一个对象或者函数")])]),t._v(" "),s("h4",{attrs:{id:"type"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#type"}},[t._v("#")]),t._v(" type")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("type")]),t._v(" 可以声明基本类型别名，联合类型: "),s("code",[t._v("type AB = A | B")])]),t._v(" "),s("li",[s("code",[t._v("type")]),t._v(" 语句中还可以使用 "),s("code",[t._v("typeof")]),t._v(" 获取实例的 类型进行赋值: "),s("code",[t._v("type B = typeof A")])])]),t._v(" "),s("h4",{attrs:{id:"interface"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#interface"}},[t._v("#")]),t._v(" interface")]),t._v(" "),s("ul",[s("li",[t._v("接口可以继承和实现")]),t._v(" "),s("li",[t._v("接口可以进行声明合并")])]),t._v(" "),s("h2",{attrs:{id:"类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[t._v("#")]),t._v(" 类")]),t._v(" "),s("ul",[s("li",[t._v("访问修饰符：四种访问修饰符 public、protected、private 和 readonly。")]),t._v(" "),s("li",[t._v("静态方法调用同一个类中的其他静态方法，可使用 this 关键字。")]),t._v(" "),s("li",[t._v("静态方法中的 this 指向类本身，而静态方法也存在于类本身，所以可以在静态方法中用 this 访问在同一类中的其他静态方法。")]),t._v(" "),s("li",[t._v("非静态方法中，不能直接使用 this 关键字来访问静态方法。而要用类本身或者构造函数的属性来调用该方法：")]),t._v(" "),s("li",[t._v("类指向其构造函数本身，在非静态方法中，this.constructor === StaticMethodCall 为 true， 也就是说这两种写法等价。")]),t._v(" "),s("li",[t._v("类指向其构造函数本身。")]),t._v(" "),s("li",[t._v("静态方法存在于类本身上面而不是类的实例上。")]),t._v(" "),s("li",[t._v("抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。")]),t._v(" "),s("li",[t._v("子类继承父类时，在其构造函数 constructor() 中不要忘了 super() 方法。")])]),t._v(" "),s("h2",{attrs:{id:"函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[t._v("#")]),t._v(" 函数")]),t._v(" "),s("ul",[s("li",[t._v("等号左侧的类型定义由两部分组成：参数类型和返回值类型，通过 => 符号来连接。")]),t._v(" "),s("li",[t._v("这里要注意：函数类型的 => 和 箭头函数的 => 是不同的含义。")]),t._v(" "),s("li",[t._v("注意 rest 参数 只能是最后一个参数。")]),t._v(" "),s("li",[t._v("在函数执行时， this 关键字并不会指向正在运行的函数本身，而是 指向调用函数的对象。")]),t._v(" "),s("li",[t._v("字面量类型:字符串字面量类型还可以用于区分函数重载：")])]),t._v(" "),s("h2",{attrs:{id:"类型断言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类型断言"}},[t._v("#")]),t._v(" 类型断言")]),t._v(" "),s("ul",[s("li",[t._v("两种方式：\n"),s("ul",[s("li",[t._v("通过 as 关键字进行类型断言")]),t._v(" "),s("li",[t._v("类型断言还可以通过标签 <> 来实现")])])]),t._v(" "),s("li",[t._v("当使用 JSX 语法时，会跟标签 <> 形式的类型断言混淆，推荐统一使用 "),s("code",[t._v("as type")]),t._v(" 语法。")]),t._v(" "),s("li",[t._v("非空断言："),s("code",[t._v("!")])]),t._v(" "),s("li",[t._v("双重断言：使用 as 关键字进行两次断言，使用场景很少。")]),t._v(" "),s("li",[t._v("赋值的时候，使用"),s("code",[t._v("as const")]),t._v("可以将变量改成 "),s("code",[t._v("readonly")]),t._v("类型。")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" z "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" text"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nz"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("text "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'1123'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// error: Cannot assign to 'text' because it is a read-only property.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" z1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("text"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'hi'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nz1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("text "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'hello'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ok")]),t._v("\n")])])]),s("ul",[s("li",[t._v("注意：类型断言是不够严谨的，如果某个类型的变量缺少一些接口中定义的属性，也不会报错。")])]),t._v(" "),s("h2",{attrs:{id:"类型保护"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类型保护"}},[t._v("#")]),t._v(" 类型保护")]),t._v(" "),s("ul",[s("li",[t._v("类型保护是指缩小类型的范围，在一定的块级作用域内由编译器推导其类型，提示并规避不合法的操作。")]),t._v(" "),s("li",[t._v("可以通过四种方式将代码类型范围缩小："),s("code",[t._v("typeof， instanceof， in， 字面量类型")]),t._v(" "),s("ul",[s("li",[t._v("typeof 判断基础类型")]),t._v(" "),s("li",[t._v("instanceof 判断是否为对象的实例")]),t._v(" "),s("li",[t._v("in 操作符用于确定属性是否存在于某个对象上")])])]),t._v(" "),s("li",[t._v("字面量类型")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("type Success "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  success"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ntype Fail "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  success"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("check")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("res"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Success "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" Fail")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("success"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// do something successful")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// do something failed")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h2",{attrs:{id:"声明文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#声明文件"}},[t._v("#")]),t._v(" 声明文件")]),t._v(" "),s("ul",[s("li",[t._v("当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。")]),t._v(" "),s("li",[t._v("声明文件必需以"),s("code",[t._v(".d.ts")]),t._v("为后缀。推荐使用 "),s("code",[t._v("@types")]),t._v(" 统一管理第三方库的声明文件。"),s("code",[t._v("@types")]),t._v(" 的使用方式很简单，直接用 npm 安装对应的声明模块即可。")]),t._v(" "),s("li",[t._v("如果第三方库没有提供声明文件，则需要手动书写声明文件。")]),t._v(" "),s("li",[t._v("一般来说，ts 会解析项目中所有的 "),s("code",[t._v("*.ts")]),t._v(" 文件，当然也包含以 "),s("code",[t._v(".d.ts")]),t._v("结尾的文件。")])]),t._v(" "),s("h3",{attrs:{id:"语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[t._v("#")]),t._v(" 语法")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("declare "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" 声明全局变量\ndeclare "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" 声明全局方法\ndeclare "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" 声明全局类\ndeclare "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("enum")]),t._v(" 声明全局枚举类型\ndeclare namespace 声明（含有子属性的）全局对象\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" 和 type 声明全局类型\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" 导出变量\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" namespace 导出（含有子属性的）对象\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("ES6")]),t._v(" 默认导出\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" commonjs 导出模块\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" namespace "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("UMD")]),t._v(" 库声明全局变量\ndeclare global 扩展全局变量\ndeclare module 扩展模块\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/// <reference /> 三斜线指令")]),t._v("\n")])])]),s("h3",{attrs:{id:"declare-namespace"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#declare-namespace"}},[t._v("#")]),t._v(" declare namespace")]),t._v(" "),s("ul",[s("li",[t._v("namespace 是 ts 早期时为了解决模块化而创造的关键字。")]),t._v(" "),s("li",[t._v("早期还没有 ES6 的时候，ts 提供了一种模块化方案，使用 module 关键字表示内部模块。但由于后来 ES6 也使用了 module 关键字，ts 为了兼容 ES6，使用 namespace 替代了自己的 module，更名为命名空间。")])]),t._v(" "),s("h3",{attrs:{id:"interface-和-type"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#interface-和-type"}},[t._v("#")]),t._v(" interface 和 type")]),t._v(" "),s("ul",[s("li",[t._v("暴露全局的接口和类型，其他文件可以直接使用。")]),t._v(" "),s("li",[t._v("暴露在最外层的 interface 或 type 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。推荐它们放到 namespace 下。")]),t._v(" "),s("li",[t._v("interface 前是不需要 declare 。")])]),t._v(" "),s("h3",{attrs:{id:"发布声明文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#发布声明文件"}},[t._v("#")]),t._v(" 发布声明文件")]),t._v(" "),s("ul",[s("li",[t._v("1.将声明文件和源码放在一起，2.将声明文件发布到 @types 下")])]),t._v(" "),s("h3",{attrs:{id:"注意"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注意"}},[t._v("#")]),t._v(" 注意")]),t._v(" "),s("ul",[s("li",[t._v("声明语句中只能定义类型，不能定义具体的实现。")]),t._v(" "),s("li",[t._v("在函数类型的声明语句中，支持函数重载。")]),t._v(" "),s("li",[s("code",[t._v("declare class")]),t._v(" 语句也只能用来定义类型，不能用来定义具体的实现。")])]),t._v(" "),s("h2",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"http://www.imooc.com/wiki/typescriptlesson",target:"_blank",rel:"noopener noreferrer"}},[t._v("TypeScript慕课教程"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://ts.xcatliu.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("TypeScript入门教程"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=r.exports}}]);