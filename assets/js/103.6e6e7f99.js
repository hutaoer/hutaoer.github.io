(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{499:function(o,e,t){"use strict";t.r(e);var v=t(3),_=Object(v.a)({},(function(){var o=this,e=o._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[e("h1",{attrs:{id:"react-hooks-vs-vue-composition-api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks-vs-vue-composition-api"}},[o._v("#")]),o._v(" React Hooks VS Vue Composition API")]),o._v(" "),e("h2",{attrs:{id:"hooks的意义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hooks的意义"}},[o._v("#")]),o._v(" Hooks的意义")]),o._v(" "),e("ul",[e("li",[o._v("之前为了逻辑复用，避免耦合，后来各大框架纷纷想出了一些办法，比如 minix, render props, 高阶组件等实现逻辑上的复用，但是都有一些额外的问题。\n"),e("ul",[e("li",[o._v("minix 与组件之间存在隐式依赖，可能产生冲突。")]),o._v(" "),e("li",[o._v("高阶组件 多层包裹嵌套组件，增加了复杂度和理解成本，调试也会相对麻烦。")]),o._v(" "),e("li",[o._v("Render Props 不好维护, 同样存在嵌套问题。")])])]),o._v(" "),e("li",[o._v("通过 function 抽离的方式，实现了复杂逻辑的内部封装：\n"),e("ul",[e("li",[o._v("逻辑代码的复用")]),o._v(" "),e("li",[o._v("减小了代码体积")]),o._v(" "),e("li",[o._v("没有 "),e("code",[o._v("this")]),o._v(" 的问题")])])])]),o._v(" "),e("h2",{attrs:{id:"对比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对比"}},[o._v("#")]),o._v(" 对比")]),o._v(" "),e("ul",[e("li",[o._v("Compotision API 受到了 Hooks 的启发，规避了一些 Hooks 的问题。")]),o._v(" "),e("li",[o._v("Hooks 是纯函数。两者的思想是不同的。")]),o._v(" "),e("li",[o._v("使用 React Hooks 就要尽量采用 immutable 变量，降低函数调用过频影响性能（部分 React 调度策略兜底）；使用 Vue 就尽量不要依赖跟踪丢失或者滥用依赖跟踪导致行为不可预测。")])]),o._v(" "),e("h2",{attrs:{id:"兼容性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#兼容性"}},[o._v("#")]),o._v(" 兼容性")]),o._v(" "),e("ul",[e("li",[o._v("可以在 Vue 2.x 中通过 @vue/composition-api 插件尝试新 API")]),o._v(" "),e("li",[o._v("React 不反对类组件。")])]),o._v(" "),e("h2",{attrs:{id:"相同点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#相同点"}},[o._v("#")]),o._v(" 相同点")]),o._v(" "),e("ul",[e("li",[o._v("React 的 useRef 和 Vue 的 ref 都允许你引用一个子组件 或 要附加到的 DOM 元素。")]),o._v(" "),e("li",[o._v("使用"),e("code",[o._v("use")]),o._v("作为hooks的前缀。")])]),o._v(" "),e("h2",{attrs:{id:"差别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#差别"}},[o._v("#")]),o._v(" 差别")]),o._v(" "),e("h3",{attrs:{id:"react-hooks"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks"}},[o._v("#")]),o._v(" React Hooks")]),o._v(" "),e("ul",[e("li",[o._v("React Hook 底层是基于链表实现，调用的条件是每次组件被 render 的时候都会顺序执行所有的 Hooks。每一个 Hook 的 next 是指向下一个 Hook 的，if 会导致顺序不正确，从而导致报错。")]),o._v(" "),e("li",[o._v("由于 React Hooks 会多次运行，所以 render 方法必须遵守某些规则，比如:\n"),e("ul",[e("li",[o._v("不要在循环内部、条件语句中或嵌套函数里调用 Hooks")]),o._v(" "),e("li",[o._v("Hooks 只能用在函数组件中")])])]),o._v(" "),e("li",[o._v("每次render的时候，Hooks 都会重新注册，通过"),e("code",[o._v("useCallback")]),o._v("和"),e("code",[o._v("useMemo")]),o._v("来提升性能。")]),o._v(" "),e("li",[o._v("如何追踪依赖：\n"),e("ul",[e("li",[o._v("默认情况下，所有用 useEffect 注册的函数都会在每次渲染之后运行，但可以定义真实依赖的状态和属性。跳过不必要的渲染。")]),o._v(" "),e("li",[o._v("useCallback和useMemo 都有依赖项，用来决定是否返回缓存过的回调或值。")])])]),o._v(" "),e("li",[o._v("生命周期不同：\n"),e("ul",[e("li",[e("code",[o._v("useEffect")]),o._v("相当于"),e("code",[o._v("componentDidMount、componentDidUpdate 及 componentWillUnmount 的合集")])]),o._v(" "),e("li",[o._v("从生命周期，转变为对状态的依赖，更符合习惯。")])])]),o._v(" "),e("li",[o._v("上下文：\n"),e("ul",[e("li",[o._v("提供的"),e("code",[o._v("useContext")])])])])]),o._v(" "),e("h3",{attrs:{id:"composition-api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#composition-api"}},[o._v("#")]),o._v(" Composition API")]),o._v(" "),e("ul",[e("li",[o._v("Vue Hook 只会被注册调用一次，Vue 能避开这些麻烦的问题，原因在于它对数据的响应是基于 proxy 的，对数据直接代理观察。")]),o._v(" "),e("li",[o._v("setup() 为 Vue 组件提供了状态、计算值、watcher 和生命周期钩子.")]),o._v(" "),e("li",[o._v("只要对data进行了修改，那么相关的函数和模板都会被重新计算。")]),o._v(" "),e("li",[o._v("setup() 晚于 beforeCreate 钩子，早于 created 钩子被调用。")]),o._v(" "),e("li",[o._v("追踪依赖：\n"),e("ul",[e("li",[o._v("包裹在watch函数中，来相应状态或属性的改变。")])])]),o._v(" "),e("li",[o._v("生命周期\n"),e("ul",[e("li",[o._v("提供了"),e("code",[o._v("onMounted、onUpdated 和 onBeforeUnmount")]),o._v("生命周期钩子。")])])]),o._v(" "),e("li",[o._v("提供了：\n"),e("ul",[e("li",[o._v("inject/provide")]),o._v(" "),e("li",[o._v("如果想保持响应性，必须明确提供一个 ref/reactive 作为值.")])])])]),o._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[o._v("#")]),o._v(" 参考")]),o._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://juejin.cn/post/6847902223918170126",target:"_blank",rel:"noopener noreferrer"}},[o._v("翻译：Vue Composition API 和 React Hooks 对比"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=_.exports}}]);