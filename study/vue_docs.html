<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 文档学习笔记 | 逗逼码农</title>
    <meta name="generator" content="VuePress 1.9.9">
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?97584138af9a81f074d821256641e300";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    <meta name="description" content="持续提升，降低欲望；乐观幽默，自律坦然">
    
    <link rel="preload" href="/assets/css/0.styles.e8e4f3a3.css" as="style"><link rel="preload" href="/assets/js/app.4220ef43.js" as="script"><link rel="preload" href="/assets/js/2.07f3c95d.js" as="script"><link rel="preload" href="/assets/js/80.4c5877fb.js" as="script"><link rel="prefetch" href="/assets/js/10.31dddc5c.js"><link rel="prefetch" href="/assets/js/11.964e61e9.js"><link rel="prefetch" href="/assets/js/12.2db488c0.js"><link rel="prefetch" href="/assets/js/13.6a126940.js"><link rel="prefetch" href="/assets/js/14.79b8c8b8.js"><link rel="prefetch" href="/assets/js/15.aa3804ca.js"><link rel="prefetch" href="/assets/js/16.9252eac0.js"><link rel="prefetch" href="/assets/js/17.0f2108d7.js"><link rel="prefetch" href="/assets/js/18.4d9ea04c.js"><link rel="prefetch" href="/assets/js/19.de161077.js"><link rel="prefetch" href="/assets/js/20.fd4e2149.js"><link rel="prefetch" href="/assets/js/21.97398d5d.js"><link rel="prefetch" href="/assets/js/22.69bb038f.js"><link rel="prefetch" href="/assets/js/23.b7a4bc49.js"><link rel="prefetch" href="/assets/js/24.0b29bf2e.js"><link rel="prefetch" href="/assets/js/25.41ab8569.js"><link rel="prefetch" href="/assets/js/26.4fbb54d5.js"><link rel="prefetch" href="/assets/js/27.277d0b6b.js"><link rel="prefetch" href="/assets/js/28.001621d9.js"><link rel="prefetch" href="/assets/js/29.1aaa5d5c.js"><link rel="prefetch" href="/assets/js/3.d6b692e8.js"><link rel="prefetch" href="/assets/js/30.54302a67.js"><link rel="prefetch" href="/assets/js/31.7ea9e4ef.js"><link rel="prefetch" href="/assets/js/32.88db9afc.js"><link rel="prefetch" href="/assets/js/33.1a5faf80.js"><link rel="prefetch" href="/assets/js/34.f149916b.js"><link rel="prefetch" href="/assets/js/35.1f354762.js"><link rel="prefetch" href="/assets/js/36.58a30451.js"><link rel="prefetch" href="/assets/js/37.7d7a2b13.js"><link rel="prefetch" href="/assets/js/38.2b18eacf.js"><link rel="prefetch" href="/assets/js/39.fda650e0.js"><link rel="prefetch" href="/assets/js/4.045757b5.js"><link rel="prefetch" href="/assets/js/40.04d9f1e1.js"><link rel="prefetch" href="/assets/js/41.fd378062.js"><link rel="prefetch" href="/assets/js/42.795ec3e9.js"><link rel="prefetch" href="/assets/js/43.e688969d.js"><link rel="prefetch" href="/assets/js/44.4aba8bd9.js"><link rel="prefetch" href="/assets/js/45.29d1a621.js"><link rel="prefetch" href="/assets/js/46.ffd5438f.js"><link rel="prefetch" href="/assets/js/47.2a67c235.js"><link rel="prefetch" href="/assets/js/48.5e2fa954.js"><link rel="prefetch" href="/assets/js/49.b2e5f2ca.js"><link rel="prefetch" href="/assets/js/5.d2f3d5f9.js"><link rel="prefetch" href="/assets/js/50.7ba90205.js"><link rel="prefetch" href="/assets/js/51.61325695.js"><link rel="prefetch" href="/assets/js/52.154357cc.js"><link rel="prefetch" href="/assets/js/53.2e5f8990.js"><link rel="prefetch" href="/assets/js/54.59b07749.js"><link rel="prefetch" href="/assets/js/55.17a60a98.js"><link rel="prefetch" href="/assets/js/56.942517b0.js"><link rel="prefetch" href="/assets/js/57.2497c9bd.js"><link rel="prefetch" href="/assets/js/58.80aa5f95.js"><link rel="prefetch" href="/assets/js/59.5ee27c9c.js"><link rel="prefetch" href="/assets/js/6.dbf9f127.js"><link rel="prefetch" href="/assets/js/60.fd6efd14.js"><link rel="prefetch" href="/assets/js/61.487cd1ec.js"><link rel="prefetch" href="/assets/js/62.63b4cd02.js"><link rel="prefetch" href="/assets/js/63.c1df2dcd.js"><link rel="prefetch" href="/assets/js/64.9c02da80.js"><link rel="prefetch" href="/assets/js/65.2b513424.js"><link rel="prefetch" href="/assets/js/66.938df911.js"><link rel="prefetch" href="/assets/js/67.21e1984d.js"><link rel="prefetch" href="/assets/js/68.ef73b452.js"><link rel="prefetch" href="/assets/js/69.e1edf963.js"><link rel="prefetch" href="/assets/js/7.c0484196.js"><link rel="prefetch" href="/assets/js/70.e5a248f4.js"><link rel="prefetch" href="/assets/js/71.5e9136f8.js"><link rel="prefetch" href="/assets/js/72.e953761c.js"><link rel="prefetch" href="/assets/js/73.acc5fe88.js"><link rel="prefetch" href="/assets/js/74.f538b49a.js"><link rel="prefetch" href="/assets/js/75.c9246f13.js"><link rel="prefetch" href="/assets/js/76.4d257509.js"><link rel="prefetch" href="/assets/js/77.a4153525.js"><link rel="prefetch" href="/assets/js/78.69d4ea2d.js"><link rel="prefetch" href="/assets/js/79.489eed17.js"><link rel="prefetch" href="/assets/js/8.4acfd1db.js"><link rel="prefetch" href="/assets/js/81.4bf7e54d.js"><link rel="prefetch" href="/assets/js/82.23856e6a.js"><link rel="prefetch" href="/assets/js/83.6b825aa6.js"><link rel="prefetch" href="/assets/js/84.1aae3330.js"><link rel="prefetch" href="/assets/js/85.d0ac97ad.js"><link rel="prefetch" href="/assets/js/86.234c0e91.js"><link rel="prefetch" href="/assets/js/87.5a3e81de.js"><link rel="prefetch" href="/assets/js/88.a5a929bb.js"><link rel="prefetch" href="/assets/js/89.04f51fff.js"><link rel="prefetch" href="/assets/js/9.06390865.js"><link rel="prefetch" href="/assets/js/90.6fbaf67b.js"><link rel="prefetch" href="/assets/js/91.313a377a.js"><link rel="prefetch" href="/assets/js/92.1b2e581b.js"><link rel="prefetch" href="/assets/js/93.604a027c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e8e4f3a3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">逗逼码农</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://www.cnblogs.com/hutaoer/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  旧的博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/hutaoer" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://www.cnblogs.com/hutaoer/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  旧的博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/hutaoer" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Vue 文档学习笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/vue_docs.html#概述" class="sidebar-link">概述</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/vue_docs.html#计算属性-computed" class="sidebar-link">计算属性（computed）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/vue_docs.html#侦听器-watch" class="sidebar-link">侦听器（watch）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/vue_docs.html#class-与-style-绑定" class="sidebar-link">Class 与 Style 绑定</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/vue_docs.html#条件渲染" class="sidebar-link">条件渲染</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/vue_docs.html#v-show" class="sidebar-link">v-show</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#v-show-对比-v-if" class="sidebar-link">v-show 对比 v-if</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#v-if-与-v-for-一起使用" class="sidebar-link">v-if 与 v-for 一起使用</a></li></ul></li><li><a href="/study/vue_docs.html#列表渲染" class="sidebar-link">列表渲染</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/vue_docs.html#数组更新检测" class="sidebar-link">数组更新检测</a></li></ul></li><li><a href="/study/vue_docs.html#事件处理" class="sidebar-link">事件处理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/vue_docs.html#组件" class="sidebar-link">组件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/vue_docs.html#监听子组件事件" class="sidebar-link">监听子组件事件</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#组件绑定-v-model" class="sidebar-link">组件绑定 v-model</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#动态子组件" class="sidebar-link">动态子组件</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#异步组件" class="sidebar-link">异步组件</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#props" class="sidebar-link">props</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#单向数据流" class="sidebar-link">单向数据流</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#attribute-继承" class="sidebar-link">Attribute 继承</a></li></ul></li><li><a href="/study/vue_docs.html#插槽" class="sidebar-link">插槽</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/vue_docs.html#provide-inject" class="sidebar-link">Provide / Inject</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/vue_docs.html#过渡-动画" class="sidebar-link">过渡 &amp; 动画</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/vue_docs.html#组合式api" class="sidebar-link">组合式API</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/vue_docs.html#setup" class="sidebar-link">setup</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#生命周期钩子" class="sidebar-link">生命周期钩子</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#provide-inject-2" class="sidebar-link">provide / inject</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#mixin" class="sidebar-link">mixin</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#注意" class="sidebar-link">注意</a></li></ul></li><li><a href="/study/vue_docs.html#自定义指令" class="sidebar-link">自定义指令</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/vue_docs.html#teleport" class="sidebar-link">teleport</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/vue_docs.html#渲染函数" class="sidebar-link">渲染函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/vue_docs.html#h函数" class="sidebar-link">h函数</a></li></ul></li><li><a href="/study/vue_docs.html#插件" class="sidebar-link">插件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/vue_docs.html#响应性" class="sidebar-link">响应性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/vue_docs.html#响应性原理" class="sidebar-link">响应性原理</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#具体过程" class="sidebar-link">具体过程</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#响应性基础" class="sidebar-link">响应性基础</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#计算值" class="sidebar-link">计算值</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#注意-2" class="sidebar-link">注意</a></li></ul></li><li><a href="/study/vue_docs.html#副作用" class="sidebar-link">副作用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/vue_docs.html#纯函数" class="sidebar-link">纯函数</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#watcheffect" class="sidebar-link">watchEffect</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#watch" class="sidebar-link">watch</a></li></ul></li><li><a href="/study/vue_docs.html#vue-2-中的更改检测" class="sidebar-link">Vue 2 中的更改检测</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/vue_docs.html#对于对象" class="sidebar-link">对于对象</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#对于数组" class="sidebar-link">对于数组</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#异步更新队列" class="sidebar-link">异步更新队列</a></li></ul></li><li><a href="/study/vue_docs.html#ts支持" class="sidebar-link">TS支持</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/vue_docs.html#与组合式-api-一起使用" class="sidebar-link">与组合式 API 一起使用</a></li></ul></li><li><a href="/study/vue_docs.html#代码风格" class="sidebar-link">代码风格</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/vue_docs.html#v-if-v-for" class="sidebar-link">v-if, v-for</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#组件样式作用域" class="sidebar-link">组件样式作用域</a></li></ul></li><li><a href="/study/vue_docs.html#配置选型" class="sidebar-link">配置选型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/vue_docs.html#emits" class="sidebar-link">emits</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#dom" class="sidebar-link">DOM</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#生命周期钩子-2" class="sidebar-link">生命周期钩子</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#mixins" class="sidebar-link">mixins</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#provide-inject-3" class="sidebar-link">provide / inject</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#setup-2" class="sidebar-link">setup</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#name" class="sidebar-link">name</a></li><li class="sidebar-sub-header"><a href="/study/vue_docs.html#inheritattrs" class="sidebar-link">inheritAttrs</a></li></ul></li><li><a href="/study/vue_docs.html#实例属性" class="sidebar-link">实例属性</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/vue_docs.html#实例方法" class="sidebar-link">实例方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/vue_docs.html#指令" class="sidebar-link">指令</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/vue_docs.html#特殊属性" class="sidebar-link">特殊属性</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/vue_docs.html#内置组件" class="sidebar-link">内置组件</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-文档学习笔记"><a href="#vue-文档学习笔记" class="header-anchor">#</a> Vue 文档学习笔记</h1> <h2 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h2> <ul><li>Vue 是一套用于构建用户界面的渐进式框架，自底向上逐层应用。一开始不需要你完全掌握它的全部功能特性，可以后续逐步增加功能。</li> <li>MVVM响应式编程模型，避免直接操作DOM , 降低DOM操作的复杂性。
<ul><li>V: 对应 View，原生的DOM，前端展示页面。</li> <li>M: 对应 Model，原生的JS 对象，即数据对象。</li> <li>VM: ViewModel, 用于双向绑定数据和页面，即 Vue 实例。</li></ul></li> <li>渐进式框架：用你想用或者能用的功能特性，你不想用的部分功能可以不用。各个功能都是独立的，也能按需进行整合：
<ul><li>Declartive Rendering: 声明式渲染，采用简洁的模板语法来声明式地将数据渲染进 DOM，仅作为 View 层的渲染工具。</li> <li>Component System: 代码组件化系统，单文件组件，用来提效、复用、抽象。</li> <li>Client-Side Routing: 客户端路由。</li> <li>Large Scale State Management: 大规模数据管理，构建大型项目。</li> <li>Build System: 构建系统。</li> <li>Server-Side Rendering: 支持服务端渲染。</li> <li>支持TS</li></ul></li></ul> <h2 id="计算属性-computed"><a href="#计算属性-computed" class="header-anchor">#</a> 计算属性（computed）</h2> <ul><li>对于任何包含响应式数据的复杂逻辑，你都应该使用计算属性。</li> <li>比如：<code>author.books.length &gt; 0 ? 'Yes' : 'No' }}</code>，如果模板中多次使用，用计算属性可以缓存数据，提升性能。</li> <li>跟方法不一样，<strong>计算属性</strong> 是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。如果<code>author.books</code>没有发生改变，计算属性会立即返回之前的计算结果，不需要再次执行函数。如果是调用方法，则每次都执行函数。</li> <li>下面的计算属性，不会再更新，因为不是响应式依赖。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>计算属性默认只有<code>getter</code>，可以根据需要提供<code>setter</code></li></ul> <h2 id="侦听器-watch"><a href="#侦听器-watch" class="header-anchor">#</a> 侦听器（watch）</h2> <ul><li>通过使用 <code>watch</code> 选项允许我们执行异步操作 (比如访问一个<code>API</code>)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li> <li>不要滥用<code>watch</code>，当需要一些数据随着其依赖的数据变动时，通常更好的做法是使用计算属性。</li></ul> <h2 id="class-与-style-绑定"><a href="#class-与-style-绑定" class="header-anchor">#</a> Class 与 Style 绑定</h2> <ul><li>对象语法：<code>:class=&quot;{ active: isActive, 'text-danger': hasError }&quot;</code></li> <li>通过计算属性达到一样的效果</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">classObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">active</span><span class="token operator">:</span> expression<span class="token punctuation">,</span>
      <span class="token string-property property">'text-danger'</span><span class="token operator">:</span> expression
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>数组语法:<code>&lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</code></li> <li>可以使用三元表达式: <code>&lt;div :class=&quot;[isActive ? activeClass : '', errorClass]&quot;&gt;&lt;/div&gt;</code></li> <li>在数组语法中也可以使用对象语法:<code>&lt;div :class=&quot;[{ active: isActive }, errorClass]&quot;&gt;&lt;/div&gt;</code></li> <li>内联样式支持对象语法：<code>&lt;div :style=&quot;{ color: activeColor, fontSize: fontSize + 'px' }&quot;&gt;&lt;/div&gt;</code></li> <li>内联样式支持数组语法：<code>&lt;div :style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;</code></li></ul> <h2 id="条件渲染"><a href="#条件渲染" class="header-anchor">#</a> 条件渲染</h2> <h3 id="v-show"><a href="#v-show" class="header-anchor">#</a> v-show</h3> <ul><li><code>v-show</code> 只是简单地切换元素的 <code>CSS property display</code>。</li> <li><code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>。</li></ul> <h3 id="v-show-对比-v-if"><a href="#v-show-对比-v-if" class="header-anchor">#</a> v-show 对比 v-if</h3> <ul><li><code>v-if</code>会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建。</li> <li>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</li></ul> <h3 id="v-if-与-v-for-一起使用"><a href="#v-if-与-v-for-一起使用" class="header-anchor">#</a> v-if 与 v-for 一起使用</h3> <ul><li>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-if</code>具有比 <code>v-for</code>更高的优先级。</li> <li><code>v-if</code> 将没有权限访问 <code>v-for</code> 里的变量。可以通过调整嵌套关系来实现。</li></ul> <h2 id="列表渲染"><a href="#列表渲染" class="header-anchor">#</a> 列表渲染</h2> <ul><li><code>v-for</code> 指令需要使用 <code>(item, index )in items</code>形式的特殊语法，也可以使用<code>item of items</code></li> <li>也可以用 <code>v-for</code> 来遍历一个对象的 <code>property</code>，第二个的参数为 property 名称 (也就是键名 key)，<code>(value, name) of myObject</code>。还支持第三个参数：索引：<code>(value, name, index) of myObject</code>。在遍历对象时，会按 <code>Object.keys()</code> 的结果遍历，但是不能保证它在不同 JavaScript 引擎下的结果都一致。</li></ul> <h3 id="数组更新检测"><a href="#数组更新检测" class="header-anchor">#</a> 数组更新检测</h3> <ul><li>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：
<ul><li><code>push()</code></li> <li><code>pop()</code></li> <li><code>shift()</code></li> <li><code>unshift()</code></li> <li><code>splice()</code></li> <li><code>sort()</code></li> <li><code>reverse()</code></li></ul></li> <li>替换数组。<code>filter()</code>、<code>concat()</code> 和 <code>slice()</code>。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组.</li></ul> <h2 id="事件处理"><a href="#事件处理" class="header-anchor">#</a> 事件处理</h2> <ul><li>监听事件：<code>v-on:click=&quot;methodName&quot;</code>或使用快捷方式 <code>@click=&quot;methodName&quot;</code></li> <li>如果在监听的事件方法的地方，不带参数，那么在方法定义的地方，默认参数就是 <code>event</code>对象。</li> <li>如果在监听的事件方法的地方，传了参数，默认不会传 <code>event</code>对象，需要显示传入<code>$event</code>关键字，例如：<code>&lt;button @click=&quot;say('what', $event)&quot;&gt;Say what&lt;/button&gt;</code></li> <li>绑定多个事件处理器：<code>&lt;button @click=&quot;one($event), two($event)&quot;&gt;Submit&lt;/button&gt;</code></li></ul> <h2 id="组件"><a href="#组件" class="header-anchor">#</a> 组件</h2> <h3 id="监听子组件事件"><a href="#监听子组件事件" class="header-anchor">#</a> 监听子组件事件</h3> <ul><li>父级组件可以像处理原生 DOM 事件一样通过 <code>v-on</code> 或 <code>@</code>监听子组件实例的任意事件：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 方式一 通过表达式处理, $event 获取子组件中的传参</span>
<span class="token operator">&lt;</span>child @doSomeThing<span class="token operator">=</span><span class="token string">&quot;$event + 1&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">&gt;</span>
<span class="token comment">// 方式二,调用在父组件中的方法`doItInParent`</span>
<span class="token operator">&lt;</span>child @doSomeThing<span class="token operator">=</span><span class="token string">&quot;doItInParent&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">&gt;</span>
</code></pre></div><ul><li>子组件中触发自定义事件</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 在组件的 emits 选项中列出已抛出的事件</span>
app<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'child'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">emits</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'doSomeThing'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 触发事件</span>
<span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">&quot;$emit('doSomeThing', 333)&quot;</span><span class="token operator">&gt;</span>触发事件<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>

<span class="token comment">//  在子组件的方法中触发</span>
<span class="token punctuation">{</span>
	<span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
		<span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'doSomeThing'</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="组件绑定-v-model"><a href="#组件绑定-v-model" class="header-anchor">#</a> 组件绑定 v-model</h3> <ul><li>将其 <code>value attribute</code> 绑定到一个名叫 <code>modelValue</code> 的 <code>prop</code> 上</li> <li>在其 组件 事件被触发时，将新的值通过自定义的 <code>update:modelValue</code> 事件抛出，以<code>input</code>组件为例</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>app<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'custom-input'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'modelValue'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token literal-property property">emits</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'update:modelValue'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    &lt;input
      :value=&quot;modelValue&quot;
      @input=&quot;$emit('update:modelValue', $event.target.value)&quot;
    &gt;
  </span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="动态子组件"><a href="#动态子组件" class="header-anchor">#</a> 动态子组件</h3> <ul><li>通过 <code>Vue</code> 的 <code>&lt;component&gt;</code> 元素加一个特殊的 <code>is attribute</code> 来实现。</li> <li>使用<code>keep-alive</code>来缓存组件，该模式下，多了生命周期<code>activated</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>component <span class="token operator">:</span>is<span class="token operator">=</span><span class="token string">&quot;currentTabComponent&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>component<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>
</code></pre></div><h4 id="keep-alive"><a href="#keep-alive" class="header-anchor">#</a> keep-alive</h4> <ul><li>页面第一次进入，生命周期顺序：<code>created -&gt; mounted -&gt; activated</code></li> <li>退出时，执行<code>deactivated</code>，再次进入时，只触发<code>activated</code></li></ul> <h3 id="异步组件"><a href="#异步组件" class="header-anchor">#</a> 异步组件</h3> <h4 id="vue-2-0"><a href="#vue-2-0" class="header-anchor">#</a> Vue 2.0</h4> <ul><li>方式一：接收一个<code>resolve</code>回调。或者通过 webpack 和 ES6 语法，动态导入</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'async-example'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 向 `resolve` 回调传递组件定义</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token string">'&lt;div&gt;I am async!&lt;/div&gt;'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'async-webpack-example'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这个特殊的 `require` 语法将会告诉 webpack</span>
  <span class="token comment">// 自动将你的构建代码切割成多个包，这些包</span>
  <span class="token comment">// 会通过 Ajax 请求加载</span>
  <span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./my-async-component'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> resolve<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  	<span class="token comment">// 动态导入，返回一个 Promise 对象</span>
    <span class="token string-property property">'my-component'</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./my-async-component'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>方式二：通过配置，功能会更加强大些。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">AsyncComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span>
  <span class="token literal-property property">component</span><span class="token operator">:</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./MyComponent.vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token comment">// 异步组件加载时使用的组件</span>
  <span class="token literal-property property">loading</span><span class="token operator">:</span> LoadingComponent<span class="token punctuation">,</span>
  <span class="token comment">// 加载失败时使用的组件</span>
  <span class="token literal-property property">error</span><span class="token operator">:</span> ErrorComponent<span class="token punctuation">,</span>
  <span class="token comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span>
  <span class="token literal-property property">delay</span><span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">,</span>
  <span class="token comment">// 如果提供了超时时间且组件加载也超时了，</span>
  <span class="token comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span>
  <span class="token literal-property property">timeout</span><span class="token operator">:</span> <span class="token number">3000</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string-property property">'my-component'</span><span class="token operator">:</span> AsyncComponent
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="vue-3-0"><a href="#vue-3-0" class="header-anchor">#</a> Vue 3.0</h4> <ul><li>Vue 3.0 中，需要调用<code>defineAsyncComponent</code>，它接受一个函数，改函数必须返回一个<code>Promise</code>，将组件<code>resolve</code>。或者通过<code>import</code>方式引入。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> createApp<span class="token punctuation">,</span> defineAsyncComponent <span class="token punctuation">}</span> <span class="token operator">=</span> Vue<span class="token punctuation">;</span>
<span class="token keyword">const</span> AsyncComp <span class="token operator">=</span> <span class="token function">defineAsyncComponent</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token string">'&lt;div&gt;I am async!&lt;/div&gt;'</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token keyword">const</span> AsyncComp <span class="token operator">=</span> <span class="token function">defineAsyncComponent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./components/AsyncComponent.vue'</span><span class="token punctuation">)</span> <span class="token comment">// 注意这里是直接 return import('component.vue')</span>
<span class="token punctuation">)</span>

</code></pre></div><ul><li>同样也可以通过配置方式实现，跟2.0相比，<code>component</code> 选项现在被重命名为 <code>loader</code>:</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> asyncPageWithOptions <span class="token operator">=</span> <span class="token function">defineAsyncComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">loader</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./NextPage.vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token literal-property property">delay</span><span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">,</span>
  <span class="token literal-property property">timeout</span><span class="token operator">:</span> <span class="token number">3000</span><span class="token punctuation">,</span>
  <span class="token literal-property property">errorComponent</span><span class="token operator">:</span> ErrorComponent<span class="token punctuation">,</span>
  <span class="token literal-property property">loadingComponent</span><span class="token operator">:</span> LoadingComponent
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="props"><a href="#props" class="header-anchor">#</a> props</h3> <ul><li>传入静态数组：<code>:data=&quot;[1,2,3]&quot;</code></li> <li>传入静态数字：<code>:num=&quot;333&quot;</code></li> <li>传入静态对象：<code>{name: &quot;hutaoer&quot;}</code></li> <li>如果想要将一个对象的所有 <code>property</code> 都作为 <code>prop</code> 传入，你可以使用不带参数的 <code>v-bind</code> (取代 <code>v-bind:prop-name</code>)。<code>v-bind=&quot;data&quot;</code></li> <li><code>prop</code> 会在一个组件实例创建之前进行验证，所以实例的 <code>property</code>，在属性校验的方法<code>validator()</code>，<code>default()</code>中不能使用。</li> <li>类型检查的类型包括：<code>String</code>,<code>Number</code>,<code>Boolean</code>,<code>Object</code>,<code>Symbol</code>,<code>Array</code>,<code>Date</code>,<code>Function</code>，此外也是可以使用自定义<code>class</code></li> <li>当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名.</li></ul> <h3 id="单向数据流"><a href="#单向数据流" class="header-anchor">#</a> 单向数据流</h3> <ul><li>每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。</li> <li>你不应该在一个子组件内部改变 prop。</li> <li>对象和数组是通过引用传入的，所以对于一个数组或对象类型的 <code>prop</code> 来说，在子组件中改变变更这个对象或数组本身将会影响到父组件的状态。</li></ul> <h3 id="attribute-继承"><a href="#attribute-继承" class="header-anchor">#</a> Attribute 继承</h3> <ul><li>当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。</li> <li>同样的规则也适用于事件监听器。</li> <li>如果不希望组件的根元素继承 attribute，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。</li></ul> <h2 id="插槽"><a href="#插槽" class="header-anchor">#</a> 插槽</h2> <ul><li><code>v-slot</code> 只能添加在 <code>&lt;template&gt;</code> 上，有一种情况例外：仅使用默认插槽时候。当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样我们就可以把 <code>v-slot</code> 直接用在组件上：</li> <li>作用域插槽：让插槽内容能够访问子组件中才有的数据。</li> <li>默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确。</li> <li>具名插槽的缩写：例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code>。该缩写只在其有参数的时候才可用。</li></ul> <h2 id="provide-inject"><a href="#provide-inject" class="header-anchor">#</a> Provide / Inject</h2> <ul><li>用来解决嵌套组件直接的数据传递问题。</li> <li>这个特性有两个部分：父组件有一个 <code>provide</code> 选项来提供数据，子组件有一个 <code>inject</code> 选项来开始使用这些数据。</li> <li>父组件不需要知道哪些子组件使用它 <code>provide 的 property</code></li> <li>子组件不需要知道 <code>inject</code> 的 <code>property</code> 来自哪里.</li> <li>要访问组件实例 <code>property</code>，我们需要将 <code>provide</code> 转换为返回对象的 <strong>函数</strong> ，即：<code>provide() {return {}}</code></li> <li>默认情况下，<code>provide/inject</code> 绑定并不是响应式的。如果我们想对祖先组件中的更改做出响应，我们需要为 <code>provide</code> 的<code>property</code>分配一个组合式 <code>API computed property</code>：<code>property:Vue.computed(() =&gt; {// return property value})</code></li></ul> <h2 id="过渡-动画"><a href="#过渡-动画" class="header-anchor">#</a> 过渡 &amp; 动画</h2> <ul><li>如果要对一个元素进行硬件加速，使用下面任何一个属性均可：
<ul><li><code>perspective: 1000px;</code></li> <li><code>backface-visibility: hidden;</code></li> <li><code>transform: translateZ(0);</code></li></ul></li></ul> <h2 id="组合式api"><a href="#组合式api" class="header-anchor">#</a> 组合式API</h2> <h3 id="setup"><a href="#setup" class="header-anchor">#</a> setup</h3> <ul><li>接收两个参数<code>(props, context)</code></li> <li>因为 <code>props</code> 是响应式的，你不能使用 <code>ES6</code> 解构，它会消除 <code>prop</code> 的响应性。如果需要解构 <code>prop</code>，可以在 <code>setup</code> 函数中使用 <code>toRefs</code> 函数来完成此操作。</li> <li><code>context</code> 是一个普通的 JavaScript 对象，它暴露组件的三个 <code>property：attrs, slots, emit</code></li> <li>执行<code>setup</code>时候，组件实例还未创建。只能访问：<code>props, attrs, slots, emit</code>，不能访问<code>data, computed, methods</code>.</li> <li>如果 <code>setup</code> 返回一个对象，那么该对象的 <code>property</code> 以及传递给 <code>setup</code> 的 <code>props</code> 参数中的 <code>property</code> 就都可以在模板中访问到。<code>props</code>不需要再从<code>setup</code>中<code>return</code>出去。</li> <li>从 <code>setup</code> 返回的 <code>refs</code> 在<code>模板</code>中访问时是被<code>自动浅解包</code>的，不需要在模板中使用 <code>.value</code>。</li> <li><code>setup</code> 还可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态，会覆盖掉<code>template</code>中的内容。</li> <li><code>setup</code> 中的<code>this</code>不是指向当前组件实例，不能同选项式<code>API</code>混用。</li></ul> <h3 id="生命周期钩子"><a href="#生命周期钩子" class="header-anchor">#</a> 生命周期钩子</h3> <ul><li>选项式API: <code>beforeCreate</code>,<code>created</code>,<code>beforeMount</code>,<code>mounted</code>,<code>beforeUpdate</code>,<code>updated</code>,<code>beforeUnmount</code>,<code>unmounted</code>。</li> <li><code>onBeforeMount</code>,<code>onMounted</code>,<code>onBeforeUpdate</code>,<code>onUpdated</code>,<code>onBeforeUnmount</code>,<code>onUnMounted</code>，<code>setup</code>是围绕<code>beforeCreate</code>和<code>created</code>生命周期钩子运行的，所以不需要显示定义它们。</li></ul> <h3 id="provide-inject-2"><a href="#provide-inject-2" class="header-anchor">#</a> provide / inject</h3> <ul><li><code>setup</code>中使用<code>provide/inject</code>都需要显示导入。</li> <li>使用字面量：<code>provide('key', 'string')</code>, <code>inject('key')</code></li> <li>使用响应式对象：<code>provide('key', ref('string'))</code>，<code>provide('key', reactive({}))</code></li> <li>当使用响应式 <code>provide / inject</code> 值时，建议尽可能将对响应式 <code>property</code> 的所有修改限制在定义 <code>provide</code> 的组件内部。</li> <li>需要在注入数据的组件内部更新 inject 的数据。在这种情况下，我们建议 provide 一个方法来负责改变响应式 property。</li> <li>如果要确保通过 <code>provide</code> 传递的数据不会被 <code>inject</code> 的组件更改，我们建议对提供者的 <code>property</code> 使用 <code>readonly</code>，比如：<code>provide('key', readonly(reactiveData))</code></li></ul> <h3 id="mixin"><a href="#mixin" class="header-anchor">#</a> mixin</h3> <ul><li>Vue 2 中，mixin是组件逻辑抽象的主要工具。</li> <li>但它存在一些缺点：1. 容易产生冲突；2. 复用性有限，不能向 mixin 传递任何参数来改变它的逻辑。</li> <li>Vue 3 中，使用组合式API来代替 mixin</li></ul> <h3 id="注意"><a href="#注意" class="header-anchor">#</a> 注意</h3> <ul><li>在 setup 中你应该避免使用 this，因为它不会找到组件实例。setup 的调用发生在 data property、computed property 或 methods 被解析之前，所以它们无法在 setup 中被获取。</li></ul> <h2 id="自定义指令"><a href="#自定义指令" class="header-anchor">#</a> 自定义指令</h2> <ul><li>自定义指令总是会被应用在组件的根节点上。</li></ul> <h2 id="teleport"><a href="#teleport" class="header-anchor">#</a> teleport</h2> <ul><li>允许我们控制在 DOM 中哪个父节点下渲染了 HTML，而不必求助于全局状态或将其拆分为两个组件。</li> <li><code>&lt;teleport to=&quot;body&quot;&gt;&lt;/teleport&gt;</code>，渲染到<code>body</code>标签。</li> <li>如果<code>teleport</code>中存在Vue子组件，虽然在DOM节点中，可能不是父子关系，但子组件在 <code>Vue Devtools</code> 中的，仍然在父组件之下，而不是放在实际内容移动到的位置。父子组件之间的通信没有变化。</li> <li>如果有多个<code>teleport</code>都挂载到同一个DOM节点，那么其顺序将是一个简单的追加——稍后挂载将位于目标元素中较早的挂载之后，跟组件在模板中出现的顺序保持一致。</li></ul> <h2 id="渲染函数"><a href="#渲染函数" class="header-anchor">#</a> 渲染函数</h2> <ul><li>DOM树：每个元素都是一个节点。每段文字也是一个节点。甚至注释也都是节点。一个节点就是页面的一个部分。</li> <li>虚拟节点，简称为<code>VNode</code>, 虚拟DOM是我们对由 Vue 组件树建立起来的整个 <code>VNode</code> 树的称呼。</li></ul> <h3 id="h函数"><a href="#h函数" class="header-anchor">#</a> h函数</h3> <ul><li>用于创建<code>VNode</code>，接受三个参数：
<ul><li><code>{String | Object | Function} tag</code>，一个HTML标签名，一个组件，一个异步组件或一个函数式组件。必须的。</li> <li><code>{Object} props</code>,与 attribute、prop 和事件相对应的对象。可选的。</li> <li><code>{String | Array | Object} children</code>，子 <code>VNodes</code>，可选的。</li></ul></li> <li>如果没有 <code>prop</code>，那么通常可以将 <code>children</code> 作为第二个参数传入。如果会产生歧义，可以将 <code>null</code> 作为第二个参数传入，将 <code>children</code> 作为第三个参数传入。</li> <li>要为某个组件创建一个 <code>VNode</code>，传递给 <code>h</code> 的第一个参数应该是组件本身。</li> <li><code>&lt;template&gt;</code>的优先级高于<code>render</code>函数。</li> <li>模板使用 <code>resolveDynamicComponent</code> 来实现 <code>is attribute</code></li> <li>诸如 <code>&lt;keep-alive&gt;、&lt;transition&gt;、&lt;transition-group&gt; 和 &lt;teleport&gt;</code>等内置组件默认并没有被全局注册。这使得打包工具可以 <code>tree-shake</code>，因此这些组件只会在被用到的时候被引入构建。</li> <li>Vue 的模板实际上被编译成了渲染函数。</li></ul> <h2 id="插件"><a href="#插件" class="header-anchor">#</a> 插件</h2> <ul><li>插件是自包含的代码，通常向 Vue 添加全局级功能。它可以是公开 <code>install()</code> 方法的对象，也可以是 <code>function</code>.</li></ul> <h2 id="响应性"><a href="#响应性" class="header-anchor">#</a> 响应性</h2> <h3 id="响应性原理"><a href="#响应性原理" class="header-anchor">#</a> 响应性原理</h3> <ul><li>Vue 3 使用<code>Proxy</code>来实现，在<code>get</code>的时候，添加<code>track</code>函数，来追踪依赖；在<code>set</code>的是时候，添加了<code>trigger</code>，触发依赖。</li> <li><code>Proxy</code> 是一个对象，它包装了另一个对象，并允许你拦截对该对象的任何交互。ES6 引入了另一个名为 <code>Reflect</code> 的新特性。</li> <li><code>Proxy</code> 实现响应性的第一步就是跟踪一个 <code>property</code> 何时被读取。我们在一个名为 <code>track</code>的处理器函数中执行此操作，该函数可以传入 <code>target</code> 和 <code>property</code> 两个参数。它将检查当前运行的是哪个副作用，并将其与 target 和 property 记录在一起。这就是 Vue 如何知道这个 <code>property</code> 是该副作用的依赖项。</li> <li>需要在 <code>property</code> 值更改时重新运行这个副作用。<code>trigger(target, property)</code></li></ul> <h3 id="具体过程"><a href="#具体过程" class="header-anchor">#</a> 具体过程</h3> <ul><li>当一个值被读取时进行追踪：proxy 的 get 处理函数中 track 函数记录了该 property 和当前副作用。</li> <li>当某个值改变时进行检测：在 proxy 上调用 set 处理函数。</li> <li>重新运行代码来读取原始值：trigger 函数查找哪些副作用依赖于该 property 并执行它们。</li> <li>如果这些 property 中的任何一个随后发生了变化，它将触发副作用再次运行，重新运行 <code>render</code> 函数以生成新的 <code>VNodes</code>。</li></ul> <h3 id="响应性基础"><a href="#响应性基础" class="header-anchor">#</a> 响应性基础</h3> <ul><li>为对象创建响应式状态，可以使用 <code>reactive</code> 方法。当从组件中的 <code>data()</code> 返回一个对象时，它在内部交由 <code>reactive()</code> 使其成为响应式对象。</li> <li>把值类型数据变成响应式，可以使用<code>ref</code>。</li> <li><code>ref</code>解包：当 <code>ref</code> 作为渲染上下文 (从 setup() 中返回的对象) 上的 <code>property</code> 返回并可以在模板中被访问时，它将自动浅层次解包内部值。不需要再通过<code>.value</code>的方式去访问。只有访问嵌套的<code>ref</code>时，需要在模板中使用<code>.value</code>访问。<code>Ref</code> 解包仅发生在被响应式 <code>Object</code> 嵌套的时候。当从<code>Array</code>或原生集合类型如 <code>Map</code>访问 <code>ref</code>时，不会进行解包。</li> <li>当 <code>ref</code> 作为响应式对象的 <code>property</code>被访问或更改时，为使其行为类似于普通 <code>property</code>，它会自动解包内部值。</li> <li>如果将新的 <code>ref</code> 赋值给现有 <code>ref</code> 的 <code>property</code>，将会替换旧的 <code>ref</code>.</li> <li>结构一个<code>reactive</code>创建的对象：<code>const info = reactive({name:'hutaoer'})</code>，会丢失响应性。可以使用<code>toRefs</code>转为<code>ref</code>，这样就可以保留与源对象的响应式关联:<code>let {name} = toRefs(info)</code>,<code>name.value='yilin'</code></li></ul> <h3 id="计算值"><a href="#计算值" class="header-anchor">#</a> 计算值</h3> <ul><li><code>computed</code>方法，有两种方式：1. 一个参数的时候，默认为getter函数，并返回一个不可变的响应式<code>ref</code>对象；2. 接受一个带有<code>get</code>和<code>set</code>函数的对象，返回一个可写的<code>ref</code>对象。</li></ul> <h3 id="注意-2"><a href="#注意-2" class="header-anchor">#</a> 注意</h3> <ul><li>被代理对象与原始对象不相等</li> <li>最佳实践是永远不要持有对原始对象的引用，而只使用响应式版本。</li> <li>Vue 的 计算属性 (computed) 中应当仅包含用于返回值的计算，不应该包含 DOM操作，修改外部变量，异步操作 等。这些操作应该在 侦听器 (watch) 中实现。否则会提示<code>Unexpected side effect in “...“ computed property</code></li></ul> <h2 id="副作用"><a href="#副作用" class="header-anchor">#</a> 副作用</h2> <h3 id="纯函数"><a href="#纯函数" class="header-anchor">#</a> 纯函数</h3> <ul><li>纯函数需要满足以下条件：1.它应始终返回相同的值。2.它不应修改程序的状态或引起副作用。</li> <li>纯函数中的副作用（side effect）就是如果有一个函数在输入和输出之外还做了其他的事情，那么这个函数额外做的事情就被称为副作用。</li></ul> <h3 id="watcheffect"><a href="#watcheffect" class="header-anchor">#</a> watchEffect</h3> <ul><li><code>Vue3</code>中的<code>watchEffect</code>函数的<code>onInvalidate</code>方法就是用来清除副作用的。清除副作用实际上是Vue3提供给用户的一种取消异步副作用的实现方法。</li> <li><code>onInvalidate</code>只作用于异步函数，并且只有在如下两种情况下才会被调用：1. <code>effect</code>重新调用时；2.监听器被注销，比如组件被卸载。</li> <li>如果希望副作用函数在组件更新后发生，可以将<code>flush</code>设为<code>post</code>（默认是<code>pre</code>）</li> <li>与<code>watch</code>区别：
-（1）不需要手动传入依赖
-（2）每次初始化时会执行一次回调函数来自动获取依赖
-（3）无法获取到原值，只能得到变化后的值</li> <li><code>onTrack</code> 和 <code>onTrigger</code> 只能在开发模式下工作。</li></ul> <h3 id="watch"><a href="#watch" class="header-anchor">#</a> watch</h3> <ul><li><code>watch</code> 需要侦听特定的数据源，并在回调函数中执行副作用。</li> <li>默认情况下，它也是惰性的，即只有当被侦听的源发生变化时才执行回调。</li> <li>同<code>watchEffect</code>区别：
<ul><li>懒执行副作用；</li> <li>更具体地说明什么状态应该触发侦听器重新运行；</li> <li>访问侦听状态变化前后的值。</li></ul></li> <li>检查深度嵌套对象或数组中的 <code>property</code> 变化时，仍然需要 <code>deep</code> 选项设置为 <code>true</code>。</li></ul> <h2 id="vue-2-中的更改检测"><a href="#vue-2-中的更改检测" class="header-anchor">#</a> Vue 2 中的更改检测</h2> <h3 id="对于对象"><a href="#对于对象" class="header-anchor">#</a> 对于对象</h3> <ul><li>Vue 无法检测到 property 的添加或删除。</li> <li>Vue 不允许动态添加 <strong>根级别</strong> 的响应式 property。
<ul><li>可以使用 <code>Vue.set(object, propertyName, value)</code> 方法向 <strong>嵌套对象</strong> 添加响应式 <code>property</code></li> <li>也可以使用<code>vm.$set 实例方法，这也是全局 Vue.set 方法的别名</code></li></ul></li> <li>为已有对象赋值多个新 property，比如使用 <code>Object.assign()</code> 或 <code>_.extend()</code>。但是，这样添加到对象上的新 <code>property</code> 不会触发更新。应该用原对象与要混合进去的对象的 property 一起创建一个新的对象。<code>this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })</code></li></ul> <h3 id="对于数组"><a href="#对于数组" class="header-anchor">#</a> 对于数组</h3> <ul><li>Vue 不能检测以下数组的变动：1. 直接通过索引设置元素；2.修改数组长度。</li> <li>解决方法：
<ul><li>全局方法：<code>Vue.set(vm.items, indexOfItem, newValue)</code></li> <li>实例方法：<code>vm.$set(vm.items, indexOfItem, newValue)</code></li> <li>通过<code>splice</code>，<code>vm.items.splice(indexOfItem, 1, newValue)</code></li></ul></li></ul> <h3 id="异步更新队列"><a href="#异步更新队列" class="header-anchor">#</a> 异步更新队列</h3> <ul><li>只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个侦听器被多次触发，它只会被推入到队列中一次。</li> <li>在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then、MutationObserver 和 setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</li></ul> <h2 id="ts支持"><a href="#ts支持" class="header-anchor">#</a> TS支持</h2> <ul><li>要让 <code>TypeScript</code> 正确推断 <code>Vue</code> 组件选项中的类型，需要使用 <code>defineComponent</code> 全局方法定义组件。</li> <li>推荐配置</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// tsconfig.json</span>
<span class="token punctuation">{</span>
  <span class="token string-property property">&quot;compilerOptions&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string-property property">&quot;target&quot;</span><span class="token operator">:</span> <span class="token string">&quot;esnext&quot;</span><span class="token punctuation">,</span>
    <span class="token string-property property">&quot;module&quot;</span><span class="token operator">:</span> <span class="token string">&quot;esnext&quot;</span><span class="token punctuation">,</span>
    <span class="token comment">// 这样就可以对 `this` 上的数据属性进行更严格的推断</span>
    <span class="token string-property property">&quot;strict&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token string-property property">&quot;jsx&quot;</span><span class="token operator">:</span> <span class="token string">&quot;preserve&quot;</span><span class="token punctuation">,</span>
    <span class="token string-property property">&quot;moduleResolution&quot;</span><span class="token operator">:</span> <span class="token string">&quot;node&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="与组合式-api-一起使用"><a href="#与组合式-api-一起使用" class="header-anchor">#</a> 与组合式 API 一起使用</h3> <ul><li>在 <code>setup()</code> 函数中，不需要将类型传递给 <code>props</code> 参数，因为它将从 <code>props</code> 组件选项推断类型。</li></ul> <h4 id="类型声明-reactive"><a href="#类型声明-reactive" class="header-anchor">#</a> 类型声明 <code>reactive</code></h4> <ul><li>三种创建方式</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">Book</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">title</span><span class="token operator">:</span> string
	price<span class="token operator">?</span><span class="token operator">:</span> number
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
	<span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">const</span> book <span class="token operator">=</span> reactive<span class="token operator">&lt;</span>Book<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'Vue'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
		<span class="token keyword">const</span> <span class="token literal-property property">book</span><span class="token operator">:</span>Book <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'Vue'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
		<span class="token keyword">const</span> book <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'Vue'</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">as</span> Book
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="类型声明-computed"><a href="#类型声明-computed" class="header-anchor">#</a> 类型声明 computed</h4> <ul><li>计算值将根据返回值自动推断类型</li></ul> <h4 id="为事件处理器添加类型"><a href="#为事件处理器添加类型" class="header-anchor">#</a> 为事件处理器添加类型</h4> <ul><li>添加事件类型注解</li> <li>断言 <code>target</code>为 html 标签元素。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">handleEvent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">evnt</span><span class="token operator">:</span> Event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>target <span class="token keyword">as</span> HTMLInputElement<span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="代码风格"><a href="#代码风格" class="header-anchor">#</a> 代码风格</h2> <ul><li>组件名为多个单词。</li> <li>prop 的定义应该尽量详细，至少指定其类型。</li> <li>单文件组件的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 JS(X) 和模板中引用组件的方式尽可能地一致。例如：<code>components/MyComponent.vue</code> 或者<code>components/my-component.vue</code></li> <li></li></ul> <h3 id="v-if-v-for"><a href="#v-if-v-for" class="header-anchor">#</a> v-if, v-for</h3> <ul><li>在 vue 2.x 中，在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用。</li> <li>在 vue 3.x 中，v-if 总是优先于 v-for 生效。</li></ul> <h3 id="组件样式作用域"><a href="#组件样式作用域" class="header-anchor">#</a> 组件样式作用域</h3> <ul><li>对于单文件组件，推荐<code>scoped css</code>，作用域也可以通过 CSS Modules (一个基于 class 的，类似 BEM 的策略) 或者其它的库/约定来实现。</li> <li>对于组件库来说，我们应该更倾向于选用基于 class 的策略，而不是 scoped attribute。</li> <li>覆写内部样式变得更容易。</li></ul> <h2 id="配置选型"><a href="#配置选型" class="header-anchor">#</a> 配置选型</h2> <h3 id="emits"><a href="#emits" class="header-anchor">#</a> emits</h3> <ul><li><code>emits</code> 选项中列出的事件不会从组件的根元素继承，也将从 <code>$attrs property</code> 中移除。</li></ul> <h3 id="dom"><a href="#dom" class="header-anchor">#</a> DOM</h3> <ul><li>如果 Vue 选项中包含渲染函数，模板将被忽略。</li> <li><code>render</code> 函数的优先级高于根据 <code>template</code> 选项或挂载元素的 <code>DOM</code> 内 <code>HTML</code> 模板编译的渲染函数。</li></ul> <h3 id="生命周期钩子-2"><a href="#生命周期钩子-2" class="header-anchor">#</a> 生命周期钩子</h3> <ul><li>所有生命周期钩子的 this 上下文将自动绑定至实例中，因此你可以访问 <code>data、computed 和 methods</code>。</li> <li>这意味着你不应该使用箭头函数来定义一个生命周期方法。</li> <li><code>beforeCreate</code>: 实例初始化之后，进行数据侦听和事件/侦听器的配置之前同步调用。</li> <li><code>created</code>: 实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。挂载还未开始，<code>$el</code>不可使用。</li> <li><code>beforeMount</code>: <code>render</code>函数首次被调用，在SSR的时候不能使用。</li> <li><code>mounted</code>: 实例挂载完成，但不会保证所有子组件挂载完成。如果你希望等待整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <code>vm.$nextTick</code>。SSR期间不可用。</li> <li><code>beforeUpdate</code>: 在数据发生改变后，DOM 被更新之前被调用。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。</li> <li><code>updated</code>: 在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。<code>updated</code> 不会保证所有的子组件也都被重新渲染完毕。如果你希望等待整个视图都渲染完毕，可以在 <code>updated</code> 内部使用 <code>vm.$nextTick</code>。该钩子在SSR期间不被调用。</li> <li><code>activated</code>: <code>keep-alive</code>缓存的组件激活时候调用。SSR不可用。</li> <li><code>deactivated</code>: 被 <code>keep-alive</code> 缓存的组件失活时调用。SSR不可用。</li> <li><code>beforeUnmount</code>: 卸载组件实例前调用。SSR不可用。</li> <li><code>unmounted</code>: 卸载组件实例后调用。调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。SSR不可用。</li> <li><code>errorCaptured</code>: 捕获一个来自后代的错误时被调用。</li> <li><code>renderTracked</code>: 跟踪虚拟DOM重新渲染时候调用。</li> <li><code>renderTriggered</code>: 虚拟DOM重新渲染被触发时调用。</li></ul> <h3 id="mixins"><a href="#mixins" class="header-anchor">#</a> mixins</h3> <ul><li>可定义多个<code>mixin</code>, 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</li> <li><code>const mixin = {created() {}}</code></li> <li><code>{mixins: [mixin]</code></li></ul> <h3 id="provide-inject-3"><a href="#provide-inject-3" class="header-anchor">#</a> provide / inject</h3> <ul><li>跟<code>React</code>的<code>context</code>类似。</li></ul> <h3 id="setup-2"><a href="#setup-2" class="header-anchor">#</a> setup</h3> <ul><li>它是组件内部使用组合式 API 的入口点。</li> <li>在创建组件实例时，在初始 <code>prop</code> 解析之后立即调用 <code>setup</code>。在生命周期方面，它是在 <code>beforeCreate</code> 钩子之前调用的。</li> <li>从 <code>setup</code> 返回的 <code>refs</code> 在模板中访问时会自动解包，因此模板中不需要 <code>.value</code>。</li> <li><code>setup</code> 还可以返回一个渲染函数.</li> <li><code>setup</code> 的第一个参数是 <code>props</code>,此 <code>props</code> 对象是响应式的。在传入新的 <code>props</code> 时会对其进行更新。不要解构 <code>props</code> 对象，因为它会失去响应式.</li></ul> <h3 id="name"><a href="#name" class="header-anchor">#</a> name</h3> <ul><li>设置组件名称，便于调试。</li></ul> <h3 id="inheritattrs"><a href="#inheritattrs" class="header-anchor">#</a> inheritAttrs</h3> <ul><li>默认值为true。默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。</li> <li>通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过实例 property $attrs 可以让这些 attribute 生效，且可以通过 v-bind 显性的绑定到非根元素上。</li></ul> <h2 id="实例属性"><a href="#实例属性" class="header-anchor">#</a> 实例属性</h2> <ul><li><code>$data</code>: 组件实例监听的数据对象。</li> <li><code>$props</code>: 组件接收的<code>props</code>对象。</li> <li><code>$el</code>:实例正在使用的根 DOM 元素。</li></ul> <h2 id="实例方法"><a href="#实例方法" class="header-anchor">#</a> 实例方法</h2> <ul><li><code>$watch</code> <ul><li>当侦听的值是一个对象或者数组时，对其属性或元素的任何更改都不会触发侦听器，因为它们引用相同的对象/数组。</li> <li><code>$watch</code> 返回一个取消侦听函数，用来停止触发回调。</li> <li>选项：<code>deep</code>，为了发现对象内部值的变化。</li> <li>选项：<code>immediate</code>，指定 <code>immediate: true</code> 将立即以表达式的当前值触发回调。</li> <li>选项：<code>flush</code>。默认值是 <code>pre</code>，指定的回调应该在渲染前被调用。</li></ul></li> <li>$forceUpdate: 迫使组件实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件.</li> <li>$nextTick: 它跟全局方法 <code>nextTick</code> 一样，不同的是回调中的 <code>this</code> 自动绑定到调用它的实例上。</li></ul> <h2 id="指令"><a href="#指令" class="header-anchor">#</a> 指令</h2> <ul><li>v-memo：通常用于长列表优化。该指令接收一个固定长度的数组作为依赖值进行记忆比对。如果数组中的每个值都和上次渲染的时候相同，则整个该子树的更新会被跳过。在 v-for 中使用 v-memo 时，确保它们被用在了同一个元素上。 v-memo 在 v-for 内部是无效的。</li></ul> <h2 id="特殊属性"><a href="#特殊属性" class="header-anchor">#</a> 特殊属性</h2> <ul><li><code>key</code>: 有相同父元素的子元素必须有唯一的 <code>key</code>。它也可以用于强制替换元素/组件而不是重复使用它。</li> <li><code>ref</code>: <code>ref</code> 被用来给元素或子组件注册引用信息。引用信息将会被注册在父组件的 <code>$refs</code> 对象上。</li> <li><code>is</code>: 有的时候你可能需要 Vue 将一个原生元素替换为一个 Vue 组件。这是你可以把 is attribute 的值加上 vue: 前缀，这样 Vue 就会将这些元素换为 Vue 组件进行渲染。</li></ul> <h2 id="内置组件"><a href="#内置组件" class="header-anchor">#</a> 内置组件</h2> <ul><li>可以直接在模板中使用，不需要注册。</li> <li><code>&lt;keep-alive&gt;、&lt;transition&gt;、&lt;transition-group&gt; 和 &lt;teleport&gt;</code> 组件都可以被打包工具 <code>tree-shake</code>。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.4220ef43.js" defer></script><script src="/assets/js/2.07f3c95d.js" defer></script><script src="/assets/js/80.4c5877fb.js" defer></script>
  </body>
</html>
