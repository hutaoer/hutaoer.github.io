<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React 学习笔记 | 逗逼码农</title>
    <meta name="generator" content="VuePress 1.9.9">
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?97584138af9a81f074d821256641e300";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    <meta name="description" content="持续提升，降低欲望；乐观幽默，自律坦然">
    
    <link rel="preload" href="/assets/css/0.styles.e8e4f3a3.css" as="style"><link rel="preload" href="/assets/js/app.b5b43a0f.js" as="script"><link rel="preload" href="/assets/js/2.07f3c95d.js" as="script"><link rel="preload" href="/assets/js/63.938854e9.js" as="script"><link rel="prefetch" href="/assets/js/10.cc8be56c.js"><link rel="prefetch" href="/assets/js/11.964e61e9.js"><link rel="prefetch" href="/assets/js/12.2db488c0.js"><link rel="prefetch" href="/assets/js/13.6a126940.js"><link rel="prefetch" href="/assets/js/14.93311436.js"><link rel="prefetch" href="/assets/js/15.1986a410.js"><link rel="prefetch" href="/assets/js/16.35a4ab2c.js"><link rel="prefetch" href="/assets/js/17.e19e45d7.js"><link rel="prefetch" href="/assets/js/18.490b3aaf.js"><link rel="prefetch" href="/assets/js/19.dfe7fb03.js"><link rel="prefetch" href="/assets/js/20.210a2b68.js"><link rel="prefetch" href="/assets/js/21.b3f82ddd.js"><link rel="prefetch" href="/assets/js/22.6bc8ecc5.js"><link rel="prefetch" href="/assets/js/23.5e900a48.js"><link rel="prefetch" href="/assets/js/24.964cdc7b.js"><link rel="prefetch" href="/assets/js/25.7e0a3e21.js"><link rel="prefetch" href="/assets/js/26.3a64a95c.js"><link rel="prefetch" href="/assets/js/27.50ff19b8.js"><link rel="prefetch" href="/assets/js/28.c5dbf5e6.js"><link rel="prefetch" href="/assets/js/29.0eaf37b1.js"><link rel="prefetch" href="/assets/js/3.b2c2ff72.js"><link rel="prefetch" href="/assets/js/30.ce35c05e.js"><link rel="prefetch" href="/assets/js/31.11c548de.js"><link rel="prefetch" href="/assets/js/32.c57de1dd.js"><link rel="prefetch" href="/assets/js/33.d0dfe65a.js"><link rel="prefetch" href="/assets/js/34.43af99a2.js"><link rel="prefetch" href="/assets/js/35.5a05790b.js"><link rel="prefetch" href="/assets/js/36.e0cc4fea.js"><link rel="prefetch" href="/assets/js/37.7ab4f2df.js"><link rel="prefetch" href="/assets/js/38.ec48e86e.js"><link rel="prefetch" href="/assets/js/39.8db78b56.js"><link rel="prefetch" href="/assets/js/4.045757b5.js"><link rel="prefetch" href="/assets/js/40.40133055.js"><link rel="prefetch" href="/assets/js/41.eb8d5db2.js"><link rel="prefetch" href="/assets/js/42.91dce640.js"><link rel="prefetch" href="/assets/js/43.57461f97.js"><link rel="prefetch" href="/assets/js/44.e7a28a38.js"><link rel="prefetch" href="/assets/js/45.91a7ef55.js"><link rel="prefetch" href="/assets/js/46.33a34e1d.js"><link rel="prefetch" href="/assets/js/47.77395e8c.js"><link rel="prefetch" href="/assets/js/48.2a55a575.js"><link rel="prefetch" href="/assets/js/49.dd28827f.js"><link rel="prefetch" href="/assets/js/5.d2f3d5f9.js"><link rel="prefetch" href="/assets/js/50.26a6c055.js"><link rel="prefetch" href="/assets/js/51.ab73c5ca.js"><link rel="prefetch" href="/assets/js/52.9fb2291c.js"><link rel="prefetch" href="/assets/js/53.c70e55b2.js"><link rel="prefetch" href="/assets/js/54.493f5634.js"><link rel="prefetch" href="/assets/js/55.e39e8e59.js"><link rel="prefetch" href="/assets/js/56.54715536.js"><link rel="prefetch" href="/assets/js/57.5647a84d.js"><link rel="prefetch" href="/assets/js/58.fa695c1f.js"><link rel="prefetch" href="/assets/js/59.3ea1b96a.js"><link rel="prefetch" href="/assets/js/6.dbf9f127.js"><link rel="prefetch" href="/assets/js/60.2c9cba66.js"><link rel="prefetch" href="/assets/js/61.e66377dd.js"><link rel="prefetch" href="/assets/js/62.d642e466.js"><link rel="prefetch" href="/assets/js/64.06d21c86.js"><link rel="prefetch" href="/assets/js/65.dea57da7.js"><link rel="prefetch" href="/assets/js/66.e52a3ab7.js"><link rel="prefetch" href="/assets/js/67.791b9007.js"><link rel="prefetch" href="/assets/js/68.40b8974d.js"><link rel="prefetch" href="/assets/js/69.260249dd.js"><link rel="prefetch" href="/assets/js/7.8730244f.js"><link rel="prefetch" href="/assets/js/70.d7722a4f.js"><link rel="prefetch" href="/assets/js/71.91f62fed.js"><link rel="prefetch" href="/assets/js/72.8b7a46b4.js"><link rel="prefetch" href="/assets/js/73.8aeb5c37.js"><link rel="prefetch" href="/assets/js/74.d56e832b.js"><link rel="prefetch" href="/assets/js/75.f92bf234.js"><link rel="prefetch" href="/assets/js/76.b5c32f3e.js"><link rel="prefetch" href="/assets/js/77.c2374faa.js"><link rel="prefetch" href="/assets/js/78.7e81fe3e.js"><link rel="prefetch" href="/assets/js/79.070ed08f.js"><link rel="prefetch" href="/assets/js/8.ad10c1b9.js"><link rel="prefetch" href="/assets/js/80.4f210acc.js"><link rel="prefetch" href="/assets/js/81.817183f6.js"><link rel="prefetch" href="/assets/js/82.976a71ff.js"><link rel="prefetch" href="/assets/js/83.288d3c86.js"><link rel="prefetch" href="/assets/js/84.8745dd19.js"><link rel="prefetch" href="/assets/js/85.301ba501.js"><link rel="prefetch" href="/assets/js/9.a36b3496.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e8e4f3a3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">逗逼码农</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://www.cnblogs.com/hutaoer/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  旧的博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/hutaoer" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://www.cnblogs.com/hutaoer/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  旧的博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/hutaoer" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React 学习笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/react.html#设计思想" class="sidebar-link">设计思想</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/react.html#版本更新" class="sidebar-link">版本更新</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/react.html#基础" class="sidebar-link">基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/react.html#对比-vue" class="sidebar-link">对比 Vue</a></li><li class="sidebar-sub-header"><a href="/study/react.html#生命周期" class="sidebar-link">生命周期</a></li><li class="sidebar-sub-header"><a href="/study/react.html#数据-state" class="sidebar-link">数据 State</a></li><li class="sidebar-sub-header"><a href="/study/react.html#组件" class="sidebar-link">组件</a></li><li class="sidebar-sub-header"><a href="/study/react.html#合成事件" class="sidebar-link">合成事件</a></li><li class="sidebar-sub-header"><a href="/study/react.html#表单" class="sidebar-link">表单</a></li><li class="sidebar-sub-header"><a href="/study/react.html#组合、继承" class="sidebar-link">组合、继承</a></li></ul></li><li><a href="/study/react.html#高级部分" class="sidebar-link">高级部分</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/react.html#代码分割" class="sidebar-link">代码分割</a></li><li class="sidebar-sub-header"><a href="/study/react.html#context" class="sidebar-link">Context</a></li><li class="sidebar-sub-header"><a href="/study/react.html#高阶组件" class="sidebar-link">高阶组件</a></li></ul></li><li><a href="/study/react.html#api" class="sidebar-link">API</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/react.html#createelement" class="sidebar-link">createElement</a></li></ul></li><li><a href="/study/react.html#concurrent-模式" class="sidebar-link">Concurrent 模式</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react-学习笔记"><a href="#react-学习笔记" class="header-anchor">#</a> React 学习笔记</h1> <ul><li><code>React</code>是一个用于构建用户界面的 JS 库，相当于 <code>MVC</code> 中的<code>View</code>层。</li></ul> <h2 id="设计思想"><a href="#设计思想" class="header-anchor">#</a> 设计思想</h2> <ul><li>React 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递。尽管如此，但这种需要显式声明的方法更有助于人们理解程序的运作方式。</li> <li>state 只能由拥有它们的组件进行更改。</li></ul> <h2 id="版本更新"><a href="#版本更新" class="header-anchor">#</a> 版本更新</h2> <ul><li>React 16</li> <li>React 17，没有添加任何面向开发人员的新功能，简化React自身的一次升级。
<ul><li>去除事件池。</li> <li>事件代理更改。在React 16和更早的版本中，React将对大多数事件执行<code>document.addEventListener()</code>。 React 17将在后调用<code>rootNode.addEventListener()</code>。</li> <li>新的<code>jsx</code>转换。为全新的 JSX 转换器添加 <code>react/jsx-runtime</code> 和 <code>react/jsx-dev-runtime</code>。</li> <li><code>Concurrent Mode</code> (实验阶段)。在实现性 API 前添加 <code>unstable_</code> 前缀。</li> <li><code>useEffect</code> 的回调修改为异步调用。<code>useEffect</code> 的副作用清理函数是在 <code>effect</code> 执行之后立马执行的，但是在使用中发现了如果回调中的操作比较耗时，会造成一些性能问题，现在<code>useEffect</code> 的 副作用清理函数会在 <code>render</code> 后执行了。</li></ul></li> <li>React 18 Alpha
<ul><li>时间分片是利用了 fiber 的可中断，可继续的功能，每个渲染周期内都会留一部分的时间来响应用户的输入,或者其他 IO 的状态修改。</li> <li>使用 Transition API 进行并发控制。React 在内部使用了一个“调度程序”，负责对这些回调进行优先级排序和请求</li> <li>自动批处理，多次调用状态修改函数，会进行合并。如果不想批处理，需要在函数外面包裹一层<code>flushSync</code>函数，同步渲染。</li> <li>SSR 支持 Suspense，更快的加载页面。</li></ul></li></ul> <h2 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h2> <h3 id="对比-vue"><a href="#对比-vue" class="header-anchor">#</a> 对比 Vue</h3> <ul><li><code>JSX</code> 是一种扩展的 <code>XML</code> 语言，最终 <code>JSX</code> 写出的代码会被转换成 <code>React.createElement</code>的形式。</li> <li><code>JSX</code> 中的表达式，是使用<code>{}</code>来插入；而 Vue 使用的是“Mustache”语法 (双大括号) 的文本插值。</li> <li>跟 Vue 比较，更接近于原生 JS，比如少了指令、修饰符等一些语法糖。</li> <li><code>portal</code> 跟 Vue 中的 <code>teloport</code> 类似。</li> <li><code>props.children</code> 跟 <code>slot</code>类似。</li> <li><code>Context</code> 类似 <code>provider/inject</code></li></ul> <h4 id="指定属性"><a href="#指定属性" class="header-anchor">#</a> 指定属性</h4> <ul><li>通过引号来指定字符串字面量， <code>const element = &lt;div dataIndex=&quot;o&quot;&gt;&lt;/div&gt;</code></li> <li>通过大括号，来指定表达式，<code>const el = &lt;img src={url}&gt;&lt;/img&gt;</code></li> <li><code>React DOM</code> 使用 <code>camelCase</code>（小驼峰命名）来定义属性的名称。</li> <li><code>React DOM</code> 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。可以有效的防止XSS攻击。</li></ul> <h3 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h3> <ul><li>挂载过程中会依次执行：
<ul><li>constructor</li> <li>componentWillMount</li> <li>render</li> <li>componentDidMount,一般组件需要自己加载数据，放到这个函数中</li></ul></li></ul> <h4 id="更新"><a href="#更新" class="header-anchor">#</a> 更新</h4> <ul><li>有三种途径：父组件更新、自身的状态变化、强制更新</li></ul> <h3 id="数据-state"><a href="#数据-state" class="header-anchor">#</a> 数据 State</h3> <ul><li>构造函数是唯一可以给 <code>this.state</code> 赋值的地方。</li> <li>出于性能考虑，<code>React</code> 可能会把多个 <code>setState()</code> 调用合并成一个调用。</li> <li>数据是向下流动的，也称之为单向数据流。</li></ul> <h3 id="组件"><a href="#组件" class="header-anchor">#</a> 组件</h3> <ul><li>所有 React 组件的 <code>props</code> 不能更改。</li></ul> <h4 id="functional-component"><a href="#functional-component" class="header-anchor">#</a> Functional Component</h4> <ul><li>函数式组件</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Welcome</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="类组件"><a href="#类组件" class="header-anchor">#</a> 类组件</h4> <ul><li>即：class 组件。</li> <li><code>Class</code> 组件应该始终使用 <code>props</code> 参数来调用父类的构造函数。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Welcome</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
	<span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="purecomponent"><a href="#purecomponent" class="header-anchor">#</a> PureComponent</h4> <ul><li>15.3 引入的一个组件基类。</li> <li><code>shouldComponentUpdate</code>不会直接返回<code>true</code>，而是会对属性和状态进行浅层比较。</li></ul> <h4 id="渲染"><a href="#渲染" class="header-anchor">#</a> 渲染</h4> <ul><li>条件渲染：
<ul><li><code>condition &amp;&amp; expression</code></li> <li><code>condition ? expression1 : expression2</code></li></ul></li> <li>在组件的 render 方法中返回 null 并不会影响组件的生命周期。</li></ul> <h4 id="列表"><a href="#列表" class="header-anchor">#</a> 列表</h4> <ul><li>如果列表项目的顺序可能会变化，我们不建议使用索引来用作 <code>key</code> 值，因为这样做会导致性能变差，还可能引起组件状态的问题。</li> <li>当我们生成两个不同的数组时，我们可以使用相同的 <code>key</code> 值。</li></ul> <h4 id="事件"><a href="#事件" class="header-anchor">#</a> 事件</h4> <ul><li>不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用 <code>preventDefault</code>。</li> <li>class 的方法默认不会绑定 this，需要手动绑定。有两种方法可以解决：
<ul><li>试验性质的<code>public class fields</code>语法，声明方法的时候：<code>handleClick = () =&gt; {console.log()}</code>, 事件监听：<code>&lt;button onClick={this.handleClick}&gt;&lt;/button&gt;</code></li> <li>或者可以使用箭头函数，<code>handleClick() {}</code>，事件监听：<code>&lt;button onClick={() =&gt; {this.handleClick()}&gt;&lt;/button</code>。这种写法有个问题，每次渲染的时候都会创建回调函数。如果是作为props传入子组件的话，会进行额外的重新渲染。</li></ul></li> <li>事件传参，有两种方式
<ul><li><code>&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;</code>，这种需要显示的传递事件对象 e。</li> <li><code>&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;</code>，默认隐式传递。</li></ul></li></ul> <h3 id="合成事件"><a href="#合成事件" class="header-anchor">#</a> 合成事件</h3> <ul><li>React 合成事件（<code>SyntheticEvent</code>）是React模拟原生DOM事件所有能力的一个事件对象。它遵循 W3C 规范，兼容所有浏览器，拥有与浏览器原生事件相同的接口。</li> <li>React 中，所有事件都是合成的，不是原生的，但可以通过 <code>e.nativeEvent</code> 属性获取 DOM 事件。</li> <li>为什么使用合成事件
<ul><li>浏览器兼容，使用顶级事件代理机制，保证冒泡的一致性。</li> <li>避免垃圾回收。引入事件池，从中获取或释放事件对象，避免频繁的创建和销毁事件对象。</li> <li>方便事件统一管理和事务机制。</li></ul></li> <li>可以使用 <code>e.stopPropagation()</code> 或者 <code>e.cancelBubble=true（IE）</code>来阻止事件的冒泡传播。</li> <li>与原生事件区别
<ul><li>命名方式不同。原生为纯小写<code>&lt;button onclick='handleClick()'&gt;</code>，React采用小驼峰，<code>&lt;button onClick={handleClick}&gt;</code></li> <li>事件处理函数写法不同，原生是字符串，React是函数。</li> <li>阻止默认行为方式不同：原生返回<code>false</code>，React 显示调用<code>preventDefault()</code></li></ul></li> <li>执行顺序
<ul><li>在 React 中，“合成事件”会以事件委托<code>（Event Delegation）</code>方式绑定在组件最上层，并在组件卸载<code>（unmount）</code>阶段自动销毁绑定的事件。</li> <li>React 所有事件都挂载在 document 对象上；</li> <li>当真实 DOM 元素触发事件，会冒泡到 document 对象后，再处理 React 事件；</li> <li>所以会先执行原生事件，然后处理 React 事件；</li> <li>最后真正执行 document 上挂载的事件。</li></ul></li></ul> <h3 id="表单"><a href="#表单" class="header-anchor">#</a> 表单</h3> <ul><li>表单一般会设计为受控组件，它的状态，会收到用户交互影响而改变，从而也会导致UI层的改变。</li> <li>当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。</li> <li><code>this.setState({[name]: value})</code>，这里利用了ES6 计算属性名称的语法。</li> <li>在受控组件上指定 <code>value</code> 的值， 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将value 设置为 undefined 或 null。</li> <li>处理表单的时候，推荐使用受控组件。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。</li></ul> <h3 id="组合、继承"><a href="#组合、继承" class="header-anchor">#</a> 组合、继承</h3> <ul><li>推荐使用组合而非继承来实现组件间的代码重用。</li> <li>通过<code>children prop</code> 来将他们的子组件传递到渲染结果中，类似 Vue 中的插槽。也可以通过<code>prop</code>来传递组件。</li> <li>React 中没有“槽”这一概念的限制，你可以将任何东西作为 props 进行传递。</li> <li>如果想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入<code>（import）</code>而无需通过 <code>extend</code> 继承它们。</li></ul> <h2 id="高级部分"><a href="#高级部分" class="header-anchor">#</a> 高级部分</h2> <h3 id="代码分割"><a href="#代码分割" class="header-anchor">#</a> 代码分割</h3> <ul><li>使用 Create React App，该功能已开箱即用。</li> <li>当使用 Babel 时，你要确保 Babel 能够解析动态 import 语法而不是将其进行转换。需要 <code>@babel/plugin-syntax-dynamic-import</code> 插件。</li> <li><code>React.lazy</code>，可以动态引入组件。然后应在 Suspense 组件中渲染 lazy 组件，如此使得我们可以使用在等待加载 lazy 组件时做优雅降级。</li> <li>如果动态加载的组件有带有样式的，需要做处理，那么打包跟 chunk 文件一起，这样的话 css 文件不会被异步加载。</li> <li>注意：<code>React.lazy</code> 目前只支持默认导出（default exports）。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span>Suspense<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">const</span> LazyComp <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./LazyComp'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">MyComp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>
		<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>Suspense fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>loading<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
				<span class="token operator">&lt;</span>LazyComp <span class="token operator">/</span><span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span><span class="token operator">/</span>Suspense<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
	<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="context"><a href="#context" class="header-anchor">#</a> Context</h3> <ul><li><code>Context</code> 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 <code>props</code>。</li> <li>TOFILL</li></ul> <h3 id="高阶组件"><a href="#高阶组件" class="header-anchor">#</a> 高阶组件</h3> <ul><li>定义：将组件作为参数，并返回新组件的函数。</li> <li>常见的组件就是：Redux 的 <code>connect</code></li> <li>解决的问题：我们需要一个抽象，允许我们在一个地方定义这个逻辑，并在许多组件之间共享它。</li></ul> <h2 id="api"><a href="#api" class="header-anchor">#</a> API</h2> <h3 id="createelement"><a href="#createelement" class="header-anchor">#</a> createElement</h3> <ul><li>跟 Vue3.0 中的 <code>h</code> 函数很像</li></ul> <h2 id="concurrent-模式"><a href="#concurrent-模式" class="header-anchor">#</a> Concurrent 模式</h2> <ul><li>目前尚处于实验阶段，可能会在 <code>React 18</code> 版本中落地。</li> <li>概念：<code>Concurrent</code> 模式是一组 <code>React</code> 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。在 <code>Concurrent</code> 模式中，渲染不是阻塞的。它是可中断的。</li> <li>产生卡顿的原因很简单：一旦渲染开始，就不能被终止。<code>Concurrent</code> 模式减少了防抖和节流在 UI 中的需求。因为渲染是可以中断的，React 不需要人为地 延迟 工作以避免卡顿。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b5b43a0f.js" defer></script><script src="/assets/js/2.07f3c95d.js" defer></script><script src="/assets/js/63.938854e9.js" defer></script>
  </body>
</html>
