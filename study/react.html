<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React 学习笔记 | 逗逼码农</title>
    <meta name="generator" content="VuePress 1.8.2">
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?97584138af9a81f074d821256641e300";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    <meta name="description" content="持续提升，降低欲望；乐观幽默，自律坦然">
    
    <link rel="preload" href="/assets/css/0.styles.35bcedcf.css" as="style"><link rel="preload" href="/assets/js/app.0513760d.js" as="script"><link rel="preload" href="/assets/js/2.dc0afc93.js" as="script"><link rel="preload" href="/assets/js/48.06bc1f8f.js" as="script"><link rel="prefetch" href="/assets/js/10.f7a71898.js"><link rel="prefetch" href="/assets/js/11.c744beb7.js"><link rel="prefetch" href="/assets/js/12.43f47731.js"><link rel="prefetch" href="/assets/js/13.faf6e2db.js"><link rel="prefetch" href="/assets/js/14.219200c9.js"><link rel="prefetch" href="/assets/js/15.4c057cfb.js"><link rel="prefetch" href="/assets/js/16.6b8e6641.js"><link rel="prefetch" href="/assets/js/17.d5bff695.js"><link rel="prefetch" href="/assets/js/18.9b59be54.js"><link rel="prefetch" href="/assets/js/19.536b8a35.js"><link rel="prefetch" href="/assets/js/20.f0651e91.js"><link rel="prefetch" href="/assets/js/21.b9b97edf.js"><link rel="prefetch" href="/assets/js/22.16ff9055.js"><link rel="prefetch" href="/assets/js/23.a7c8193d.js"><link rel="prefetch" href="/assets/js/24.7846edb1.js"><link rel="prefetch" href="/assets/js/25.c849d65d.js"><link rel="prefetch" href="/assets/js/26.42b4aa31.js"><link rel="prefetch" href="/assets/js/27.a874250c.js"><link rel="prefetch" href="/assets/js/28.43a43bcf.js"><link rel="prefetch" href="/assets/js/29.804182d6.js"><link rel="prefetch" href="/assets/js/3.4d1b1a3e.js"><link rel="prefetch" href="/assets/js/30.f2eb8d94.js"><link rel="prefetch" href="/assets/js/31.e90d7b4c.js"><link rel="prefetch" href="/assets/js/32.1cd900b9.js"><link rel="prefetch" href="/assets/js/33.93d4972c.js"><link rel="prefetch" href="/assets/js/34.188088ae.js"><link rel="prefetch" href="/assets/js/35.cd951e9a.js"><link rel="prefetch" href="/assets/js/36.eb69da45.js"><link rel="prefetch" href="/assets/js/37.6f1fb353.js"><link rel="prefetch" href="/assets/js/38.392d3990.js"><link rel="prefetch" href="/assets/js/39.da1726a5.js"><link rel="prefetch" href="/assets/js/4.c610d016.js"><link rel="prefetch" href="/assets/js/40.e56c9975.js"><link rel="prefetch" href="/assets/js/41.3dee4576.js"><link rel="prefetch" href="/assets/js/42.b7200451.js"><link rel="prefetch" href="/assets/js/43.ff9e6ea7.js"><link rel="prefetch" href="/assets/js/44.81f977df.js"><link rel="prefetch" href="/assets/js/45.04b6f380.js"><link rel="prefetch" href="/assets/js/46.3212c02d.js"><link rel="prefetch" href="/assets/js/47.e772f81d.js"><link rel="prefetch" href="/assets/js/49.1c9abae2.js"><link rel="prefetch" href="/assets/js/5.26471bd2.js"><link rel="prefetch" href="/assets/js/50.ff5caa6e.js"><link rel="prefetch" href="/assets/js/51.a3965e2d.js"><link rel="prefetch" href="/assets/js/52.f62b3b40.js"><link rel="prefetch" href="/assets/js/53.0a42570b.js"><link rel="prefetch" href="/assets/js/54.256f6837.js"><link rel="prefetch" href="/assets/js/55.e9c4cbe7.js"><link rel="prefetch" href="/assets/js/56.10836ba0.js"><link rel="prefetch" href="/assets/js/57.d2d00ef5.js"><link rel="prefetch" href="/assets/js/58.2c1bdf43.js"><link rel="prefetch" href="/assets/js/59.7b2d434d.js"><link rel="prefetch" href="/assets/js/6.66b67ff0.js"><link rel="prefetch" href="/assets/js/60.71e2464a.js"><link rel="prefetch" href="/assets/js/61.0d435bb5.js"><link rel="prefetch" href="/assets/js/62.6daecc67.js"><link rel="prefetch" href="/assets/js/63.ffc85a5c.js"><link rel="prefetch" href="/assets/js/64.c495ff69.js"><link rel="prefetch" href="/assets/js/65.a2681e68.js"><link rel="prefetch" href="/assets/js/66.51f0a5c4.js"><link rel="prefetch" href="/assets/js/67.a4e50e62.js"><link rel="prefetch" href="/assets/js/68.019c3d97.js"><link rel="prefetch" href="/assets/js/69.528b3503.js"><link rel="prefetch" href="/assets/js/7.695c93bc.js"><link rel="prefetch" href="/assets/js/8.7d9ec861.js"><link rel="prefetch" href="/assets/js/9.7833fb7a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35bcedcf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">逗逼码农</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://www.cnblogs.com/hutaoer/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  旧的博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/hutaoer" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://www.cnblogs.com/hutaoer/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  旧的博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/hutaoer" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React 学习笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/react.html#设计思想" class="sidebar-link">设计思想</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/study/react.html#基础" class="sidebar-link">基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/react.html#对比-vue" class="sidebar-link">对比 Vue</a></li><li class="sidebar-sub-header"><a href="/study/react.html#生命周期" class="sidebar-link">生命周期</a></li><li class="sidebar-sub-header"><a href="/study/react.html#数据-state" class="sidebar-link">数据 State</a></li><li class="sidebar-sub-header"><a href="/study/react.html#组件" class="sidebar-link">组件</a></li><li class="sidebar-sub-header"><a href="/study/react.html#表单" class="sidebar-link">表单</a></li><li class="sidebar-sub-header"><a href="/study/react.html#组合、继承" class="sidebar-link">组合、继承</a></li></ul></li><li><a href="/study/react.html#高级部分" class="sidebar-link">高级部分</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/react.html#代码分割" class="sidebar-link">代码分割</a></li><li class="sidebar-sub-header"><a href="/study/react.html#context" class="sidebar-link">Context</a></li><li class="sidebar-sub-header"><a href="/study/react.html#高阶组件" class="sidebar-link">高阶组件</a></li></ul></li><li><a href="/study/react.html#api" class="sidebar-link">API</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/react.html#createelement" class="sidebar-link">createElement</a></li></ul></li><li><a href="/study/react.html#concurrent-模式" class="sidebar-link">Concurrent 模式</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react-学习笔记"><a href="#react-学习笔记" class="header-anchor">#</a> React 学习笔记</h1> <ul><li><code>React</code>是一个用于构建用户界面的 JS 库，相当于 <code>MVC</code> 中的<code>View</code>层。</li></ul> <h2 id="设计思想"><a href="#设计思想" class="header-anchor">#</a> 设计思想</h2> <ul><li>React 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递。尽管如此，但这种需要显式声明的方法更有助于人们理解程序的运作方式。</li> <li>state 只能由拥有它们的组件进行更改。</li></ul> <h2 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h2> <h3 id="对比-vue"><a href="#对比-vue" class="header-anchor">#</a> 对比 Vue</h3> <ul><li><code>JSX</code> 是一种扩展的 <code>XML</code> 语言，最终 <code>JSX</code> 写出的代码会被转换成 <code>React.createElement</code>的形式。</li> <li><code>JSX</code> 中的表达式，是使用<code>{}</code>来插入；而 Vue 使用的是“Mustache”语法 (双大括号) 的文本插值。</li> <li>跟 Vue 比较，更接近于原生 JS，比如少了指令、修饰符等一些语法糖。</li> <li><code>portal</code> 跟 Vue 中的 <code>teloport</code> 类似。</li> <li><code>props.children</code> 跟 <code>slot</code>类似。</li> <li><code>Context</code> 类似 <code>provider/inject</code></li></ul> <h4 id="指定属性"><a href="#指定属性" class="header-anchor">#</a> 指定属性</h4> <ul><li>通过引号来指定字符串字面量， <code>const element = &lt;div dataIndex=&quot;o&quot;&gt;&lt;/div&gt;</code></li> <li>通过大括号，来指定表达式，<code>const el = &lt;img src={url}&gt;&lt;/img&gt;</code></li> <li><code>React DOM</code> 使用 <code>camelCase</code>（小驼峰命名）来定义属性的名称。</li> <li><code>React DOM</code> 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。可以有效的防止XSS攻击。</li></ul> <h3 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h3> <ul><li>挂载过程中会依次执行：
<ul><li>constructor</li> <li>componentWillMount</li> <li>render</li> <li>componentDidMount,一般组件需要自己加载数据，放到这个函数中</li></ul></li></ul> <h4 id="更新"><a href="#更新" class="header-anchor">#</a> 更新</h4> <ul><li>有三种途径：父组件更新、自身的状态变化、强制更新</li></ul> <h3 id="数据-state"><a href="#数据-state" class="header-anchor">#</a> 数据 State</h3> <ul><li>构造函数是唯一可以给 <code>this.state</code> 赋值的地方。</li> <li>出于性能考虑，<code>React</code> 可能会把多个 <code>setState()</code> 调用合并成一个调用。</li> <li>数据是向下流动的，也称之为单向数据流。</li></ul> <h3 id="组件"><a href="#组件" class="header-anchor">#</a> 组件</h3> <ul><li>所有 React 组件的 <code>props</code> 不能更改。</li></ul> <h4 id="functional-component"><a href="#functional-component" class="header-anchor">#</a> Functional Component</h4> <ul><li>函数式组件</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Welcome</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="类组件"><a href="#类组件" class="header-anchor">#</a> 类组件</h4> <ul><li>即：class 组件。</li> <li><code>Class</code> 组件应该始终使用 <code>props</code> 参数来调用父类的构造函数。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Welcome</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
	<span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="purecomponent"><a href="#purecomponent" class="header-anchor">#</a> PureComponent</h5> <ul><li>15.3 引入的一个组件基类。</li> <li><code>shouldComponentUpdate</code>不会直接返回<code>true</code>，而是会对属性和状态进行浅层比较。</li></ul> <h4 id="事件"><a href="#事件" class="header-anchor">#</a> 事件</h4> <ul><li>不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用 <code>preventDefault</code>。</li> <li>class 的方法默认不会绑定 this，需要手动绑定。有两种方法可以解决：
<ul><li>试验性质的<code>public class fields</code>语法，声明方法的时候：<code>handleClick = () =&gt; {console.log()}</code>, 事件监听：<code>&lt;button onClick={this.handleClick}&gt;&lt;/button&gt;</code></li> <li>或者可以使用箭头函数，<code>handleClick() {}</code>，事件监听：<code>&lt;button onClick={() =&gt; {this.handleClick()}&gt;&lt;/button</code>。这种写法有个问题，每次渲染的时候都会创建回调函数。如果是作为props传入子组件的话，会进行额外的重新渲染。</li></ul></li> <li>事件传参，有两种方式
<ul><li><code>&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;</code>，这种需要显示的传递事件对象 e。</li> <li><code>&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;</code>，默认隐式传递。</li></ul></li></ul> <h4 id="渲染"><a href="#渲染" class="header-anchor">#</a> 渲染</h4> <ul><li>条件渲染：
<ul><li><code>condition &amp;&amp; expression</code></li> <li><code>condition ? expression1 : expression2</code></li></ul></li> <li>在组件的 render 方法中返回 null 并不会影响组件的生命周期。</li></ul> <h4 id="列表"><a href="#列表" class="header-anchor">#</a> 列表</h4> <ul><li>如果列表项目的顺序可能会变化，我们不建议使用索引来用作 <code>key</code> 值，因为这样做会导致性能变差，还可能引起组件状态的问题。</li> <li>当我们生成两个不同的数组时，我们可以使用相同的 <code>key</code> 值。</li></ul> <h3 id="表单"><a href="#表单" class="header-anchor">#</a> 表单</h3> <ul><li>表单一般会设计为受控组件，它的状态，会收到用户交互影响而改变，从而也会导致UI层的改变。</li> <li>当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。</li> <li><code>this.setState({[name]: value})</code>，这里利用了ES6 计算属性名称的语法。</li> <li>在受控组件上指定 <code>value</code> 的值， 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将value 设置为 undefined 或 null。</li> <li>处理表单的时候，推荐使用受控组件。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。</li></ul> <h3 id="组合、继承"><a href="#组合、继承" class="header-anchor">#</a> 组合、继承</h3> <ul><li>推荐使用组合而非继承来实现组件间的代码重用。</li> <li>通过<code>children prop</code> 来将他们的子组件传递到渲染结果中，类似 Vue 中的插槽。也可以通过<code>prop</code>来传递组件。</li> <li>React 中没有“槽”这一概念的限制，你可以将任何东西作为 props 进行传递。</li> <li>如果想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入<code>（import）</code>而无需通过 <code>extend</code> 继承它们。</li></ul> <h2 id="高级部分"><a href="#高级部分" class="header-anchor">#</a> 高级部分</h2> <h3 id="代码分割"><a href="#代码分割" class="header-anchor">#</a> 代码分割</h3> <ul><li>使用 Create React App，该功能已开箱即用。</li> <li>当使用 Babel 时，你要确保 Babel 能够解析动态 import 语法而不是将其进行转换。需要 <code>@babel/plugin-syntax-dynamic-import</code> 插件。</li> <li><code>React.lazy</code>，可以动态引入组件。然后应在 Suspense 组件中渲染 lazy 组件，如此使得我们可以使用在等待加载 lazy 组件时做优雅降级。</li> <li>如果动态加载的组件有带有样式的，需要做处理，那么打包跟 chunk 文件一起，这样的话 css 文件不会被异步加载。</li> <li>注意：<code>React.lazy</code> 目前只支持默认导出（default exports）。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span>Suspense<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">const</span> LazyComp <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./LazyComp'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">MyComp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>
		<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>Suspense fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>loading<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
				<span class="token operator">&lt;</span>LazyComp <span class="token operator">/</span><span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span><span class="token operator">/</span>Suspense<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
	<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="context"><a href="#context" class="header-anchor">#</a> Context</h3> <ul><li><code>Context</code> 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 <code>props</code>。</li> <li>TOFILL</li></ul> <h3 id="高阶组件"><a href="#高阶组件" class="header-anchor">#</a> 高阶组件</h3> <ul><li>定义：将组件作为参数，并返回新组件的函数。</li> <li>常见的组件就是：Redux 的 <code>connect</code></li> <li>解决的问题：我们需要一个抽象，允许我们在一个地方定义这个逻辑，并在许多组件之间共享它。</li></ul> <h2 id="api"><a href="#api" class="header-anchor">#</a> API</h2> <h3 id="createelement"><a href="#createelement" class="header-anchor">#</a> createElement</h3> <ul><li>跟 Vue3.0 中的 <code>h</code> 函数很像</li></ul> <h2 id="concurrent-模式"><a href="#concurrent-模式" class="header-anchor">#</a> Concurrent 模式</h2> <ul><li>目前尚处于实验阶段，可能会在 <code>React 18</code> 版本中落地。</li> <li>概念：<code>Concurrent</code> 模式是一组 <code>React</code> 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。在 <code>Concurrent</code> 模式中，渲染不是阻塞的。它是可中断的。</li> <li>产生卡顿的原因很简单：一旦渲染开始，就不能被终止。<code>Concurrent</code> 模式减少了防抖和节流在 UI 中的需求。因为渲染是可以中断的，React 不需要人为地 延迟 工作以避免卡顿。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.0513760d.js" defer></script><script src="/assets/js/2.dc0afc93.js" defer></script><script src="/assets/js/48.06bc1f8f.js" defer></script>
  </body>
</html>
