<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React 知识点梳理 | 逗逼码农:Blackey</title>
    <meta name="generator" content="VuePress 1.9.9">
    <script>
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?b6eca7f42777b93d2edc92dba0220839";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
    <meta name="description" content="持续提升，降低欲望；乐观幽默，自律坦然">
    
    <link rel="preload" href="/assets/css/0.styles.6b12758a.css" as="style"><link rel="preload" href="/assets/js/app.d7400715.js" as="script"><link rel="preload" href="/assets/js/3.ea6371c1.js" as="script"><link rel="preload" href="/assets/js/1.51666839.js" as="script"><link rel="preload" href="/assets/js/105.1374d1fe.js" as="script"><link rel="prefetch" href="/assets/js/10.f58dbb2d.js"><link rel="prefetch" href="/assets/js/100.433e72f6.js"><link rel="prefetch" href="/assets/js/101.14bd424e.js"><link rel="prefetch" href="/assets/js/102.18a3b89b.js"><link rel="prefetch" href="/assets/js/103.ac35965a.js"><link rel="prefetch" href="/assets/js/104.c643a5c7.js"><link rel="prefetch" href="/assets/js/106.9aa9dadc.js"><link rel="prefetch" href="/assets/js/107.d055dbbe.js"><link rel="prefetch" href="/assets/js/108.32c4fd06.js"><link rel="prefetch" href="/assets/js/109.d1906fcf.js"><link rel="prefetch" href="/assets/js/11.64d74831.js"><link rel="prefetch" href="/assets/js/110.179f106f.js"><link rel="prefetch" href="/assets/js/111.f1a4d1fc.js"><link rel="prefetch" href="/assets/js/112.37e5a8a4.js"><link rel="prefetch" href="/assets/js/113.5bd42016.js"><link rel="prefetch" href="/assets/js/114.0f11ed4e.js"><link rel="prefetch" href="/assets/js/115.98f0eda8.js"><link rel="prefetch" href="/assets/js/116.072d5582.js"><link rel="prefetch" href="/assets/js/117.3d5d8324.js"><link rel="prefetch" href="/assets/js/118.01a33ba7.js"><link rel="prefetch" href="/assets/js/119.7eb48989.js"><link rel="prefetch" href="/assets/js/12.43eda7d3.js"><link rel="prefetch" href="/assets/js/120.590ebf7f.js"><link rel="prefetch" href="/assets/js/121.9eb512c7.js"><link rel="prefetch" href="/assets/js/122.f5cf428b.js"><link rel="prefetch" href="/assets/js/123.91174b09.js"><link rel="prefetch" href="/assets/js/124.ef118a18.js"><link rel="prefetch" href="/assets/js/125.23facba1.js"><link rel="prefetch" href="/assets/js/126.fb781191.js"><link rel="prefetch" href="/assets/js/127.237424a7.js"><link rel="prefetch" href="/assets/js/128.1d4eb7cf.js"><link rel="prefetch" href="/assets/js/129.cd1a2f4e.js"><link rel="prefetch" href="/assets/js/13.f1a1b718.js"><link rel="prefetch" href="/assets/js/130.94f3c2b6.js"><link rel="prefetch" href="/assets/js/131.ee1ae023.js"><link rel="prefetch" href="/assets/js/132.240c352c.js"><link rel="prefetch" href="/assets/js/133.a4e00300.js"><link rel="prefetch" href="/assets/js/134.42ca3e54.js"><link rel="prefetch" href="/assets/js/135.81b4b3cf.js"><link rel="prefetch" href="/assets/js/136.2b9fc1a8.js"><link rel="prefetch" href="/assets/js/137.9a5f4b62.js"><link rel="prefetch" href="/assets/js/138.5fc683da.js"><link rel="prefetch" href="/assets/js/139.366fffb5.js"><link rel="prefetch" href="/assets/js/14.7cb9a8ec.js"><link rel="prefetch" href="/assets/js/140.94f2e2ae.js"><link rel="prefetch" href="/assets/js/141.7919af68.js"><link rel="prefetch" href="/assets/js/142.36434311.js"><link rel="prefetch" href="/assets/js/143.bbc229cc.js"><link rel="prefetch" href="/assets/js/144.11929360.js"><link rel="prefetch" href="/assets/js/145.a231fa70.js"><link rel="prefetch" href="/assets/js/146.5cb0a2df.js"><link rel="prefetch" href="/assets/js/147.c2233f90.js"><link rel="prefetch" href="/assets/js/15.22c8cb53.js"><link rel="prefetch" href="/assets/js/16.6ceca5e2.js"><link rel="prefetch" href="/assets/js/17.61ddf260.js"><link rel="prefetch" href="/assets/js/18.aeacb996.js"><link rel="prefetch" href="/assets/js/19.04c4505f.js"><link rel="prefetch" href="/assets/js/20.e1c07183.js"><link rel="prefetch" href="/assets/js/21.3c4ef1de.js"><link rel="prefetch" href="/assets/js/22.53172acd.js"><link rel="prefetch" href="/assets/js/23.d39b208c.js"><link rel="prefetch" href="/assets/js/24.5328005e.js"><link rel="prefetch" href="/assets/js/25.97076771.js"><link rel="prefetch" href="/assets/js/26.e9c9b87a.js"><link rel="prefetch" href="/assets/js/27.f5845ccc.js"><link rel="prefetch" href="/assets/js/28.5a1378d3.js"><link rel="prefetch" href="/assets/js/29.6563bc07.js"><link rel="prefetch" href="/assets/js/30.55b85fe5.js"><link rel="prefetch" href="/assets/js/31.d200e7e2.js"><link rel="prefetch" href="/assets/js/32.4c7273a1.js"><link rel="prefetch" href="/assets/js/33.1e6542ef.js"><link rel="prefetch" href="/assets/js/34.fe1989f4.js"><link rel="prefetch" href="/assets/js/35.4d0006a6.js"><link rel="prefetch" href="/assets/js/36.099a6890.js"><link rel="prefetch" href="/assets/js/37.b1fbc124.js"><link rel="prefetch" href="/assets/js/38.612767aa.js"><link rel="prefetch" href="/assets/js/39.98fbaf9a.js"><link rel="prefetch" href="/assets/js/4.ee2cbdf1.js"><link rel="prefetch" href="/assets/js/40.4ac08a07.js"><link rel="prefetch" href="/assets/js/41.368a1169.js"><link rel="prefetch" href="/assets/js/42.c587611a.js"><link rel="prefetch" href="/assets/js/43.018dcb1b.js"><link rel="prefetch" href="/assets/js/44.0f5c72e2.js"><link rel="prefetch" href="/assets/js/45.de51a78b.js"><link rel="prefetch" href="/assets/js/46.4c4c082e.js"><link rel="prefetch" href="/assets/js/47.c0c9637b.js"><link rel="prefetch" href="/assets/js/48.3f5ca5f1.js"><link rel="prefetch" href="/assets/js/49.42ccaf0e.js"><link rel="prefetch" href="/assets/js/5.44a5a2f5.js"><link rel="prefetch" href="/assets/js/50.f76f0545.js"><link rel="prefetch" href="/assets/js/51.ad59a784.js"><link rel="prefetch" href="/assets/js/52.1e089d4d.js"><link rel="prefetch" href="/assets/js/53.156df59b.js"><link rel="prefetch" href="/assets/js/54.c54d9c9a.js"><link rel="prefetch" href="/assets/js/55.4d6afc02.js"><link rel="prefetch" href="/assets/js/56.0a7a6ae1.js"><link rel="prefetch" href="/assets/js/57.946a8789.js"><link rel="prefetch" href="/assets/js/58.c4357fa0.js"><link rel="prefetch" href="/assets/js/59.078287ed.js"><link rel="prefetch" href="/assets/js/6.318277a8.js"><link rel="prefetch" href="/assets/js/60.b4a031bc.js"><link rel="prefetch" href="/assets/js/61.3ae3e2d9.js"><link rel="prefetch" href="/assets/js/62.78be8eed.js"><link rel="prefetch" href="/assets/js/63.73db2a5f.js"><link rel="prefetch" href="/assets/js/64.8e67c64f.js"><link rel="prefetch" href="/assets/js/65.13c35b9c.js"><link rel="prefetch" href="/assets/js/66.bc8ccb4d.js"><link rel="prefetch" href="/assets/js/67.07b1c042.js"><link rel="prefetch" href="/assets/js/68.818d87df.js"><link rel="prefetch" href="/assets/js/69.b97676ab.js"><link rel="prefetch" href="/assets/js/7.fe69baf6.js"><link rel="prefetch" href="/assets/js/70.90aabc6e.js"><link rel="prefetch" href="/assets/js/71.122de2a1.js"><link rel="prefetch" href="/assets/js/72.98449345.js"><link rel="prefetch" href="/assets/js/73.7b8dfefc.js"><link rel="prefetch" href="/assets/js/74.191b683a.js"><link rel="prefetch" href="/assets/js/75.f0e5713d.js"><link rel="prefetch" href="/assets/js/76.e32b60bf.js"><link rel="prefetch" href="/assets/js/77.5ec8ef9c.js"><link rel="prefetch" href="/assets/js/78.7b3f1686.js"><link rel="prefetch" href="/assets/js/79.65abc7a2.js"><link rel="prefetch" href="/assets/js/8.944a02e8.js"><link rel="prefetch" href="/assets/js/80.f46489eb.js"><link rel="prefetch" href="/assets/js/81.46ae47c2.js"><link rel="prefetch" href="/assets/js/82.0862a8de.js"><link rel="prefetch" href="/assets/js/83.dfeb2fcf.js"><link rel="prefetch" href="/assets/js/84.99e3093c.js"><link rel="prefetch" href="/assets/js/85.c99dea93.js"><link rel="prefetch" href="/assets/js/86.5c0a7500.js"><link rel="prefetch" href="/assets/js/87.4c778d51.js"><link rel="prefetch" href="/assets/js/88.52b41ff1.js"><link rel="prefetch" href="/assets/js/89.f58b2341.js"><link rel="prefetch" href="/assets/js/9.0c0f7730.js"><link rel="prefetch" href="/assets/js/90.6fa189bf.js"><link rel="prefetch" href="/assets/js/91.9cfa0e85.js"><link rel="prefetch" href="/assets/js/92.70b35b62.js"><link rel="prefetch" href="/assets/js/93.5e1fdc8a.js"><link rel="prefetch" href="/assets/js/94.17845ec9.js"><link rel="prefetch" href="/assets/js/95.3119d071.js"><link rel="prefetch" href="/assets/js/96.1bb74d56.js"><link rel="prefetch" href="/assets/js/97.f407f27e.js"><link rel="prefetch" href="/assets/js/98.588f50cf.js"><link rel="prefetch" href="/assets/js/99.d70d0c0c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6b12758a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>逗逼码农:Blackey</h3> <p class="description" data-v-59e6cb88>持续提升，降低欲望；乐观幽默，自律坦然</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">逗逼码农:Blackey</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><a href="https://github.com/hutaoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://www.cnblogs.com/hutaoer/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  旧的博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>137</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>83</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41><li class="social-item" data-v-1fad0c41><i class="iconfont reco-github" style="color:#f26d6d;" data-v-1fad0c41></i></li></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><a href="https://github.com/hutaoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://www.cnblogs.com/hutaoer/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  旧的博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">React 知识点梳理</h1> <div data-v-8a445198><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="react-知识点梳理"><a href="#react-知识点梳理" class="header-anchor">#</a> React 知识点梳理</h1> <h2 id="fiber机制"><a href="#fiber机制" class="header-anchor">#</a> fiber机制</h2> <ul><li>render 阶段是允许暂停、终止和重启的。</li> <li>render 阶段的生命周期都可能是被重复执行的。</li></ul> <h3 id="废弃的api"><a href="#废弃的api" class="header-anchor">#</a> 废弃的API</h3> <ul><li>废弃的API有：<code>componentWillMount</code>,<code>componentWillUpdate</code>,<code>componentWillReceiveProps</code>，都是处于render阶段，可能被重复执行的。</li> <li>这些API使用不推荐的操作：
<ul><li>在<code>componentWillMount</code>中，请求数据，应该放到<code>componentDidMount</code>中。首屏渲染依然会在数据返回之前执行。</li> <li><code>componentWillUpdate</code>和<code>componentWillReceiveProps</code>中滥用<code>setState</code>导致死循环。</li></ul></li> <li>fiber异步渲染机制下，可能导致的bug:
<ul><li>由于render阶段，生命周期可以重复执行，<code>componentWillMount</code>被打断、重复多次后，可能会发出多个请求。</li></ul></li> <li>新的生命周期：<code>getDerivedStateFromProps</code>是静态方法，不能访问<code>this</code></li> <li>React 16 改造生命周期的动机是为了配合 fiber 架构带来的异步渲染机制。</li></ul> <h2 id="数据传递"><a href="#数据传递" class="header-anchor">#</a> 数据传递</h2> <ul><li><code>UI = render(data)</code>, 视图会随着数据变化而变化。</li></ul> <h3 id="props"><a href="#props" class="header-anchor">#</a> props</h3> <ul><li>基于<code>props</code>的单向数据流，当前组件的<code>state</code>以<code>props</code>的形式流动时，只能流向组件树中比自己层级更低的组件。<code>props</code>传参适用于
<ul><li>父子间的组件通信</li> <li>兄弟组件间的数据通信</li> <li>其他场景，不推荐，不如超过了两层关系传递数据。</li></ul></li> <li>父组件的更新，都会触发子组件<code>componentWillReceiveProps</code>，而不仅仅是传入的<code>props</code>发生改变。</li></ul> <h3 id="发布订阅模式"><a href="#发布订阅模式" class="header-anchor">#</a> 发布订阅模式</h3> <ul><li>常见的有：<code>socket.io</code>, <code>Node.js</code>中的<code>EventEmitter</code>，<code>Vue.js</code>中的<code>EventBus</code></li> <li><code>target.addEventListener(type, listener, useCapture</code> 创建事件监听器</li> <li>监听位置和触发事件的位置不受限制。事件的监听即订阅，事件的触发即发布。</li> <li>使用发布订阅模式，可以在任意的组件间进行通信。</li></ul> <h3 id="context-api"><a href="#context-api" class="header-anchor">#</a> Context API</h3> <ul><li>16.3 版本后，新的<code>context API</code>，即使组件的<code>shouldComponentUpdate</code>返回<code>false</code>,它依然可以穿透组件，向子组件进行传播。</li></ul> <h3 id="redux"><a href="#redux" class="header-anchor">#</a> Redux</h3> <ul><li>Redux是js的状态容器。由三部分组成：<code>store</code>,<code>action</code>,<code>reducer</code>,在<code>redux</code>工作流程中，数据是严格单向的。</li> <li><code>store</code>是单一的数据源，只读。</li> <li><code>action</code>是对变化的描述，包含<code>type</code>和<code>payload</code></li> <li>使用<code>dispatch</code>来派发<code>action</code>,<code>store.dispatch(action)</code>, <code>action</code>会进入到<code>reducer</code>触发对应的更新。</li> <li><code>reducer</code>纯函数，对变化进行分发和处理，返回新的数据给<code>store</code></li></ul> <h2 id="函数组件与类组件对比"><a href="#函数组件与类组件对比" class="header-anchor">#</a> 函数组件与类组件对比</h2> <ul><li>类组件需要继承，函数组件不需要</li> <li>类组件可以访问生命周期方法，函数组件不可以</li> <li>类组件中可以获取实例化后的this，然后可以调用各种实例方法，有生命周期钩子。</li> <li>类组件中有state状态，函数组件没有。</li></ul> <h3 id="类组件"><a href="#类组件" class="header-anchor">#</a> 类组件</h3> <ul><li>是基于面向对象的一种封装，提供了各种钩子函数，但对于一些简单的场景，类组件的实现有些复杂。</li> <li>类组件的内部逻辑难以拆分和复用</li> <li>面向对象编程思想。</li></ul> <h3 id="函数组件"><a href="#函数组件" class="header-anchor">#</a> 函数组件</h3> <ul><li>轻量、灵活。</li> <li>函数组件会捕获<code>render</code>内部的状态，这是与类组件最大的不同。</li> <li>函数式编程思想。</li></ul> <h2 id="react-hooks"><a href="#react-hooks" class="header-anchor">#</a> React Hooks</h2> <ul><li>16.8 版本开始推广的。</li></ul> <h3 id="使用原则"><a href="#使用原则" class="header-anchor">#</a> 使用原则</h3> <ul><li>只在React 函数中使用 Hook</li> <li>不要在循环、条件或嵌套中使用 Hook</li></ul> <h3 id="底层实现"><a href="#底层实现" class="header-anchor">#</a> 底层实现</h3> <ul><li>依赖于顺序链表，<code>hooks</code>的本质是链表。所有的hook是通过单向链表存储的，每个<code>hook</code>是一个对象。</li> <li>首次渲染的时候，调用<code>moutState</code>构建链表并渲染</li> <li>二次渲染的时候，调用<code>updateState</code>一次遍历链表并渲染。</li> <li>hooks的渲染是通过<code>依次遍历</code>来定位每个hook的内容的。如果前后两次读到的链表在顺序上的位置不一样，那么渲染就会出现问题。</li></ul> <h2 id="虚拟dom"><a href="#虚拟dom" class="header-anchor">#</a> 虚拟DOM</h2> <ul><li>本质上是<code>js</code>和<code>DOM</code>之间的一个映射缓存，一个能描述<code>DOM</code>结构和属性的js对象。</li> <li>简单来讲，虚拟DOM是一个js对象，是对真实DOM的描述。</li> <li>挂载阶段：通过<code>JSX</code>，构建出虚拟DOM树，然后通过<code>ReactDOM.render</code>实现虚拟DOM到真实DOM的映射。</li> <li>更新阶段：页面的变化，会先作用于虚拟DOM，虚拟DOM借助diff算法，对比出需要改变的DOM，然后将这些改变作用于真实DOM。</li></ul> <h3 id="原始的方案"><a href="#原始的方案" class="header-anchor">#</a> 原始的方案</h3> <ul><li>原生对DOM操作，比较繁琐。</li> <li>jQuery，解决浏览器兼容性，API更人性化，链式调用。</li> <li>模板引擎，拼接DOM。没有缓存，更新的时候，性能存在瓶颈。</li> <li>使用虚拟DOM，更多的考虑是在于开发体验和研发效率，虚拟DOM不一定回带来更高的渲染效率。</li> <li>模板渲染过程：动态生成HTML字符串 -&gt; 旧的DOM元素整体被替换为新的DOM元素（全量更新）</li> <li>虚拟DOM渲染过程：构建新的虚拟DOM树 -&gt; 通过diff对比出新旧两个树的差异 -&gt; 差量更新DOM</li></ul> <h3 id="为什么要使用虚拟dom"><a href="#为什么要使用虚拟dom" class="header-anchor">#</a> 为什么要使用虚拟DOM</h3> <ul><li>模板引擎和虚拟DOM存在着递进的关系。</li> <li>解决了研发体验、研发效率、和跨平台的问题。</li> <li>解决跨平台问题：同一套虚拟DOM可以映射为不同平台的渲染元素。</li></ul> <h2 id="diff-算法"><a href="#diff-算法" class="header-anchor">#</a> diff 算法</h2> <ul><li>调和不等同于diff.</li> <li>React 15 使用的是 <code>Stack Reconciler</code>，同步递归，不可被打断。如果嵌套节点层级很深，递归的过程时间会很长，导致js长时间的占用主线程，从而导致页面的渲染卡顿。</li> <li>React 16 使用的是 <code>Fiber</code>。从架构来看，是对React核心算法重写；从编码来看，是React内部定义的一种数据结构，是虚拟节点；从工作流来看，Fiber节点保存了组件更新的状态和副作用。</li></ul> <h3 id="设计思想"><a href="#设计思想" class="header-anchor">#</a> 设计思想</h3> <ul><li>若两个组件属于同一个类型，它们拥有一样的DOM树形结构</li> <li>同一层级的一组子节点，可以通过设置<code>key</code>作为唯一标识，来维持各个节点在不同渲染过程中的稳定性。</li> <li>diff的关键点：1. 递归的进行分层对比；2. 必须是类型一致的节点；3. key属性设置，利于对节点的复用。</li></ul> <h3 id="reconciler"><a href="#reconciler" class="header-anchor">#</a> Reconciler</h3> <ul><li><code>Reconciler</code>中文意思是”调和器“</li> <li>虚拟DOM保存在内存中，通过<code>ReactDOM</code>等类库的作用，使之与真实的DOM同步，这个过程称之为协调（调和）。</li> <li>简单讲：就是将虚拟DOM转变为真实DOM的过程。</li> <li>调和器的工作：组件的挂载、卸载、更新等等。</li></ul> <h2 id="setstate"><a href="#setstate" class="header-anchor">#</a> setState</h2> <ul><li>为了避免频繁的二次渲染，setState 有异步更新、批量更新的机制。每次调用<code>setState</code>，将<code>state</code>缓存起来，在合适的时机，将<code>state</code>做合并，针对最新的<code>state</code>做更新渲染。</li> <li><code>setTimout</code> 可以帮助<code>setState</code> 脱离<code>React</code>的管控，从而变成同步的。一般而言，React管控下的<code>setState</code>一定是异步的。</li> <li><code>setState</code>并不是具备同步渲染的特性，而是在特定的场景下，比如在<code>setTimout</code>的回调中的时候，<code>isBatchingUpdates</code>的值，就是<code>false</code>，所以就变成了同步更新。</li></ul> <h3 id="工作流程"><a href="#工作流程" class="header-anchor">#</a> 工作流程</h3> <ul><li><code>setState</code> -&gt; <code>enqueueSetState</code> -&gt; <code>enqueueUpState</code> -&gt; <code>isBatchingUpdates??</code></li> <li><code>isBatchingUpdates</code>的判断，决定了是立刻渲染，还是等待，是一个全局的锁。默认是<code>false</code>，异步批量更新。</li> <li><code>isBatchingUpdates(true)</code> -&gt; <code>dirtyComponents</code></li> <li><code>isBatchingUpdates(false)</code> -&gt; 循环更新<code>dirtyComponents</code></li></ul> <h3 id="transaction-事务"><a href="#transaction-事务" class="header-anchor">#</a> transaction（事务）</h3> <ul><li>批量更新，就是一次事务的执行。</li></ul> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <ul><li><code>setState</code>的表现，会因为调用场景的不同而不同。</li> <li>在生命周期钩子函数及合成事件中，表现为异步。</li> <li>在<code>setTimeout</code>,<code>setInterval</code>, 原生DOM事件中，表现为同步。</li></ul> <h2 id="fiber"><a href="#fiber" class="header-anchor">#</a> Fiber</h2> <ul><li>浏览器是多线程的，包括处理DOM和UI的渲染。js是单线程，但是可以操作DOM。</li> <li>GUI渲染线程与JS线程是互斥的。渲染线程必须互斥，否则渲染结果难以预料。当一个线程执行的时候，另个一线程必须挂起。</li> <li>js中，事件被触发的时候，将由事件线程把它添加到任务队列末尾，等到js的同步代码执行完成后，在空闲时间执行出队。</li> <li>架构核心：可中断、可恢复、优先级。</li> <li>React 15流程：Reconciler -&gt; render</li> <li>React 16流程：Scheduler -&gt; Reconciler -&gt; render，多了一个更新优先级的调度。
<ul><li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler</li> <li>Reconciler（协调器）—— 负责找出变化的组件</li> <li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul></li> <li>每个更新任务，会被赋予一个优先级。</li> <li>Fiber架构是一种同时兼容同步渲染和异步渲染的设计。</li> <li>深度优先遍历。</li></ul> <h3 id="首次渲染"><a href="#首次渲染" class="header-anchor">#</a> 首次渲染</h3> <ul><li><code>ReactDOM.render</code>触发的首次渲染是同步过程。</li> <li>几种启动方式：
<ul><li><code>legacy模式</code>： <code>ReactDOM.render(&lt;App/&gt;, rootNode)</code>，当前版本的方式，同步渲染。</li> <li><code>blocking模式</code>： <code>ReactDOM.createBlockingRoot(rootNode).render(&lt;App/&gt;)</code>处于实验中，作为迁移到<code>concurrent模式</code>的一个步骤。</li> <li><code>concurrent模式</code>： <code>ReactDOM.createRoot(rootNode).render(&lt;App/&gt;)</code>, 开启异步渲染，目前也是在实验中，React的终极目标。</li></ul></li> <li><code>React 17</code>中可以开启<code>concurrent</code>异步渲染，但是是不稳定的，调用方式如下：<code>ReactDOM.unstable_createNode(rootNode)</code></li> <li>不同渲染模式在挂载阶段的差异，是由<code>mode</code>属性决定的。</li></ul> <h2 id="事件系统"><a href="#事件系统" class="header-anchor">#</a> 事件系统</h2> <ul><li>一个事件的传播要经过一下3个阶段：
<ul><li>事件捕获：事件从最外层向最内层传递，知道抵达目标元素。</li> <li>目标阶段：到达目标元素</li> <li>事件冒泡：从目标元素向外层传递。</li></ul></li> <li>在<code>React</code>里面，事件在具体的DOM节点上被触发后，都会冒泡到<code>document</code>上。<code>document</code>上所绑定的统一事件处理程序会将事件分发到具体组件实例。</li></ul> <h3 id="合成事件"><a href="#合成事件" class="header-anchor">#</a> 合成事件</h3> <ul><li>符合W3C规范，抹平了不同浏览器的差异。</li> <li>暴露统一、稳定的，与原生DOM事件相同的事件接口。</li> <li>可以通过<code>e.nativeEvent</code>访问到原生事件对象</li></ul> <h3 id="事件工作流"><a href="#事件工作流" class="header-anchor">#</a> 事件工作流</h3> <ul><li>事件绑定是在组件挂载时候完成。</li> <li>最后绑定到<code>document</code>上，统一的事件分发函数，<code>dispatchEvent</code>。事件触发本质，是对<code>dispatchEvent</code>的调用。</li> <li>整体流程：
<ul><li>事件触发、冒泡到<code>docuemnt</code></li> <li>执行<code>dispatchEvent</code></li> <li>创建事件对应的合成事件对象<code>SyntheticEvent</code></li> <li>收集事件在 <strong>捕获阶段</strong> 所涉及的回调函数和对应的节点实例。</li> <li>收集事件在 <strong>冒泡阶段</strong> 所涉及的回调函数和对应的节点实例。</li> <li>将前两步收集的回调按顺序执行，执行时<code>SyntheticEvent</code>作为入参传入每个回调中。</li></ul></li> <li>收集过程中，仅收集DOM元素对应的Fiber节点。</li> <li>对于 React 来讲，事件委托帮助其实现了对所有事件的中心化管控。</li></ul> <h2 id="redux-2"><a href="#redux-2" class="header-anchor">#</a> Redux</h2> <ul><li>是对 <code>Flux</code> 架构的一种实现，是单向数据流，一共包含四个方面：
<ul><li><code>View: 视图</code></li> <li><code>Action: 动作</code>，通过视图来触发</li> <li><code>Dispatcher: 派发器</code>，对<code>Action</code>进行分发；</li> <li><code>Store：数据层</code>, 存储应用状态，定义修改状态的逻辑。</li></ul></li> <li>简单描述其过程：用户与<code>View</code>产生交互，发起一个<code>action</code>, <code>dispatcher</code> 将<code>action</code> 派发给 <code>store</code>，通知 <code>store</code> 进行相应的状态更新，状态更新完成后通知 <code>view</code> 更新界面。</li> <li>Flux 允许多个 store，Redux 只允许一个。</li></ul> <h3 id="双向数据流的问题"><a href="#双向数据流的问题" class="header-anchor">#</a> 双向数据流的问题</h3> <ul><li>View 和 Model 可以直接通信。</li> <li>可能会比较混乱，因为 View 的更新可能来自 Model</li> <li>单向数据流的优点是：数据可预测。</li></ul> <h3 id="设计思想-2"><a href="#设计思想-2" class="header-anchor">#</a> 设计思想</h3> <ul><li><code>Store</code>: 一个单一的只读的数据源</li> <li><code>Action</code>: 对变化的描述</li> <li><code>Reducer</code>: 一个函数，对变化分发和处理，将新的数据返回给<code>Store</code>。<code>reducer</code> 是一个纯函数，接收旧的 <code>state</code> 和 <code>action</code>，返回新的 <code>state</code>。</li> <li>任何组件都可以从<code>Store</code>读取全局的状态，并派发<code>Action</code>来修改全局状态。</li></ul> <h3 id="工作原理"><a href="#工作原理" class="header-anchor">#</a> 工作原理</h3> <h4 id="createstore"><a href="#createstore" class="header-anchor">#</a> createStore</h4> <ul><li><code>getState</code>：获取当前的状态</li> <li><code>subscribe</code>: 订阅监听函数</li> <li><code>dispatch</code>: 派发action, 调用reducer触发订阅。</li></ul> <h4 id="dispatch"><a href="#dispatch" class="header-anchor">#</a> dispatch</h4> <ul><li>先将<code>isDispatching</code>变量设置为<code>true</code>，</li> <li>执行<code>reducer(state, action)</code></li> <li>执行完后，<code>isDispatching</code>设置为<code>false</code></li> <li>上锁的目的，是为了在执行<code>reducer</code>的时候，防止手动执行<code>dispatch</code>，<code>reducer</code>就不再是纯函数了，可能陷入死循环。</li></ul> <h4 id="触发订阅"><a href="#触发订阅" class="header-anchor">#</a> 触发订阅</h4> <ul><li>Redux 中，默认的订阅对象就是状态的变化。</li> <li>store对象创建后，通过调用<code>store.subscribe</code> 来注册监听函数，<code>dispatch</code> 发生时，在 <code>reducer</code> 执行完成后，将 listeners 数组中的监听函数逐个执行。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> listeners <span class="token operator">=</span> <span class="token punctuation">(</span>currentLisnteners <span class="token operator">=</span> nextListeners<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> listeners<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> listener <span class="token operator">=</span> listeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token function">listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 确保是两个数组</span>
<span class="token keyword">function</span> <span class="token function">ensureCanMutateNextListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>nextListeners <span class="token operator">===</span> currentLisnteners<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		nextListeners <span class="token operator">=</span> currentLisnteners<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>为什么有<code>currentLisnteners</code>和<code>nextListeners</code>两个数组？
<ul><li><code>currentLisnteners</code>用于确保监听函数执行过程的稳定性，而对注册事件监听的取消都是发生在<code>nextListeners</code>上，因此需要一个稳定的数组。</li> <li>事件监听注册后，会返回一个取消注册的函数。dispatch 的时候，可能会取消注册，可能会影响执行过程中的 listenrs 数组。因此不能使用同一份数组。</li></ul></li></ul> <h3 id="注意事项"><a href="#注意事项" class="header-anchor">#</a> 注意事项</h3> <ul><li>在<code>reducer</code>中，不能修改<code>state</code>，类似<code>Object.assign(state, {data: {}})</code>，这样会修改<code>state</code>。应该这样使用：<code>Object.assign({}, state, otherData)</code></li> <li>当管理的数据较多的时候，需要对<code>reducer</code>做拆分。每个 <code>reducer</code> 只负责管理全局 <code>state</code> 中它负责的一部分。每个 <code>reducer</code> 的 <code>state</code> 参数都不同，分别对应它管理的那部分 <code>state</code> 数据。</li> <li><code>reducer</code> 是纯函数。它仅用于计算下一个 <code>state</code>。它应该是完全可预测的：多次传入相同的输入必须产生相同的输出。它不应做有副作用的操作，如 <code>API</code> 调用或路由跳转。这些应该在 <code>dispatch action</code> 前发生。</li></ul> <h3 id="react-redux"><a href="#react-redux" class="header-anchor">#</a> react-redux</h3> <ul><li>容器组件就是使用 <code>store.subscribe()</code> 从 <code>Redux state</code> 树中读取部分数据，并通过 <code>props</code> 来把这些数据提供给要渲染的组件。直接使用<code>connect()</code>方法来生成容器。</li> <li>定义 <code>mapStateToProps</code> 函数来指定如何把当前 <code>state</code> 映射到组件的 <code>props</code> 中。</li> <li>定义 <code>mapDispatchToProps</code> 方法接收 <code>dispatch()</code> 方法并返回期望注入到展示组件的 <code>props</code> 中的回调方法。</li> <li>最后，调用<code>connect()</code>，与组件进行绑定。</li> <li>在最外层根组件中，使用<code>Provider</code>将根组件包裹。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> connect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-redux'</span>

<span class="token keyword">class</span> <span class="token class-name">DemoComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">const</span> Demo <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span>
  mapStateToProps<span class="token punctuation">,</span>
  mapDispatchToProps
<span class="token punctuation">)</span><span class="token punctuation">(</span>DemoComponent<span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> Demo
</code></pre></div><h4 id="异步action"><a href="#异步action" class="header-anchor">#</a> 异步action</h4> <ul><li>引入<code>redux-thunk</code>，<code>action</code>函数除了返回action对象外，还可以返回函数。</li> <li>当 <code>action</code> 创建函数返回函数时，这个函数会被 <code>Redux Thunk</code> 执行。这个函数不需要保持纯净；它还可以带有副作用，包括执行异步 API 请求，还可以 <code>dispatch action</code></li> <li>通过<code>applyMiddleware()</code>来使用<code>redux-chunk</code>中间件。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> thunkMiddleware <span class="token keyword">from</span> <span class="token string">'redux-thunk'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createLogger <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'redux-logger'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createStore<span class="token punctuation">,</span> applyMiddleware <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'redux'</span>

<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span>
  <span class="token operator">...</span><span class="token punctuation">,</span>
  <span class="token function">applyMiddleware</span><span class="token punctuation">(</span>
    thunkMiddleware<span class="token punctuation">,</span> <span class="token comment">// 允许我们 dispatch() 函数</span>
    loggerMiddleware <span class="token comment">// 用来打印 action 日志</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre></div><h4 id="其他方式"><a href="#其他方式" class="header-anchor">#</a> 其他方式</h4> <ul><li>使用 redux-promise 或者 redux-promise-middleware 来 dispatch Promise 来替代函数。</li> <li>使用 redux-observable 来 dispatch Observable。</li> <li>使用 redux-saga 中间件来创建更加复杂的异步 action。</li> <li>使用 redux-pack 中间件 dispatch 基于 Promise 的异步 Action。</li></ul> <h2 id="优化技巧"><a href="#优化技巧" class="header-anchor">#</a> 优化技巧</h2> <h3 id="purecomponent、react-memo"><a href="#purecomponent、react-memo" class="header-anchor">#</a> PureComponent、React.memo</h3> <ul><li>如果父组件发生状态更新，及时父组件传给子组件的<code>props</code>没有修改，也会引起子组件的渲染。</li> <li><code>PureComponent</code>是对类组件的 <code>Props</code> 和 <code>State</code> 进行浅比较，如果没有变化，则不会渲染组件。</li> <li><code>React.memo</code> 是对函数组件的 Props 进行浅比较。</li></ul> <h3 id="shouldcomponentupdate"><a href="#shouldcomponentupdate" class="header-anchor">#</a> shouldComponentUpdate</h3> <ul><li>使用<code>shouldComponentUpdate</code>会存在一些隐患。如果存在很多子孙组件，「找出所有子孙组件使用的属性」就会有很多工作量，也容易因为遗漏导致 bug，且会带来一定的维护成本。</li></ul> <h3 id="usememo、usecallback"><a href="#usememo、usecallback" class="header-anchor">#</a> useMemo、useCallback</h3> <ul><li>子组件接收的函数或<code>props</code>，每次都是新的引用，那么<code>PureComponent</code> 和 <code>React.memo</code> 优化就会失效。需要使用 <code>useMemo</code> 和 <code>useCallback</code> 来生成稳定值，并结合 <code>PureComponent</code> 或 <code>React.memo</code> 避免子组件重新 Render。</li> <li><code>useCallback</code> 是基于 <code>useMemo</code> 实现的，只是针对缓存函数。</li> <li><code>useMemo</code> 用于非常耗时的计算场景。</li></ul> <h3 id="节流、防抖"><a href="#节流、防抖" class="header-anchor">#</a> 节流、防抖</h3> <ul><li>节流，可以想象为水龙头放水，不能一直放任其流水，为了节约用水，改成每隔固定的间隔滴水。无论规定时间内，事件有无触发，都会按照固定频率触发。比如滚动时候，请求数据。窗口拖动时候，resize 事件。</li> <li>防抖，频繁触发的动作，在 n 秒内只执行一次。输入框不断的输入值，使用防抖节约请求。频繁点赞和取消，仅需获取最后一次的操作结果传递给服务端。</li></ul></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/study/react_note.html#fiber机制" class="sidebar-link reco-side-fiber机制" data-v-b57cc07c>fiber机制</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#废弃的api" class="sidebar-link reco-side-废弃的api" data-v-b57cc07c>废弃的API</a></li><li class="level-2" data-v-b57cc07c><a href="/study/react_note.html#数据传递" class="sidebar-link reco-side-数据传递" data-v-b57cc07c>数据传递</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#props" class="sidebar-link reco-side-props" data-v-b57cc07c>props</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#发布订阅模式" class="sidebar-link reco-side-发布订阅模式" data-v-b57cc07c>发布订阅模式</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#context-api" class="sidebar-link reco-side-context-api" data-v-b57cc07c>Context API</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#redux" class="sidebar-link reco-side-redux" data-v-b57cc07c>Redux</a></li><li class="level-2" data-v-b57cc07c><a href="/study/react_note.html#函数组件与类组件对比" class="sidebar-link reco-side-函数组件与类组件对比" data-v-b57cc07c>函数组件与类组件对比</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#类组件" class="sidebar-link reco-side-类组件" data-v-b57cc07c>类组件</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#函数组件" class="sidebar-link reco-side-函数组件" data-v-b57cc07c>函数组件</a></li><li class="level-2" data-v-b57cc07c><a href="/study/react_note.html#react-hooks" class="sidebar-link reco-side-react-hooks" data-v-b57cc07c>React Hooks</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#使用原则" class="sidebar-link reco-side-使用原则" data-v-b57cc07c>使用原则</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#底层实现" class="sidebar-link reco-side-底层实现" data-v-b57cc07c>底层实现</a></li><li class="level-2" data-v-b57cc07c><a href="/study/react_note.html#虚拟dom" class="sidebar-link reco-side-虚拟dom" data-v-b57cc07c>虚拟DOM</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#原始的方案" class="sidebar-link reco-side-原始的方案" data-v-b57cc07c>原始的方案</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#为什么要使用虚拟dom" class="sidebar-link reco-side-为什么要使用虚拟dom" data-v-b57cc07c>为什么要使用虚拟DOM</a></li><li class="level-2" data-v-b57cc07c><a href="/study/react_note.html#diff-算法" class="sidebar-link reco-side-diff-算法" data-v-b57cc07c>diff 算法</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#设计思想" class="sidebar-link reco-side-设计思想" data-v-b57cc07c>设计思想</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#reconciler" class="sidebar-link reco-side-reconciler" data-v-b57cc07c>Reconciler</a></li><li class="level-2" data-v-b57cc07c><a href="/study/react_note.html#setstate" class="sidebar-link reco-side-setstate" data-v-b57cc07c>setState</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#工作流程" class="sidebar-link reco-side-工作流程" data-v-b57cc07c>工作流程</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#transaction-事务" class="sidebar-link reco-side-transaction-事务" data-v-b57cc07c>transaction（事务）</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#总结" class="sidebar-link reco-side-总结" data-v-b57cc07c>总结</a></li><li class="level-2" data-v-b57cc07c><a href="/study/react_note.html#fiber" class="sidebar-link reco-side-fiber" data-v-b57cc07c>Fiber</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#首次渲染" class="sidebar-link reco-side-首次渲染" data-v-b57cc07c>首次渲染</a></li><li class="level-2" data-v-b57cc07c><a href="/study/react_note.html#事件系统" class="sidebar-link reco-side-事件系统" data-v-b57cc07c>事件系统</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#合成事件" class="sidebar-link reco-side-合成事件" data-v-b57cc07c>合成事件</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#事件工作流" class="sidebar-link reco-side-事件工作流" data-v-b57cc07c>事件工作流</a></li><li class="level-2" data-v-b57cc07c><a href="/study/react_note.html#redux-2" class="sidebar-link reco-side-redux-2" data-v-b57cc07c>Redux</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#双向数据流的问题" class="sidebar-link reco-side-双向数据流的问题" data-v-b57cc07c>双向数据流的问题</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#设计思想-2" class="sidebar-link reco-side-设计思想-2" data-v-b57cc07c>设计思想</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#工作原理" class="sidebar-link reco-side-工作原理" data-v-b57cc07c>工作原理</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#注意事项" class="sidebar-link reco-side-注意事项" data-v-b57cc07c>注意事项</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#react-redux" class="sidebar-link reco-side-react-redux" data-v-b57cc07c>react-redux</a></li><li class="level-2" data-v-b57cc07c><a href="/study/react_note.html#优化技巧" class="sidebar-link reco-side-优化技巧" data-v-b57cc07c>优化技巧</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#purecomponent、react-memo" class="sidebar-link reco-side-purecomponent、react-memo" data-v-b57cc07c>PureComponent、React.memo</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#shouldcomponentupdate" class="sidebar-link reco-side-shouldcomponentupdate" data-v-b57cc07c>shouldComponentUpdate</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#usememo、usecallback" class="sidebar-link reco-side-usememo、usecallback" data-v-b57cc07c>useMemo、useCallback</a></li><li class="level-3" data-v-b57cc07c><a href="/study/react_note.html#节流、防抖" class="sidebar-link reco-side-节流、防抖" data-v-b57cc07c>节流、防抖</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.d7400715.js" defer></script><script src="/assets/js/3.ea6371c1.js" defer></script><script src="/assets/js/1.51666839.js" defer></script><script src="/assets/js/105.1374d1fe.js" defer></script>
  </body>
</html>
