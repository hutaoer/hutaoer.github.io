<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React 知识链路梳理 | 逗逼码农</title>
    <meta name="generator" content="VuePress 1.8.2">
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?97584138af9a81f074d821256641e300";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    <meta name="description" content="持续提升，降低欲望；乐观幽默，自律坦然">
    
    <link rel="preload" href="/assets/css/0.styles.35bcedcf.css" as="style"><link rel="preload" href="/assets/js/app.5ddec74e.js" as="script"><link rel="preload" href="/assets/js/2.dc0afc93.js" as="script"><link rel="preload" href="/assets/js/50.8136119e.js" as="script"><link rel="prefetch" href="/assets/js/10.ad4c898c.js"><link rel="prefetch" href="/assets/js/11.2dcf0b32.js"><link rel="prefetch" href="/assets/js/12.0c710abb.js"><link rel="prefetch" href="/assets/js/13.19356a78.js"><link rel="prefetch" href="/assets/js/14.5a219323.js"><link rel="prefetch" href="/assets/js/15.4c057cfb.js"><link rel="prefetch" href="/assets/js/16.152605de.js"><link rel="prefetch" href="/assets/js/17.d5bff695.js"><link rel="prefetch" href="/assets/js/18.81f38f9b.js"><link rel="prefetch" href="/assets/js/19.340aed85.js"><link rel="prefetch" href="/assets/js/20.f0651e91.js"><link rel="prefetch" href="/assets/js/21.b9b97edf.js"><link rel="prefetch" href="/assets/js/22.8772e325.js"><link rel="prefetch" href="/assets/js/23.79e252fc.js"><link rel="prefetch" href="/assets/js/24.aaf1f29d.js"><link rel="prefetch" href="/assets/js/25.c849d65d.js"><link rel="prefetch" href="/assets/js/26.d20b9177.js"><link rel="prefetch" href="/assets/js/27.b926550d.js"><link rel="prefetch" href="/assets/js/28.43a43bcf.js"><link rel="prefetch" href="/assets/js/29.804182d6.js"><link rel="prefetch" href="/assets/js/3.4d1b1a3e.js"><link rel="prefetch" href="/assets/js/30.f2eb8d94.js"><link rel="prefetch" href="/assets/js/31.e90d7b4c.js"><link rel="prefetch" href="/assets/js/32.1cd900b9.js"><link rel="prefetch" href="/assets/js/33.93d4972c.js"><link rel="prefetch" href="/assets/js/34.cd10d381.js"><link rel="prefetch" href="/assets/js/35.72bd2bc1.js"><link rel="prefetch" href="/assets/js/36.8d4b15b4.js"><link rel="prefetch" href="/assets/js/37.db0066f9.js"><link rel="prefetch" href="/assets/js/38.3735c80e.js"><link rel="prefetch" href="/assets/js/39.637c5350.js"><link rel="prefetch" href="/assets/js/4.c610d016.js"><link rel="prefetch" href="/assets/js/40.80d8ed89.js"><link rel="prefetch" href="/assets/js/41.a1b15bd3.js"><link rel="prefetch" href="/assets/js/42.b7200451.js"><link rel="prefetch" href="/assets/js/43.ff9e6ea7.js"><link rel="prefetch" href="/assets/js/44.5c41c009.js"><link rel="prefetch" href="/assets/js/45.acdcdc19.js"><link rel="prefetch" href="/assets/js/46.7731a6a1.js"><link rel="prefetch" href="/assets/js/47.e30e5223.js"><link rel="prefetch" href="/assets/js/48.06bc1f8f.js"><link rel="prefetch" href="/assets/js/49.1c9abae2.js"><link rel="prefetch" href="/assets/js/5.26471bd2.js"><link rel="prefetch" href="/assets/js/51.3fecf450.js"><link rel="prefetch" href="/assets/js/52.f62b3b40.js"><link rel="prefetch" href="/assets/js/53.0a42570b.js"><link rel="prefetch" href="/assets/js/54.256f6837.js"><link rel="prefetch" href="/assets/js/55.e9c4cbe7.js"><link rel="prefetch" href="/assets/js/56.004a078f.js"><link rel="prefetch" href="/assets/js/57.f574462a.js"><link rel="prefetch" href="/assets/js/58.acdba453.js"><link rel="prefetch" href="/assets/js/59.d1c6403b.js"><link rel="prefetch" href="/assets/js/6.66b67ff0.js"><link rel="prefetch" href="/assets/js/60.4b6260de.js"><link rel="prefetch" href="/assets/js/61.cd534cbc.js"><link rel="prefetch" href="/assets/js/62.0d160b2d.js"><link rel="prefetch" href="/assets/js/63.3f5e29f1.js"><link rel="prefetch" href="/assets/js/64.c495ff69.js"><link rel="prefetch" href="/assets/js/65.a2681e68.js"><link rel="prefetch" href="/assets/js/66.51f0a5c4.js"><link rel="prefetch" href="/assets/js/67.a4e50e62.js"><link rel="prefetch" href="/assets/js/68.019c3d97.js"><link rel="prefetch" href="/assets/js/69.528b3503.js"><link rel="prefetch" href="/assets/js/7.695c93bc.js"><link rel="prefetch" href="/assets/js/8.862ad8bf.js"><link rel="prefetch" href="/assets/js/9.55491c9a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35bcedcf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">逗逼码农</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://www.cnblogs.com/hutaoer/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  旧的博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/hutaoer" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://www.cnblogs.com/hutaoer/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  旧的博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/hutaoer" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React 知识链路梳理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/react_note.html#fiber机制" class="sidebar-link">fiber机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/react_note.html#废弃的api" class="sidebar-link">废弃的API</a></li></ul></li><li><a href="/study/react_note.html#数据传递" class="sidebar-link">数据传递</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/react_note.html#props" class="sidebar-link">props</a></li><li class="sidebar-sub-header"><a href="/study/react_note.html#发布订阅模式" class="sidebar-link">发布订阅模式</a></li><li class="sidebar-sub-header"><a href="/study/react_note.html#context-api" class="sidebar-link">Context API</a></li><li class="sidebar-sub-header"><a href="/study/react_note.html#redux" class="sidebar-link">Redux</a></li></ul></li><li><a href="/study/react_note.html#函数组件与类组件对比" class="sidebar-link">函数组件与类组件对比</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/react_note.html#类组件" class="sidebar-link">类组件</a></li><li class="sidebar-sub-header"><a href="/study/react_note.html#函数组件" class="sidebar-link">函数组件</a></li></ul></li><li><a href="/study/react_note.html#react-hooks" class="sidebar-link">React Hooks</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/react_note.html#使用原则" class="sidebar-link">使用原则</a></li><li class="sidebar-sub-header"><a href="/study/react_note.html#底层实现" class="sidebar-link">底层实现</a></li></ul></li><li><a href="/study/react_note.html#虚拟dom" class="sidebar-link">虚拟DOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/react_note.html#原始的方案" class="sidebar-link">原始的方案</a></li><li class="sidebar-sub-header"><a href="/study/react_note.html#为什么要使用虚拟dom" class="sidebar-link">为什么要使用虚拟DOM</a></li></ul></li><li><a href="/study/react_note.html#diff-算法" class="sidebar-link">diff 算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/react_note.html#设计思想" class="sidebar-link">设计思想</a></li><li class="sidebar-sub-header"><a href="/study/react_note.html#reconciler" class="sidebar-link">Reconciler</a></li></ul></li><li><a href="/study/react_note.html#setstate" class="sidebar-link">setState</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/react_note.html#工作流程" class="sidebar-link">工作流程</a></li><li class="sidebar-sub-header"><a href="/study/react_note.html#transaction-事务" class="sidebar-link">transaction（事务）</a></li><li class="sidebar-sub-header"><a href="/study/react_note.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/study/react_note.html#fiber" class="sidebar-link">Fiber</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/react_note.html#首次渲染" class="sidebar-link">首次渲染</a></li></ul></li><li><a href="/study/react_note.html#事件系统" class="sidebar-link">事件系统</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/react_note.html#合成事件" class="sidebar-link">合成事件</a></li><li class="sidebar-sub-header"><a href="/study/react_note.html#事件工作流" class="sidebar-link">事件工作流</a></li></ul></li><li><a href="/study/react_note.html#redux-2" class="sidebar-link">Redux</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/react_note.html#双向数据流的问题" class="sidebar-link">双向数据流的问题</a></li><li class="sidebar-sub-header"><a href="/study/react_note.html#设计思想-2" class="sidebar-link">设计思想</a></li><li class="sidebar-sub-header"><a href="/study/react_note.html#工作原理" class="sidebar-link">工作原理</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react-知识链路梳理"><a href="#react-知识链路梳理" class="header-anchor">#</a> React 知识链路梳理</h1> <h2 id="fiber机制"><a href="#fiber机制" class="header-anchor">#</a> fiber机制</h2> <ul><li>render 阶段是允许暂停、终止和重启的。</li> <li>render 阶段的生命周期都可能是被重复执行的。</li></ul> <h3 id="废弃的api"><a href="#废弃的api" class="header-anchor">#</a> 废弃的API</h3> <ul><li>废弃的API有：<code>componentWillMount</code>,<code>componentWillUpdate</code>,<code>componentWillReceiveProps</code>，都是处于render阶段，可能被重复执行的。</li> <li>这些API使用不推荐的操作：
<ul><li>在<code>componentWillMount</code>中，请求数据，应该放到<code>componentDidMount</code>中。首屏渲染依然会在数据返回之前执行。</li> <li><code>componentWillUpdate</code>和<code>componentWillReceiveProps</code>中滥用<code>setState</code>导致死循环。</li></ul></li> <li>fiber异步渲染机制下，可能导致的bug:
<ul><li>由于render阶段，生命周期可以重复执行，<code>componentWillMount</code>被打断、重复多次后，可能会发出多个请求。</li></ul></li> <li>新的生命周期：<code>getDerivedStateFromProps</code>是静态方法，不能访问<code>this</code></li> <li>React 16 改造生命周期的动机是为了配合 fiber 架构带来的异步渲染机制。</li></ul> <h2 id="数据传递"><a href="#数据传递" class="header-anchor">#</a> 数据传递</h2> <ul><li><code>UI = render(data)</code>, 视图会随着数据变化而变化。</li></ul> <h3 id="props"><a href="#props" class="header-anchor">#</a> props</h3> <ul><li>基于<code>props</code>的单向数据流，当前组件的<code>state</code>以<code>props</code>的形式流动时，只能流向组件树中比自己层级更低的组件。<code>props</code>传参适用于
<ul><li>父子间的组件通信</li> <li>兄弟组件间的数据通信</li> <li>其他场景，不推荐，不如超过了两层关系传递数据。</li></ul></li> <li>父组件的更新，都会触发子组件<code>componentWillReceiveProps</code>，而不仅仅是传入的<code>props</code>发生改变。</li></ul> <h3 id="发布订阅模式"><a href="#发布订阅模式" class="header-anchor">#</a> 发布订阅模式</h3> <ul><li>常见的有：<code>socket.io</code>, <code>Node.js</code>中的<code>EventEmitter</code>，<code>Vue.js</code>中的<code>EventBus</code></li> <li><code>target.addEventListener(type, listener, useCapture</code> 创建事件监听器</li> <li>监听位置和触发事件的位置不受限制。事件的监听即订阅，事件的触发即发布。</li> <li>使用发布订阅模式，可以在任意的组件间进行通信。</li></ul> <h3 id="context-api"><a href="#context-api" class="header-anchor">#</a> Context API</h3> <ul><li>16.3 版本后，新的<code>context API</code>，即使组件的<code>shouldComponentUpdate</code>返回<code>false</code>,它依然可以穿透组件，向子组件进行传播。</li></ul> <h3 id="redux"><a href="#redux" class="header-anchor">#</a> Redux</h3> <ul><li>Redux是js的状态容器。由三部分组成：<code>store</code>,<code>action</code>,<code>reducer</code>,<code>redux</code>工作流程中，数据是严格单向的。</li> <li><code>store</code>是单一的数据源，只读。</li> <li><code>action</code>是对变化的描述，包含<code>type</code>和<code>payload</code></li> <li>使用<code>dispatch</code>来派发<code>action</code>,<code>store.dispatch(action)</code>, <code>action</code>会进入到<code>reducer</code>触发对应的更新。</li> <li><code>reducer</code>纯函数，对变化进行分发和处理，返回新的数据给<code>store</code></li></ul> <h2 id="函数组件与类组件对比"><a href="#函数组件与类组件对比" class="header-anchor">#</a> 函数组件与类组件对比</h2> <ul><li>类组件需要继承，函数组件不需要</li> <li>类组件可以访问生命周期方法，函数组件不可以</li> <li>类组件中可以获取实例化后的this，然后可以调用各种实例方法，有生命周期钩子。</li> <li>类组件中有state状态，函数组件没有。</li></ul> <h3 id="类组件"><a href="#类组件" class="header-anchor">#</a> 类组件</h3> <ul><li>是基于面向对象的一种封装，提供了各种钩子函数，但对于一些简单的场景，类组件的实现有些复杂。</li> <li>类组件的内部逻辑难以拆分和复用</li> <li>面向对象编程思想。</li></ul> <h3 id="函数组件"><a href="#函数组件" class="header-anchor">#</a> 函数组件</h3> <ul><li>轻量、灵活。</li> <li>函数组件会捕获<code>render</code>内部的状态，这是与类组件最大的不同。</li> <li>函数式编程思想。</li></ul> <h2 id="react-hooks"><a href="#react-hooks" class="header-anchor">#</a> React Hooks</h2> <ul><li>16.8 版本开始推广的。</li></ul> <h3 id="使用原则"><a href="#使用原则" class="header-anchor">#</a> 使用原则</h3> <ul><li>只在React 函数中使用 Hook</li> <li>不要在循环、条件或嵌套中使用 Hook</li></ul> <h3 id="底层实现"><a href="#底层实现" class="header-anchor">#</a> 底层实现</h3> <ul><li>依赖于顺序链表，<code>hooks</code>的本质是链表。所有的hook是通过单向链表存储的，每个<code>hook</code>是一个对象。</li> <li>首次渲染的时候，调用<code>moutState</code>构建链表并渲染</li> <li>二次渲染的时候，调用<code>updateState</code>一次遍历链表并渲染。</li> <li>hooks的渲染是通过<code>依次遍历</code>来定位每个hook的内容的。如果前后两次读到的链表在顺序上的位置不一样，那么渲染就会出现问题。</li></ul> <h2 id="虚拟dom"><a href="#虚拟dom" class="header-anchor">#</a> 虚拟DOM</h2> <ul><li>本质上是<code>js</code>和<code>DOM</code>之间的一个映射缓存，一个能描述<code>DOM</code>结构和属性的js对象。</li> <li>简单来讲，虚拟DOM是一个js对象，是对真实DOM的描述。</li> <li>挂载阶段：通过<code>JSX</code>，构建出虚拟DOM树，然后通过<code>ReactDOM.render</code>实现虚拟DOM到真实DOM的映射。</li> <li>更新阶段：页面的变化，会先作用于虚拟DOM，虚拟DOM借助diff算法，对比出需要改变的DOM，然后将这些改变作用于真实DOM。</li></ul> <h3 id="原始的方案"><a href="#原始的方案" class="header-anchor">#</a> 原始的方案</h3> <ul><li>原生对DOM操作，比较繁琐。</li> <li>jQuery，解决浏览器兼容性，API更人性化，链式调用。</li> <li>模板引擎，拼接DOM。没有缓存，更新的时候，性能存在瓶颈。</li> <li>使用虚拟DOM，更多的考虑是在于开发体验和研发效率，虚拟DOM不一定回带来更高的渲染效率。</li> <li>模板渲染过程：动态生成HTML字符串 -&gt; 旧的DOM元素整体被替换为新的DOM元素（全量更新）</li> <li>虚拟DOM渲染过程：构建新的虚拟DOM树 -&gt; 通过diff对比出新旧两个树的差异 -&gt; 差量更新DOM</li></ul> <h3 id="为什么要使用虚拟dom"><a href="#为什么要使用虚拟dom" class="header-anchor">#</a> 为什么要使用虚拟DOM</h3> <ul><li>模板引擎和虚拟DOM存在着递进的关系。</li> <li>解决了研发体验、研发效率、和跨平台的问题。</li> <li>解决跨平台问题：同一套虚拟DOM可以映射为不同平台的渲染元素。</li></ul> <h2 id="diff-算法"><a href="#diff-算法" class="header-anchor">#</a> diff 算法</h2> <ul><li>调和不等同于diff.</li> <li>React 15 使用的是 <code>Stack Reconciler</code>，同步递归，不可被打断。如果嵌套节点层级很深，递归的过程时间会很长，导致js长时间的占用主线程，从而导致页面的渲染卡顿。</li> <li>React 16 使用的是 <code>Fiber</code>。从架构来看，是对React核心算法重写；从编码来看，是React内部定义的一种数据结构，是虚拟节点；从工作流来看，Fiber节点保存了组件更新的状态和副作用。</li></ul> <h3 id="设计思想"><a href="#设计思想" class="header-anchor">#</a> 设计思想</h3> <ul><li>若两个组件属于同一个类型，它们拥有一样的DOM树形结构</li> <li>同一层级的一组子节点，可以通过设置<code>key</code>作为唯一标识，来维持各个节点在不同渲染过程中的稳定性。</li> <li>diff的关键点：1. 递归的进行分层对比；2. 必须是类型一致的节点；3. key属性设置，利于对节点的复用。</li></ul> <h3 id="reconciler"><a href="#reconciler" class="header-anchor">#</a> Reconciler</h3> <ul><li><code>Reconciler</code>中文意思是”调和器“</li> <li>虚拟DOM保存在内存中，通过<code>ReactDOM</code>等类库的作用，使之与真实的DOM同步，这个过程称之为协调（调和）。</li> <li>简单讲：就是将虚拟DOM转变为真实DOM的过程。</li> <li>调和器的工作：组件的挂载、卸载、更新等等。</li></ul> <h2 id="setstate"><a href="#setstate" class="header-anchor">#</a> setState</h2> <ul><li>为了避免频繁的二次渲染，setState 有异步更新、批量更新的机制。每次调用<code>setState</code>，将<code>state</code>缓存起来，在合适的时机，将<code>state</code>做合并，针对最新的<code>state</code>做更新渲染。</li> <li><code>setTimout</code> 可以帮助<code>setState</code> 脱离<code>React</code>的管控，从而变成同步的。一般而言，React管控下的<code>setState</code>一定是异步的。</li> <li><code>setState</code>并不是具备同步渲染的特性，而是在特定的场景下，比如在<code>setTimout</code>的回调中的时候，<code>isBatchingUpdates</code>的值，就是<code>false</code>，所以就变成了同步更新。</li></ul> <h3 id="工作流程"><a href="#工作流程" class="header-anchor">#</a> 工作流程</h3> <ul><li><code>setState</code> -&gt; <code>enqueueSetState</code> -&gt; <code>enqueueUpState</code> -&gt; <code>isBatchingUpdates??</code></li> <li><code>isBatchingUpdates</code>的判断，决定了是立刻渲染，还是等待，是一个全局的锁。默认是<code>false</code>，异步批量更新。</li> <li><code>isBatchingUpdates(true)</code> -&gt; <code>dirtyComponents</code></li> <li><code>isBatchingUpdates(false)</code> -&gt; 循环更新<code>dirtyComponents</code></li></ul> <h3 id="transaction-事务"><a href="#transaction-事务" class="header-anchor">#</a> transaction（事务）</h3> <ul><li>批量更新，就是一次事务的执行。</li></ul> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <ul><li><code>setState</code>的表现，会因为调用场景的不同而不同。</li> <li>在生命周期钩子函数及合成事件中，表现为异步。</li> <li>在<code>setTimeout</code>,<code>setInterval</code>, 原生DOM事件中，表现为同步。</li></ul> <h2 id="fiber"><a href="#fiber" class="header-anchor">#</a> Fiber</h2> <ul><li>浏览器是多线程的，包括处理DOM和UI的渲染。js是单线程，但是可以操作DOM。</li> <li>GUI渲染线程与JS线程是互斥的。渲染线程必须互斥，否则渲染结果难以预料。当一个线程执行的时候，另个一线程必须挂起。</li> <li>js中，事件被触发的时候，将由事件线程把它添加到任务队列末尾，等到js的同步代码执行完成后，在空闲时间执行出队。</li> <li>架构核心：可中断、可恢复、优先级。</li> <li>React 15流程：Reconciler -&gt; render</li> <li>React 16流程：Scheduler -&gt; Reconciler -&gt; render，多了一个更新优先级的调度。
<ul><li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler</li> <li>Reconciler（协调器）—— 负责找出变化的组件</li> <li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul></li> <li>每个更新任务，会被赋予一个优先级。</li> <li>Fiber架构是一种同时兼容同步渲染和异步渲染的设计。</li> <li>深度优先遍历。</li></ul> <h3 id="首次渲染"><a href="#首次渲染" class="header-anchor">#</a> 首次渲染</h3> <ul><li><code>ReactDOM.render</code>触发的首次渲染是同步过程。</li> <li>几种启动方式：
<ul><li><code>legacy模式</code>： <code>ReactDOM.render(&lt;App/&gt;, rootNode)</code>，当前版本的方式，同步渲染。</li> <li><code>blocking模式</code>： <code>ReactDOM.createBlockingRoot(rootNode).render(&lt;App/&gt;)</code>处于实验中，作为迁移到<code>concurrent模式</code>的一个步骤。</li> <li><code>concurrent模式</code>： <code>ReactDOM.createRoot(rootNode).render(&lt;App/&gt;)</code>, 开启异步渲染，目前也是在实验中，React的终极目标。</li></ul></li> <li><code>React 17</code>中可以开启<code>concurrent</code>异步渲染，但是是不稳定的，调用方式如下：<code>ReactDOM.unstable_createNode(rootNode)</code></li> <li>不同渲染模式在挂载阶段的差异，是由<code>mode</code>属性决定的。</li></ul> <h2 id="事件系统"><a href="#事件系统" class="header-anchor">#</a> 事件系统</h2> <ul><li>一个事件的传播要经过一下3个阶段：
<ul><li>事件捕获：事件从最外层向最内层传递，知道抵达目标元素。</li> <li>目标阶段：到达目标元素</li> <li>事件冒泡：从目标元素向外层传递。</li></ul></li> <li>在<code>React</code>里面，事件在具体的DOM节点上被触发后，都会冒泡到<code>document</code>上。<code>document</code>上所绑定的统一事件处理程序会将事件分发到具体组件实例。</li></ul> <h3 id="合成事件"><a href="#合成事件" class="header-anchor">#</a> 合成事件</h3> <ul><li>符合W3C规范，抹平了不同浏览器的差异。</li> <li>暴露统一、稳定的，与原生DOM事件相同的事件接口。</li> <li>可以通过<code>e.nativeEvent</code>访问到原生事件对象</li></ul> <h3 id="事件工作流"><a href="#事件工作流" class="header-anchor">#</a> 事件工作流</h3> <ul><li>事件绑定是在组件挂载时候完成。</li> <li>最后绑定到<code>document</code>上，统一的事件分发函数，<code>dispatchEvent</code>。事件触发本质，是对<code>dispatchEvent</code>的调用。</li> <li>整体流程：
<ul><li>事件触发、冒泡到<code>docuemnt</code></li> <li>执行<code>dispatchEvent</code></li> <li>创建事件对应的合成事件对象<code>SyntheticEvent</code></li> <li>收集事件在 <strong>捕获阶段</strong> 所涉及的回调函数和对应的节点实例。</li> <li>收集事件在 <strong>冒泡阶段</strong> 所涉及的回调函数和对应的节点实例。</li> <li>将前两步收集的回调按顺序执行，执行时<code>SyntheticEvent</code>作为入参传入每个回调中。</li></ul></li> <li>收集过程中，仅收集DOM元素对应的Fiber节点。</li> <li>对于 React 来讲，事件委托帮助其实现了对所有事件的中心化管控。</li></ul> <h2 id="redux-2"><a href="#redux-2" class="header-anchor">#</a> Redux</h2> <ul><li>是对 <code>Flux</code> 架构的一种实现，是单向数据流，一共包含四个方面：
<ul><li><code>View: 视图</code></li> <li><code>Action: 动作</code>，通过视图来触发</li> <li><code>Dispatcher: 派发器</code>，对<code>Action</code>进行分发；</li> <li><code>Store：数据层</code>, 存储应用状态，定义修改状态的逻辑。</li></ul></li> <li>简单描述其过程：用户与<code>View</code>产生交互，发起一个<code>action</code>, <code>dispatcher</code> 将<code>action</code> 派发给 <code>store</code>，通知 <code>store</code> 进行相应的状态更新，状态更新完成后通知 <code>view</code> 更新界面。</li> <li>Flux 允许多个 store，Redux 只允许一个。</li></ul> <h3 id="双向数据流的问题"><a href="#双向数据流的问题" class="header-anchor">#</a> 双向数据流的问题</h3> <ul><li>View 和 Model 可以直接通信。</li> <li>可能会比较混乱，因为 View 的更新可能来自 Model</li> <li>单向数据流的优点是：数据可预测。</li></ul> <h3 id="设计思想-2"><a href="#设计思想-2" class="header-anchor">#</a> 设计思想</h3> <ul><li><code>Store</code>: 一个单一的只读的数据源</li> <li><code>Action</code>: 对变化的描述</li> <li><code>Reducer</code>: 一个函数，对变化分发和处理，将新的数据返回给<code>Store</code></li> <li>任何组件都可以从<code>Store</code>读取全局的状态，并派发<code>Action</code>来修改全局状态。</li></ul> <h3 id="工作原理"><a href="#工作原理" class="header-anchor">#</a> 工作原理</h3> <h4 id="createstore"><a href="#createstore" class="header-anchor">#</a> createStore</h4> <ul><li><code>getState</code>：获取当前的状态</li> <li><code>subscribe</code>: 订阅监听函数</li> <li><code>dispatch</code>: 派发action, 调用reducer触发订阅。</li></ul> <h4 id="dispatch"><a href="#dispatch" class="header-anchor">#</a> dispatch</h4> <ul><li>先将<code>isDispatching</code>变量设置为<code>true</code>，</li> <li>执行<code>reducer(state, action)</code></li> <li>执行完后，<code>isDispatching</code>设置为<code>false</code></li> <li>上锁的目的，是为了在执行<code>reducer</code>的时候，防止手动执行<code>dispatch</code>，<code>reducer</code>就不再是纯函数了，可能陷入死循环。</li></ul> <h4 id="触发订阅"><a href="#触发订阅" class="header-anchor">#</a> 触发订阅</h4> <ul><li>Redux 中，默认的订阅对象就是状态的变化。</li> <li>store对象创建后，通过调用store.subscribe 来注册监听函数，dispatch 发生时，在 reducer 执行完成后，将 listeners 数组中的监听函数逐个执行。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> listeners <span class="token operator">=</span> <span class="token punctuation">(</span>currentLisnteners <span class="token operator">=</span> nextListeners<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> listeners<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> listener <span class="token operator">=</span> listeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token function">listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 确保是两个数组</span>
<span class="token keyword">function</span> <span class="token function">ensureCanMutateNextListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>nextListeners <span class="token operator">===</span> currentLisnteners<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		nextListeners <span class="token operator">=</span> currentLisnteners<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>为什么有<code>currentLisnteners</code>和<code>nextListeners</code>两个数组？
<ul><li><code>currentLisnteners</code>用于确保监听函数执行过程的稳定性，而对注册事件监听的取消都是发生在<code>nextListeners</code>上，因此需要一个稳定的数组。</li> <li>事件监听注册后，会返回一个取消注册的函数。dispatch 的时候，可能会取消注册，可能会影响执行过程中的 listenrs 数组。因此不能使用同一份数组。</li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.5ddec74e.js" defer></script><script src="/assets/js/2.dc0afc93.js" defer></script><script src="/assets/js/50.8136119e.js" defer></script>
  </body>
</html>
