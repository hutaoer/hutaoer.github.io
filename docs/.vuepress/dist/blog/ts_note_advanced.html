<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>TypeScript 学习笔记 —— 高级 | 逗逼码农</title>
    <meta name="generator" content="VuePress 1.9.9">
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?97584138af9a81f074d821256641e300";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    <meta name="description" content="持续提升，降低欲望；乐观幽默，自律坦然">
    
    <link rel="preload" href="/assets/css/0.styles.e8e4f3a3.css" as="style"><link rel="preload" href="/assets/js/app.a505bd13.js" as="script"><link rel="preload" href="/assets/js/2.07f3c95d.js" as="script"><link rel="preload" href="/assets/js/9.f5dee991.js" as="script"><link rel="prefetch" href="/assets/js/10.ffc1418c.js"><link rel="prefetch" href="/assets/js/11.07a60222.js"><link rel="prefetch" href="/assets/js/12.2db488c0.js"><link rel="prefetch" href="/assets/js/13.6a126940.js"><link rel="prefetch" href="/assets/js/14.bf2c12e9.js"><link rel="prefetch" href="/assets/js/15.0a607308.js"><link rel="prefetch" href="/assets/js/16.5f4b031f.js"><link rel="prefetch" href="/assets/js/17.a7b4dae5.js"><link rel="prefetch" href="/assets/js/18.2d71f503.js"><link rel="prefetch" href="/assets/js/19.bed63901.js"><link rel="prefetch" href="/assets/js/20.abc1d5d0.js"><link rel="prefetch" href="/assets/js/21.528a62dc.js"><link rel="prefetch" href="/assets/js/22.41b7540e.js"><link rel="prefetch" href="/assets/js/23.b7a4bc49.js"><link rel="prefetch" href="/assets/js/24.0b29bf2e.js"><link rel="prefetch" href="/assets/js/25.214cf900.js"><link rel="prefetch" href="/assets/js/26.49a39e9a.js"><link rel="prefetch" href="/assets/js/27.d4e0211a.js"><link rel="prefetch" href="/assets/js/28.cec7e5de.js"><link rel="prefetch" href="/assets/js/29.e80c44a8.js"><link rel="prefetch" href="/assets/js/3.d6b692e8.js"><link rel="prefetch" href="/assets/js/30.cac7774e.js"><link rel="prefetch" href="/assets/js/31.fbc9d6f0.js"><link rel="prefetch" href="/assets/js/32.1248f33b.js"><link rel="prefetch" href="/assets/js/33.47bbae98.js"><link rel="prefetch" href="/assets/js/34.980ae989.js"><link rel="prefetch" href="/assets/js/35.3db781b0.js"><link rel="prefetch" href="/assets/js/36.34bfb4db.js"><link rel="prefetch" href="/assets/js/37.07e5a38f.js"><link rel="prefetch" href="/assets/js/38.bdcbee17.js"><link rel="prefetch" href="/assets/js/39.2d7f4ac6.js"><link rel="prefetch" href="/assets/js/4.045757b5.js"><link rel="prefetch" href="/assets/js/40.ce6ebee3.js"><link rel="prefetch" href="/assets/js/41.fd378062.js"><link rel="prefetch" href="/assets/js/42.77a2ad02.js"><link rel="prefetch" href="/assets/js/43.1a210d97.js"><link rel="prefetch" href="/assets/js/44.e3c6491d.js"><link rel="prefetch" href="/assets/js/45.45f4a47a.js"><link rel="prefetch" href="/assets/js/46.f04f8f67.js"><link rel="prefetch" href="/assets/js/47.409d6182.js"><link rel="prefetch" href="/assets/js/48.4b2e8fa5.js"><link rel="prefetch" href="/assets/js/49.b2e5f2ca.js"><link rel="prefetch" href="/assets/js/5.d2f3d5f9.js"><link rel="prefetch" href="/assets/js/50.7ba90205.js"><link rel="prefetch" href="/assets/js/51.3431b8ff.js"><link rel="prefetch" href="/assets/js/52.154357cc.js"><link rel="prefetch" href="/assets/js/53.20b5cd9a.js"><link rel="prefetch" href="/assets/js/54.8c67b707.js"><link rel="prefetch" href="/assets/js/55.17a60a98.js"><link rel="prefetch" href="/assets/js/56.e584623d.js"><link rel="prefetch" href="/assets/js/57.a10a45ac.js"><link rel="prefetch" href="/assets/js/58.f4e74a6a.js"><link rel="prefetch" href="/assets/js/59.5ee27c9c.js"><link rel="prefetch" href="/assets/js/6.dbf9f127.js"><link rel="prefetch" href="/assets/js/60.bb4fc5b2.js"><link rel="prefetch" href="/assets/js/61.487cd1ec.js"><link rel="prefetch" href="/assets/js/62.491b5b3e.js"><link rel="prefetch" href="/assets/js/63.1b7b1318.js"><link rel="prefetch" href="/assets/js/64.030356e9.js"><link rel="prefetch" href="/assets/js/65.d7eb1ae5.js"><link rel="prefetch" href="/assets/js/66.b1ed4eff.js"><link rel="prefetch" href="/assets/js/67.21e1984d.js"><link rel="prefetch" href="/assets/js/68.7193aa87.js"><link rel="prefetch" href="/assets/js/69.a7cd9e82.js"><link rel="prefetch" href="/assets/js/7.c0484196.js"><link rel="prefetch" href="/assets/js/70.e5a248f4.js"><link rel="prefetch" href="/assets/js/71.5e9136f8.js"><link rel="prefetch" href="/assets/js/72.8685cb4d.js"><link rel="prefetch" href="/assets/js/73.bbf843ac.js"><link rel="prefetch" href="/assets/js/74.e5f40b60.js"><link rel="prefetch" href="/assets/js/75.e0094006.js"><link rel="prefetch" href="/assets/js/76.b418eab2.js"><link rel="prefetch" href="/assets/js/77.616c5637.js"><link rel="prefetch" href="/assets/js/78.5d4d8721.js"><link rel="prefetch" href="/assets/js/79.9765b875.js"><link rel="prefetch" href="/assets/js/8.ad10c1b9.js"><link rel="prefetch" href="/assets/js/80.60870e16.js"><link rel="prefetch" href="/assets/js/81.a5de441d.js"><link rel="prefetch" href="/assets/js/82.0aae8ffd.js"><link rel="prefetch" href="/assets/js/83.7c2a30a0.js"><link rel="prefetch" href="/assets/js/84.66d3fcf5.js"><link rel="prefetch" href="/assets/js/85.9f4e0302.js"><link rel="prefetch" href="/assets/js/86.a9682259.js"><link rel="prefetch" href="/assets/js/87.b6b3eb34.js"><link rel="prefetch" href="/assets/js/88.02a85812.js"><link rel="prefetch" href="/assets/js/89.863dd0c6.js"><link rel="prefetch" href="/assets/js/90.a398d1f7.js"><link rel="prefetch" href="/assets/js/91.0f47ea5a.js"><link rel="prefetch" href="/assets/js/92.b6cde156.js"><link rel="prefetch" href="/assets/js/93.604a027c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e8e4f3a3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">逗逼码农</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://www.cnblogs.com/hutaoer/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  旧的博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/hutaoer" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://www.cnblogs.com/hutaoer/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  旧的博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/hutaoer" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>TypeScript 学习笔记 —— 高级</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/ts_note_advanced.html#泛型" class="sidebar-link">泛型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ts_note_advanced.html#泛型参数设置默认类型" class="sidebar-link">泛型参数设置默认类型</a></li><li class="sidebar-sub-header"><a href="/blog/ts_note_advanced.html#泛型类型与泛型接口" class="sidebar-link">泛型类型与泛型接口</a></li><li class="sidebar-sub-header"><a href="/blog/ts_note_advanced.html#泛型类" class="sidebar-link">泛型类</a></li><li class="sidebar-sub-header"><a href="/blog/ts_note_advanced.html#泛型约束" class="sidebar-link">泛型约束</a></li></ul></li><li><a href="/blog/ts_note_advanced.html#类型兼容性" class="sidebar-link">类型兼容性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ts_note_advanced.html#函数" class="sidebar-link">函数</a></li><li class="sidebar-sub-header"><a href="/blog/ts_note_advanced.html#枚举" class="sidebar-link">枚举</a></li><li class="sidebar-sub-header"><a href="/blog/ts_note_advanced.html#类" class="sidebar-link">类</a></li><li class="sidebar-sub-header"><a href="/blog/ts_note_advanced.html#泛型-2" class="sidebar-link">泛型</a></li></ul></li><li><a href="/blog/ts_note_advanced.html#交叉类型" class="sidebar-link">交叉类型</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/ts_note_advanced.html#联合类型" class="sidebar-link">联合类型</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/ts_note_advanced.html#联合、交叉组合的优先级" class="sidebar-link">联合、交叉组合的优先级</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/ts_note_advanced.html#类型别名" class="sidebar-link">类型别名</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/ts_note_advanced.html#索引" class="sidebar-link">索引</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ts_note_advanced.html#查询操作符-keyof" class="sidebar-link">查询操作符：keyof</a></li><li class="sidebar-sub-header"><a href="/blog/ts_note_advanced.html#索引访问操作符-t-k" class="sidebar-link">索引访问操作符 - T[K]</a></li></ul></li><li><a href="/blog/ts_note_advanced.html#映射类型" class="sidebar-link">映射类型</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/ts_note_advanced.html#条件类型" class="sidebar-link">条件类型</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/ts_note_advanced.html#is-关键字" class="sidebar-link">is 关键字</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/ts_note_advanced.html#infer-关键字" class="sidebar-link">infer 关键字</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/ts_note_advanced.html#iterator" class="sidebar-link">iterator</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ts_note_advanced.html#for-of" class="sidebar-link">for...of</a></li></ul></li><li><a href="/blog/ts_note_advanced.html#生成器" class="sidebar-link">生成器</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/ts_note_advanced.html#装饰器" class="sidebar-link">装饰器</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="typescript-学习笔记-高级"><a href="#typescript-学习笔记-高级" class="header-anchor">#</a> TypeScript 学习笔记 —— 高级</h1> <h2 id="泛型"><a href="#泛型" class="header-anchor">#</a> 泛型</h2> <ul><li>Java中泛型的解释：类型参数化，将原来某种具体的类型进行参数化，约束类型成员之间的关系。</li> <li>我们可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。泛型是指在定义函数、接口或者类时，未指定其参数类型，只有在运行时传入才能确定。那么此时的参数类型就是一个变量，通常用大写字母 T 来表示。</li> <li>语法：函数名、接口名或者类名添加后缀 <code>&lt;T&gt;</code></li> <li>定义多个泛型类型参数，通过逗号来分割，例如：<code>&lt;T, U, K&gt;。</code></li> <li>调用泛型函数时受泛型约束的参数有传值，泛型参数的入参可以从参数的类型进行推断，而无须显示指定类型。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> fn<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">MyData</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token constant">T</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token constant">T</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="泛型参数设置默认类型"><a href="#泛型参数设置默认类型" class="header-anchor">#</a> 泛型参数设置默认类型</h3> <ul><li>语法：<code>&lt;T = 默认类型&gt;</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> fn<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> string<span class="token operator">&gt;</span><span class="token punctuation">(</span>arr<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="泛型类型与泛型接口"><a href="#泛型类型与泛型接口" class="header-anchor">#</a> 泛型类型与泛型接口</h3> <h4 id="泛型类型"><a href="#泛型类型" class="header-anchor">#</a> 泛型类型</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> fn<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span><span class="token keyword">return</span> arg<span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token literal-property property">fn1</span><span class="token operator">:</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">arg</span><span class="token operator">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token operator">=</span> fn
<span class="token keyword">let</span> <span class="token literal-property property">fn2</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">}</span> <span class="token operator">=</span> fn
<span class="token comment">// &lt;T&gt;(arg: T) =&gt; T 即为泛型类型，</span>
<span class="token comment">// 等同于带有调用签名的对象字面量书写方式：{ &lt;T&gt;(arg: T): T }:</span>
</code></pre></div><h5 id="分配条件类型"><a href="#分配条件类型" class="header-anchor">#</a> 分配条件类型</h5> <ul><li>在条件类型判断情况下（出现 extends）,如果入参是联合类型，则会被拆解成一个个独立的原子类型进行类型计算。</li></ul> <h4 id="泛型接口"><a href="#泛型接口" class="header-anchor">#</a> 泛型接口</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">Fn</span> <span class="token punctuation">{</span>
	<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token literal-property property">myFn</span><span class="token operator">:</span> <span class="token function-variable function">Fn</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span><span class="token keyword">return</span> arg<span class="token punctuation">}</span>

<span class="token comment">// 泛型参数当作整个接口的一个参数，我们可以把泛型参数提前到接口名上。</span>
<span class="token comment">// 使用的时候，需要指定泛型参数的类型</span>
<span class="token keyword">interface</span> <span class="token class-name">Fn1</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
	<span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> 
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token literal-property property">fn1</span><span class="token operator">:</span> Fn1<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">s</span><span class="token operator">:</span>string</span><span class="token punctuation">)</span><span class="token operator">:</span>string <span class="token punctuation">{</span><span class="token keyword">return</span> s<span class="token punctuation">}</span>
</code></pre></div><h3 id="泛型类"><a href="#泛型类" class="header-anchor">#</a> 泛型类</h3> <ul><li>声明 类 <code>MyClass</code> 的后面后加上了 <code>&lt;T&gt;</code>，这样就声明了泛型参数 T</li></ul> <h3 id="泛型约束"><a href="#泛型约束" class="header-anchor">#</a> 泛型约束</h3> <ul><li>如果很明确传入的泛型参数是什么类型，或者明确想要操作的某类型的值具有什么属性，那么就需要对泛型进行约束。
<ul><li>让泛型继承一个接口，那么传入的泛型类型就必须包含接口中的成员，从而达到对泛型的约束。</li> <li>也可以让泛型继承几个类型。</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 接口</span>
<span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">name</span><span class="token operator">:</span> string
<span class="token punctuation">}</span>
<span class="token keyword">function</span> fn<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>user<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> string <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 类型</span>
type Args <span class="token operator">=</span> number <span class="token operator">|</span> string 
<span class="token keyword">class</span> <span class="token class-name">Demo</span><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">Args</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token operator">&lt;</span>number<span class="token operator">&gt;</span> <span class="token comment">// 只能传入 Args 的类型</span>
</code></pre></div><ul><li>通过 <code>&lt;T extends Interface1 &amp; Interface2&gt;</code> 这种语法来实现多重类型的泛型约束</li></ul> <h2 id="类型兼容性"><a href="#类型兼容性" class="header-anchor">#</a> 类型兼容性</h2> <ul><li>指的是一个类型能否赋值给其他类型的规则。</li> <li>TypeScript 类型兼容性是基于结构类型的；结构类型只使用其成员来描述类型。</li></ul> <h3 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h3> <ul><li>如果函数 fn2 可以赋值给 fn1 的条件 <code>let fn1 = fn2</code> <ul><li>fn2 的每个参数均能在 fn1 中找到对应类型的参数</li> <li>参数顺序保持一致，参数类型对应</li> <li>参数名称不需要相同</li></ul></li> <li>函数返回值
<ul><li>类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型</li> <li>如果目标函数的返回值类型是 void，那么源函数返回值可以是任意类型：</li></ul></li></ul> <h3 id="枚举"><a href="#枚举" class="header-anchor">#</a> 枚举</h3> <ul><li>枚举与数字类型互相兼容</li> <li>不同枚举类型之间不兼容。</li> <li>如果枚举仅有一个字面量成员，则成员的类型就等于枚举类型，可以互相兼容。</li></ul> <h4 id="数字枚举"><a href="#数字枚举" class="header-anchor">#</a> 数字枚举</h4> <ul><li>默认从0开始，要想定义从其他数值开始，则手动赋值(包括负数、小数)，后面的枚举成员值，都会递增加1</li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">enum</span> <span class="token constant">WEEK</span> <span class="token punctuation">{</span>
  monday <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
  tuesday<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>可以给任意的成员变量赋值，但需要注意有+1的规则在，可能会出现值相同的成员。不建议这么做。</li> <li>两个命名，顺序一致的枚举值，其同名成员值一样，但TS认为它们不相同，也不恒等。</li></ul> <h4 id="字符串枚举"><a href="#字符串枚举" class="header-anchor">#</a> 字符串枚举</h4> <h4 id="异构枚举"><a href="#异构枚举" class="header-anchor">#</a> 异构枚举</h4> <ul><li>枚举成员同时支持数字和字符类型。使用场景较少</li></ul> <h4 id="外部枚举"><a href="#外部枚举" class="header-anchor">#</a> 外部枚举</h4> <ul><li>使用<code>declare</code>描述一个在其他地方已经定义过的枚举类型。</li> <li>外部枚举转译为js代码后，跟常规枚举的区别是，会编译为对外部对象的引用。而不是直接的常量。</li></ul> <h3 id="类"><a href="#类" class="header-anchor">#</a> 类</h3> <ul><li>类分为实例部分和静态部分。比较两个类类型数据时，只有实例成员会被比较，静态成员和构造函数不会比较。</li> <li>类的私有成员和受保护成员会影响兼容性。</li></ul> <h3 id="泛型-2"><a href="#泛型-2" class="header-anchor">#</a> 泛型</h3> <ul><li>泛型的类型兼容性根据其是否被成员使用而不同。</li> <li>如果泛型参数类型不同，但泛型类型还未使用，则可以相互赋值。如果有使用，则不能赋值。</li> <li>没有指定泛型类型的泛型参数，会把所有泛型参数当成 any 类型比较，也可以赋值。</li></ul> <h2 id="交叉类型"><a href="#交叉类型" class="header-anchor">#</a> 交叉类型</h2> <ul><li>语法：<code>T &amp; U</code></li> <li>交叉类型是将多个类型合并为一个类型。它包含了所需的所有类型的特性。</li> <li>如果交叉类型中，有同名属性，且类型不一样，那么它最终的类型就是：never，且不能被赋值。比如，&quot;string &amp; number&quot;，就是一个never类型。</li> <li>真正有用的地方，是将多个接口进行交叉，实现接口的合并，并可形成接口继承的效果。</li> <li>如果合并的接口中，有同名类型，是什么效果。取决于同名的属性是否兼容。
<ul><li>同名属性类型兼容。则合并后的类型，为两个类型的子类型。</li> <li>同名属性类型不兼容。合并后的类型，就是不同类型进行交叉。</li></ul></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">interface</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> string
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> number
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">A</span> <span class="token operator">&amp;</span> <span class="token constant">B</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> string <span class="token operator">&amp;</span> number
<span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token literal-property property">ab</span><span class="token operator">:</span> <span class="token constant">A</span> <span class="token operator">&amp;</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'333'</span><span class="token punctuation">}</span> <span class="token comment">// 报错ts(2322)</span>
<span class="token keyword">const</span> <span class="token literal-property property">n</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token literal-property property">age</span><span class="token operator">:</span>number<span class="token punctuation">}</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span><span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">33</span><span class="token punctuation">}</span> <span class="token comment">// n 只能赋值33</span>
</code></pre></div><h2 id="联合类型"><a href="#联合类型" class="header-anchor">#</a> 联合类型</h2> <ul><li>如果一个值是联合类型，那么只能访问联合类型的共有属性或方法。</li> <li>交叉联合类型，相当于对交叉的联合类型取交集。如果交叉的两个联合类型，没有交集，则相当于never类型。</li> <li>string原始类型和string字面量类型联合，则<code>类型缩减</code>为原始类型。对于number,boolean也一样。</li> <li>如果要让缩减类型被控制，且在IDE中进行提示，给父类型添加<code>&amp; {}</code>即可，字面量就会被保留。</li> <li>联合类型的缩减规则是什么？</li></ul> <h2 id="联合、交叉组合的优先级"><a href="#联合、交叉组合的优先级" class="header-anchor">#</a> 联合、交叉组合的优先级</h2> <ul><li><code>|,&amp;</code>的优先级类似于js中的<code>||,&amp;&amp;</code></li> <li>且满足交换律和分配律</li></ul> <h2 id="类型别名"><a href="#类型别名" class="header-anchor">#</a> 类型别名</h2> <ul><li>使用<code>type</code>语法</li> <li>与接口的区别
<ul><li>接口可以实现 extends 和 implements，类型别名不行。</li> <li>类型别名并不会创建新类型，是对原有类型的引用，而接口会定义一个新类型。</li> <li>接口只能用于定义对象类型，而类型别名的声明方式除了对象之外还可以定义交叉、联合、原始类型等。</li> <li>相同的接口声明可以合并</li></ul></li> <li>TypeScript 推荐我们尽可能的使用接口来规范我们的代码。</li> <li>类型别名在定义交叉类型、联合类型。</li></ul> <h2 id="索引"><a href="#索引" class="header-anchor">#</a> 索引</h2> <ul><li>索引类型可以让 TypeScript 编译器覆盖检测到使用了动态属性名的代码。</li></ul> <h3 id="查询操作符-keyof"><a href="#查询操作符-keyof" class="header-anchor">#</a> 查询操作符：keyof</h3> <ul><li>对于任何类型 T，<code>keyof T</code> 的结果为 T 上已知的公共属性名的联合。</li></ul> <h3 id="索引访问操作符-t-k"><a href="#索引访问操作符-t-k" class="header-anchor">#</a> 索引访问操作符 - T[K]</h3> <ul><li>一个对象的类型为泛型 T，这个对象的属性类型 K 只需要满足 K extends keyof T，即可得到这个属性值的类型为 <code>T[K]</code>。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> getProperty<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token class-name">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>o<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> o<span class="token punctuation">[</span>name<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="映射类型"><a href="#映射类型" class="header-anchor">#</a> 映射类型</h2> <ul><li>属于工具类型。映射类型可以将已知类型的每个属性都变为可选的或者只读的。</li> <li>关键字：<code>Portial</code>、<code>Readonly</code></li> <li>映射类型的语法: <code>[K in Keys]</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> string
  <span class="token literal-property property">age</span><span class="token operator">:</span> number
<span class="token punctuation">}</span>

type PersonOptional <span class="token operator">=</span> Partial<span class="token operator">&lt;</span>Person<span class="token operator">&gt;</span>
type PersonReadonly <span class="token operator">=</span> Readonly<span class="token operator">&lt;</span>Person<span class="token operator">&gt;</span>

<span class="token comment">// 源码实现</span>
type Readonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  readonly <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> keyof <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token comment">// 映射类型的语法 [K in Keys]</span>
<span class="token punctuation">}</span>
type Partial<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> keyof <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="条件类型"><a href="#条件类型" class="header-anchor">#</a> 条件类型</h2> <ul><li>内置的工具类型。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>Exclude<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span> <span class="token comment">// 从 T 中剔除可以赋值给 U 的类型。</span>
Extract<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span> <span class="token comment">// 提取 T 中可以赋值给 U 的类型。</span>
NonNullable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token comment">// 从 T 中剔除 null 和 undefined。</span>
ReturnType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token comment">// 获取函数返回值类型。</span>
InstanceType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token comment">// 获取构造函数类型的实例类型。</span>
</code></pre></div><h2 id="is-关键字"><a href="#is-关键字" class="header-anchor">#</a> is 关键字</h2> <ul><li>被称为类型谓词，用来判断一个变量属于某个接口或类型。</li> <li><code>is</code> 关键字一般用于函数返回值类型中，判断参数是否属于某一类型，并根据结果返回对应的布尔类型。</li> <li>场景：对<code>unknown</code>类型的数据进行判断。<code>is</code> 关键字经常用来封装&quot;类型判断函数&quot;，通过和函数返回值的比较，从而缩小参数的类型范围，所以类型谓词 <code>is</code>也是一种类型保护。</li> <li>语法：<code>prop is type</code></li> <li>函数嵌套后， TypeScript 不能进行正确的类型判断。</li> <li>常见类型判断函数</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">const</span> isNumber <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token operator">:</span> unknown<span class="token punctuation">)</span><span class="token operator">:</span> val is <span class="token parameter">number</span> <span class="token operator">=&gt;</span> <span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">'number'</span>
<span class="token keyword">const</span> isString <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token operator">:</span> unknown<span class="token punctuation">)</span><span class="token operator">:</span> val is <span class="token parameter">string</span> <span class="token operator">=&gt;</span> <span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">'string'</span>
<span class="token keyword">const</span> isSymbol <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token operator">:</span> unknown<span class="token punctuation">)</span><span class="token operator">:</span> val is <span class="token parameter">symbol</span> <span class="token operator">=&gt;</span> <span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">'symbol'</span>
<span class="token keyword">const</span> isFunction <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token operator">:</span> unknown<span class="token punctuation">)</span><span class="token operator">:</span> val is <span class="token parameter">Function</span> <span class="token operator">=&gt;</span> <span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">'function'</span>
<span class="token keyword">const</span> isObject <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token operator">:</span> unknown<span class="token punctuation">)</span><span class="token operator">:</span> val is <span class="token parameter">Object</span> <span class="token operator">=&gt;</span> val <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">'object'</span>

<span class="token keyword">function</span> isPromise<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> any<span class="token operator">&gt;</span><span class="token punctuation">(</span>val<span class="token operator">:</span> unknown<span class="token punctuation">)</span><span class="token operator">:</span> val is Promise<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">isObject</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isFunction</span><span class="token punctuation">(</span>val<span class="token punctuation">.</span>then<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isFunction</span><span class="token punctuation">(</span>val<span class="token punctuation">.</span>catch<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="infer-关键字"><a href="#infer-关键字" class="header-anchor">#</a> infer 关键字</h2> <ul><li>声明一个不确定的类型变量。<code>infer R</code> 就是声明了一个类型变量 <code>R</code></li> <li>在条件类型表达式中，可以在 <code>extends</code> 条件语句中使用 <code>infer</code> 关键字来声明一个待推断的类型变量。</li> <li><code>infer</code>的作用是让 TypeScript 自己推断，并将推断的结果存储到一个类型变量中，<code>infer</code> 只能用于 <code>extends</code> 语句中。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>type ReturnType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args<span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> ang<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args<span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> infer <span class="token operator">:</span> <span class="token constant">U</span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> any

</code></pre></div><ul><li>如果<code>T</code> 满足某个约束条件，那么就返回这个类型变量，并存储在<code>infer U</code> 后面的的 <code>U</code> 中。</li> <li>借助条件类型的 infer 关键字来推断类型，可以实现一些比如联合类型转交叉类型、联合类型转元组的操作</li></ul> <h2 id="iterator"><a href="#iterator" class="header-anchor">#</a> iterator</h2> <ul><li>可迭代协议：允许 JavaScript 对象定义或定制它们的迭代行为。要成为可迭代对象， 一个对象必须实现 @@iterator 方法。可通过常量 Symbol.iterator 访问该属性。</li> <li>迭代器协议:
<ul><li>定义了产生一系列值（无论是有限个还是无限个）的标准方式。当值为有限个时，所有的值都被迭代完毕后，则会返回一个默认返回值。</li> <li>只有实现了一个拥有以下语义（semantic）的 next() 方法，一个对象才能成为迭代器。</li> <li>next() 方法的返回值类型是 { value: any, done: boolean }。其中，value 是 any 类型，表示下一个将要返回的值；done 是布尔类型，当没有更多可返回数据时返回 true。迭代器还会保存一个内部指针，用来指向当前集合中值的位置。</li></ul></li></ul> <h3 id="for-of"><a href="#for-of" class="header-anchor">#</a> for...of</h3> <ul><li><code>for...of</code> 会遍历可迭代的对象(包括 <code>Array，Map，Set，String，TypedArray，arguments</code> 对象等等)，调用对象上的 <code>Symbol.iterator</code> 方法。</li> <li><code>for...of</code> 语句遍历可迭代对象定义要迭代的数据。</li> <li><code>for...in</code> 语句以任意顺序迭代对象的可枚举属性。</li></ul> <h2 id="生成器"><a href="#生成器" class="header-anchor">#</a> 生成器</h2> <ul><li>生成器函数会返回一个对象，可以调用这个对象上的 next() 方法。</li> <li>在调用 next() 的时候可以传递一个参数，在上次 yield 前接收到这个参数：</li> <li>生成器最初没有产生任何结果，在第一次调用 next() 时传参是无意义的。</li></ul> <h2 id="装饰器"><a href="#装饰器" class="header-anchor">#</a> 装饰器</h2> <ul><li>装饰器是一种特殊类型的声明，它能够附加到类声明、方法、访问符、属性、类方法的参数上，以达到扩展类的行为。</li> <li>常见的装饰器有：类装饰器、属性装饰器、方法装饰器、参数装饰器。</li> <li>装饰器的写法：普通装饰器（无法传参）、 装饰器工厂（可传参）。</li> <li>执行顺序：先执行装饰器函数，再执行被装饰的函数。</li> <li>类装饰器函数表达式将构造函数作为唯一的参数，主要用于扩展类的属性和方法。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a505bd13.js" defer></script><script src="/assets/js/2.07f3c95d.js" defer></script><script src="/assets/js/9.f5dee991.js" defer></script>
  </body>
</html>
